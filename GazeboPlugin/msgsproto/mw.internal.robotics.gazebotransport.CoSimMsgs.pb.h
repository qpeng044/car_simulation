// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mw.internal.robotics.gazebotransport.CoSimMsgs.proto

#ifndef PROTOBUF_INCLUDED_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto
#define PROTOBUF_INCLUDED_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto 

namespace protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[47];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto
namespace mw {
namespace internal {
namespace robotics {
namespace gazebotransport {
class ApplyJointTorque;
class ApplyJointTorqueDefaultTypeInternal;
extern ApplyJointTorqueDefaultTypeInternal _ApplyJointTorque_default_instance_;
class ApplyLinkWrench;
class ApplyLinkWrenchDefaultTypeInternal;
extern ApplyLinkWrenchDefaultTypeInternal _ApplyLinkWrench_default_instance_;
class Axis;
class AxisDefaultTypeInternal;
extern AxisDefaultTypeInternal _Axis_default_instance_;
class CustomMessageSupport;
class CustomMessageSupportDefaultTypeInternal;
extern CustomMessageSupportDefaultTypeInternal _CustomMessageSupport_default_instance_;
class GetGroundTruthWorldPose;
class GetGroundTruthWorldPoseDefaultTypeInternal;
extern GetGroundTruthWorldPoseDefaultTypeInternal _GetGroundTruthWorldPose_default_instance_;
class GetJointState;
class GetJointStateDefaultTypeInternal;
extern GetJointStateDefaultTypeInternal _GetJointState_default_instance_;
class GetLinkState;
class GetLinkStateDefaultTypeInternal;
extern GetLinkStateDefaultTypeInternal _GetLinkState_default_instance_;
class GetModelInfo;
class GetModelInfoDefaultTypeInternal;
extern GetModelInfoDefaultTypeInternal _GetModelInfo_default_instance_;
class GetPose;
class GetPoseDefaultTypeInternal;
extern GetPoseDefaultTypeInternal _GetPose_default_instance_;
class GetTopicList;
class GetTopicListDefaultTypeInternal;
extern GetTopicListDefaultTypeInternal _GetTopicList_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class ImuData;
class ImuDataDefaultTypeInternal;
extern ImuDataDefaultTypeInternal _ImuData_default_instance_;
class InitCustomPublisher;
class InitCustomPublisherDefaultTypeInternal;
extern InitCustomPublisherDefaultTypeInternal _InitCustomPublisher_default_instance_;
class InitCustomSubscriber;
class InitCustomSubscriberDefaultTypeInternal;
extern InitCustomSubscriberDefaultTypeInternal _InitCustomSubscriber_default_instance_;
class JointState;
class JointStateDefaultTypeInternal;
extern JointStateDefaultTypeInternal _JointState_default_instance_;
class LaserData;
class LaserDataDefaultTypeInternal;
extern LaserDataDefaultTypeInternal _LaserData_default_instance_;
class LinkState;
class LinkStateDefaultTypeInternal;
extern LinkStateDefaultTypeInternal _LinkState_default_instance_;
class MaxStepSize;
class MaxStepSizeDefaultTypeInternal;
extern MaxStepSizeDefaultTypeInternal _MaxStepSize_default_instance_;
class ModelInfo;
class ModelInfoDefaultTypeInternal;
extern ModelInfoDefaultTypeInternal _ModelInfo_default_instance_;
class ModelInfo_JOINTS;
class ModelInfo_JOINTSDefaultTypeInternal;
extern ModelInfo_JOINTSDefaultTypeInternal _ModelInfo_JOINTS_default_instance_;
class ModelInfo_LINKS;
class ModelInfo_LINKSDefaultTypeInternal;
extern ModelInfo_LINKSDefaultTypeInternal _ModelInfo_LINKS_default_instance_;
class ModelInfo_Model;
class ModelInfo_ModelDefaultTypeInternal;
extern ModelInfo_ModelDefaultTypeInternal _ModelInfo_Model_default_instance_;
class Packet;
class PacketDefaultTypeInternal;
extern PacketDefaultTypeInternal _Packet_default_instance_;
class PacketHeader;
class PacketHeaderDefaultTypeInternal;
extern PacketHeaderDefaultTypeInternal _PacketHeader_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class RequestCoSim;
class RequestCoSimDefaultTypeInternal;
extern RequestCoSimDefaultTypeInternal _RequestCoSim_default_instance_;
class RequestCustomMessageSupport;
class RequestCustomMessageSupportDefaultTypeInternal;
extern RequestCustomMessageSupportDefaultTypeInternal _RequestCustomMessageSupport_default_instance_;
class RequestImage;
class RequestImageDefaultTypeInternal;
extern RequestImageDefaultTypeInternal _RequestImage_default_instance_;
class RequestImu;
class RequestImuDefaultTypeInternal;
extern RequestImuDefaultTypeInternal _RequestImu_default_instance_;
class RequestLaser;
class RequestLaserDefaultTypeInternal;
extern RequestLaserDefaultTypeInternal _RequestLaser_default_instance_;
class ResetSimulation;
class ResetSimulationDefaultTypeInternal;
extern ResetSimulationDefaultTypeInternal _ResetSimulation_default_instance_;
class SetJointPosition;
class SetJointPositionDefaultTypeInternal;
extern SetJointPositionDefaultTypeInternal _SetJointPosition_default_instance_;
class SetJointVelocity;
class SetJointVelocityDefaultTypeInternal;
extern SetJointVelocityDefaultTypeInternal _SetJointVelocity_default_instance_;
class SetLinkAngularVelocity;
class SetLinkAngularVelocityDefaultTypeInternal;
extern SetLinkAngularVelocityDefaultTypeInternal _SetLinkAngularVelocity_default_instance_;
class SetLinkLinearVelocity;
class SetLinkLinearVelocityDefaultTypeInternal;
extern SetLinkLinearVelocityDefaultTypeInternal _SetLinkLinearVelocity_default_instance_;
class SetLinkWorldPose;
class SetLinkWorldPoseDefaultTypeInternal;
extern SetLinkWorldPoseDefaultTypeInternal _SetLinkWorldPose_default_instance_;
class StepSimulation;
class StepSimulationDefaultTypeInternal;
extern StepSimulationDefaultTypeInternal _StepSimulation_default_instance_;
class StopCoSim;
class StopCoSimDefaultTypeInternal;
extern StopCoSimDefaultTypeInternal _StopCoSim_default_instance_;
class StopSimulation;
class StopSimulationDefaultTypeInternal;
extern StopSimulationDefaultTypeInternal _StopSimulation_default_instance_;
class SubscribeImage;
class SubscribeImageDefaultTypeInternal;
extern SubscribeImageDefaultTypeInternal _SubscribeImage_default_instance_;
class SubscribeImu;
class SubscribeImuDefaultTypeInternal;
extern SubscribeImuDefaultTypeInternal _SubscribeImu_default_instance_;
class SubscribeLaser;
class SubscribeLaserDefaultTypeInternal;
extern SubscribeLaserDefaultTypeInternal _SubscribeLaser_default_instance_;
class Time;
class TimeDefaultTypeInternal;
extern TimeDefaultTypeInternal _Time_default_instance_;
class TopicList;
class TopicListDefaultTypeInternal;
extern TopicListDefaultTypeInternal _TopicList_default_instance_;
class TopicList_TopicInfo;
class TopicList_TopicInfoDefaultTypeInternal;
extern TopicList_TopicInfoDefaultTypeInternal _TopicList_TopicInfo_default_instance_;
}  // namespace gazebotransport
}  // namespace robotics
}  // namespace internal
}  // namespace mw
namespace google {
namespace protobuf {
template<> ::mw::internal::robotics::gazebotransport::ApplyJointTorque* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ApplyJointTorque>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ApplyLinkWrench>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::Axis* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Axis>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::CustomMessageSupport* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::CustomMessageSupport>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::GetJointState* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::GetJointState>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::GetLinkState* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::GetLinkState>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::GetModelInfo* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::GetModelInfo>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::GetPose* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::GetPose>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::GetTopicList* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::GetTopicList>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::Image* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Image>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ImuData* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ImuData>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::InitCustomPublisher* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::InitCustomPublisher>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::InitCustomSubscriber>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::JointState* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::JointState>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::LaserData* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::LaserData>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::LinkState* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::LinkState>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::MaxStepSize* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::MaxStepSize>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ModelInfo* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ModelInfo>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ModelInfo_LINKS>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ModelInfo_Model* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ModelInfo_Model>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::Packet* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Packet>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::PacketHeader* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::PacketHeader>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::Point* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::Pose* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Pose>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::Quaternion* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Quaternion>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::RequestCoSim* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::RequestCoSim>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::RequestImage* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::RequestImage>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::RequestImu* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::RequestImu>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::RequestLaser* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::RequestLaser>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::ResetSimulation* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ResetSimulation>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::SetJointPosition* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::SetJointPosition>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::SetJointVelocity* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::SetJointVelocity>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::SetLinkWorldPose>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::StepSimulation* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::StepSimulation>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::StopCoSim* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::StopCoSim>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::StopSimulation* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::StopSimulation>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::SubscribeImage* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::SubscribeImage>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::SubscribeImu* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::SubscribeImu>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::SubscribeLaser* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::SubscribeLaser>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::Time* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::TopicList* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::TopicList>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::TopicList_TopicInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace mw {
namespace internal {
namespace robotics {
namespace gazebotransport {

enum PacketHeader_MsgID {
  PacketHeader_MsgID_STATUS = 0,
  PacketHeader_MsgID_STEP_SIMULATION = 1,
  PacketHeader_MsgID_RESET_SIMULATION = 2,
  PacketHeader_MsgID_IMAGE = 3,
  PacketHeader_MsgID_REQUEST_IMAGE = 4,
  PacketHeader_MsgID_REQUEST_COSIM = 5,
  PacketHeader_MsgID_STOP_COSIM = 6,
  PacketHeader_MsgID_GET_GROUND_TRUTH_WORLD_POSE = 7,
  PacketHeader_MsgID_POSE = 8,
  PacketHeader_MsgID_STOP_SIMULATION = 9,
  PacketHeader_MsgID_LASER_DATA = 10,
  PacketHeader_MsgID_REQUEST_LASER = 11,
  PacketHeader_MsgID_IMU_DATA = 12,
  PacketHeader_MsgID_REQUEST_IMU = 13,
  PacketHeader_MsgID_SUBSCRIBE_IMAGE = 14,
  PacketHeader_MsgID_SUBSCRIBE_LASER = 15,
  PacketHeader_MsgID_SUBSCRIBE_IMU = 16,
  PacketHeader_MsgID_APPLY_JOINT_TORQUE = 17,
  PacketHeader_MsgID_GET_POSE = 18,
  PacketHeader_MsgID_GET_TOPIC_LIST = 19,
  PacketHeader_MsgID_TOPIC_LIST = 20,
  PacketHeader_MsgID_GET_MODEL_INFO = 21,
  PacketHeader_MsgID_MODEL_INFO = 22,
  PacketHeader_MsgID_APPLY_LINK_WRENCH = 23,
  PacketHeader_MsgID_MAX_STEP_SIZE = 24,
  PacketHeader_MsgID_CUSTOM_MESSAGE_SUBSCRIBER = 25,
  PacketHeader_MsgID_CUSTOM_MESSAGE_PUBLISHER = 26,
  PacketHeader_MsgID_INIT_CUSTOM_MESSAGE_PUBLISHER = 27,
  PacketHeader_MsgID_INIT_CUSTOM_MESSAGE_SUBSCRIBER = 28,
  PacketHeader_MsgID_SET_JOINT_POSITION = 29,
  PacketHeader_MsgID_SET_JOINT_VELOCITY = 30,
  PacketHeader_MsgID_GET_JOINT_STATE = 31,
  PacketHeader_MsgID_JOINT_STATE = 32,
  PacketHeader_MsgID_SET_LINK_WORLD_POSE = 33,
  PacketHeader_MsgID_SET_LINK_LINEAR_VELOCITY = 34,
  PacketHeader_MsgID_SET_LINK_ANGULAR_VELOCITY = 35,
  PacketHeader_MsgID_GET_LINK_STATE = 36,
  PacketHeader_MsgID_LINK_STATE = 37
};
bool PacketHeader_MsgID_IsValid(int value);
const PacketHeader_MsgID PacketHeader_MsgID_MsgID_MIN = PacketHeader_MsgID_STATUS;
const PacketHeader_MsgID PacketHeader_MsgID_MsgID_MAX = PacketHeader_MsgID_LINK_STATE;
const int PacketHeader_MsgID_MsgID_ARRAYSIZE = PacketHeader_MsgID_MsgID_MAX + 1;

const ::google::protobuf::EnumDescriptor* PacketHeader_MsgID_descriptor();
inline const ::std::string& PacketHeader_MsgID_Name(PacketHeader_MsgID value) {
  return ::google::protobuf::internal::NameOfEnum(
    PacketHeader_MsgID_descriptor(), value);
}
inline bool PacketHeader_MsgID_Parse(
    const ::std::string& name, PacketHeader_MsgID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PacketHeader_MsgID>(
    PacketHeader_MsgID_descriptor(), name, value);
}
enum Packet_CoSimError {
  Packet_CoSimError_NONE = 0,
  Packet_CoSimError_STEP_FAILED = 1,
  Packet_CoSimError_MSG_INVALID = 2,
  Packet_CoSimError_SOCKET_FAILED = 3,
  Packet_CoSimError_RESET_FAILED = 4,
  Packet_CoSimError_COSIM_FAILED = 5,
  Packet_CoSimError_STOP_COSIM_FAILED = 6,
  Packet_CoSimError_GET_GROUND_TRUTH_WORLD_POSE_FAILED = 7,
  Packet_CoSimError_RESET_TIME_SCENE_FAILED = 8,
  Packet_CoSimError_RESET_TIME_FAILED = 9,
  Packet_CoSimError_STOP_FAILED = 10,
  Packet_CoSimError_FORCE_TYPE_INVALID = 11,
  Packet_CoSimError_MODEL_NAME_INVALID = 12,
  Packet_CoSimError_LINK_NAME_INVALID = 13,
  Packet_CoSimError_JOINT_NAME_INVALID = 14,
  Packet_CoSimError_TOPIC_NAME_INVALID = 15,
  Packet_CoSimError_TORQUE_TYPE_INVALID = 16,
  Packet_CoSimError_MAX_STEP_SIZE_ERROR = 17,
  Packet_CoSimError_CUSTOM_MESSAGE_INVALID = 18,
  Packet_CoSimError_MESSAGE_TYPE_INVALID = 19
};
bool Packet_CoSimError_IsValid(int value);
const Packet_CoSimError Packet_CoSimError_CoSimError_MIN = Packet_CoSimError_NONE;
const Packet_CoSimError Packet_CoSimError_CoSimError_MAX = Packet_CoSimError_MESSAGE_TYPE_INVALID;
const int Packet_CoSimError_CoSimError_ARRAYSIZE = Packet_CoSimError_CoSimError_MAX + 1;

const ::google::protobuf::EnumDescriptor* Packet_CoSimError_descriptor();
inline const ::std::string& Packet_CoSimError_Name(Packet_CoSimError value) {
  return ::google::protobuf::internal::NameOfEnum(
    Packet_CoSimError_descriptor(), value);
}
inline bool Packet_CoSimError_Parse(
    const ::std::string& name, Packet_CoSimError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Packet_CoSimError>(
    Packet_CoSimError_descriptor(), name, value);
}
enum ResetSimulation_ResetBehavior {
  ResetSimulation_ResetBehavior_RESET_TIME = 0,
  ResetSimulation_ResetBehavior_RESET_TIME_AND_SCENE = 1
};
bool ResetSimulation_ResetBehavior_IsValid(int value);
const ResetSimulation_ResetBehavior ResetSimulation_ResetBehavior_ResetBehavior_MIN = ResetSimulation_ResetBehavior_RESET_TIME;
const ResetSimulation_ResetBehavior ResetSimulation_ResetBehavior_ResetBehavior_MAX = ResetSimulation_ResetBehavior_RESET_TIME_AND_SCENE;
const int ResetSimulation_ResetBehavior_ResetBehavior_ARRAYSIZE = ResetSimulation_ResetBehavior_ResetBehavior_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResetSimulation_ResetBehavior_descriptor();
inline const ::std::string& ResetSimulation_ResetBehavior_Name(ResetSimulation_ResetBehavior value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResetSimulation_ResetBehavior_descriptor(), value);
}
inline bool ResetSimulation_ResetBehavior_Parse(
    const ::std::string& name, ResetSimulation_ResetBehavior* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResetSimulation_ResetBehavior>(
    ResetSimulation_ResetBehavior_descriptor(), name, value);
}
enum MaxStepSize_TYPE {
  MaxStepSize_TYPE_SET_STEP_SIZE = 0,
  MaxStepSize_TYPE_GET_STEP_SIZE = 1
};
bool MaxStepSize_TYPE_IsValid(int value);
const MaxStepSize_TYPE MaxStepSize_TYPE_TYPE_MIN = MaxStepSize_TYPE_SET_STEP_SIZE;
const MaxStepSize_TYPE MaxStepSize_TYPE_TYPE_MAX = MaxStepSize_TYPE_GET_STEP_SIZE;
const int MaxStepSize_TYPE_TYPE_ARRAYSIZE = MaxStepSize_TYPE_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* MaxStepSize_TYPE_descriptor();
inline const ::std::string& MaxStepSize_TYPE_Name(MaxStepSize_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    MaxStepSize_TYPE_descriptor(), value);
}
inline bool MaxStepSize_TYPE_Parse(
    const ::std::string& name, MaxStepSize_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MaxStepSize_TYPE>(
    MaxStepSize_TYPE_descriptor(), name, value);
}
enum JointState_Joint_Type {
  JointState_Joint_Type_REVOLUTE = 1,
  JointState_Joint_Type_REVOLUTE2 = 2,
  JointState_Joint_Type_PRISMATIC = 3,
  JointState_Joint_Type_UNIVERSAL = 4,
  JointState_Joint_Type_BALL = 5,
  JointState_Joint_Type_SCREW = 6,
  JointState_Joint_Type_GEARBOX = 7,
  JointState_Joint_Type_FIXED = 8
};
bool JointState_Joint_Type_IsValid(int value);
const JointState_Joint_Type JointState_Joint_Type_Joint_Type_MIN = JointState_Joint_Type_REVOLUTE;
const JointState_Joint_Type JointState_Joint_Type_Joint_Type_MAX = JointState_Joint_Type_FIXED;
const int JointState_Joint_Type_Joint_Type_ARRAYSIZE = JointState_Joint_Type_Joint_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* JointState_Joint_Type_descriptor();
inline const ::std::string& JointState_Joint_Type_Name(JointState_Joint_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    JointState_Joint_Type_descriptor(), value);
}
inline bool JointState_Joint_Type_Parse(
    const ::std::string& name, JointState_Joint_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<JointState_Joint_Type>(
    JointState_Joint_Type_descriptor(), name, value);
}
// ===================================================================

class Time : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Time) */ {
 public:
  Time();
  virtual ~Time();

  Time(const Time& from);

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Time(Time&& from) noexcept
    : Time() {
    *this = ::std::move(from);
  }

  inline Time& operator=(Time&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Time& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Time* internal_default_instance() {
    return reinterpret_cast<const Time*>(
               &_Time_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Time* other);
  friend void swap(Time& a, Time& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Time* New() const final {
    return CreateMaybeMessage<Time>(NULL);
  }

  Time* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Time>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Time* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 seconds = 1;
  bool has_seconds() const;
  void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  ::google::protobuf::uint64 seconds() const;
  void set_seconds(::google::protobuf::uint64 value);

  // required uint64 nano_seconds = 2;
  bool has_nano_seconds() const;
  void clear_nano_seconds();
  static const int kNanoSecondsFieldNumber = 2;
  ::google::protobuf::uint64 nano_seconds() const;
  void set_nano_seconds(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Time)
 private:
  void set_has_seconds();
  void clear_has_seconds();
  void set_has_nano_seconds();
  void clear_has_nano_seconds();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 seconds_;
  ::google::protobuf::uint64 nano_seconds_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PacketHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.PacketHeader) */ {
 public:
  PacketHeader();
  virtual ~PacketHeader();

  PacketHeader(const PacketHeader& from);

  inline PacketHeader& operator=(const PacketHeader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PacketHeader(PacketHeader&& from) noexcept
    : PacketHeader() {
    *this = ::std::move(from);
  }

  inline PacketHeader& operator=(PacketHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PacketHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PacketHeader* internal_default_instance() {
    return reinterpret_cast<const PacketHeader*>(
               &_PacketHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PacketHeader* other);
  friend void swap(PacketHeader& a, PacketHeader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PacketHeader* New() const final {
    return CreateMaybeMessage<PacketHeader>(NULL);
  }

  PacketHeader* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PacketHeader>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PacketHeader& from);
  void MergeFrom(const PacketHeader& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PacketHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PacketHeader_MsgID MsgID;
  static const MsgID STATUS =
    PacketHeader_MsgID_STATUS;
  static const MsgID STEP_SIMULATION =
    PacketHeader_MsgID_STEP_SIMULATION;
  static const MsgID RESET_SIMULATION =
    PacketHeader_MsgID_RESET_SIMULATION;
  static const MsgID IMAGE =
    PacketHeader_MsgID_IMAGE;
  static const MsgID REQUEST_IMAGE =
    PacketHeader_MsgID_REQUEST_IMAGE;
  static const MsgID REQUEST_COSIM =
    PacketHeader_MsgID_REQUEST_COSIM;
  static const MsgID STOP_COSIM =
    PacketHeader_MsgID_STOP_COSIM;
  static const MsgID GET_GROUND_TRUTH_WORLD_POSE =
    PacketHeader_MsgID_GET_GROUND_TRUTH_WORLD_POSE;
  static const MsgID POSE =
    PacketHeader_MsgID_POSE;
  static const MsgID STOP_SIMULATION =
    PacketHeader_MsgID_STOP_SIMULATION;
  static const MsgID LASER_DATA =
    PacketHeader_MsgID_LASER_DATA;
  static const MsgID REQUEST_LASER =
    PacketHeader_MsgID_REQUEST_LASER;
  static const MsgID IMU_DATA =
    PacketHeader_MsgID_IMU_DATA;
  static const MsgID REQUEST_IMU =
    PacketHeader_MsgID_REQUEST_IMU;
  static const MsgID SUBSCRIBE_IMAGE =
    PacketHeader_MsgID_SUBSCRIBE_IMAGE;
  static const MsgID SUBSCRIBE_LASER =
    PacketHeader_MsgID_SUBSCRIBE_LASER;
  static const MsgID SUBSCRIBE_IMU =
    PacketHeader_MsgID_SUBSCRIBE_IMU;
  static const MsgID APPLY_JOINT_TORQUE =
    PacketHeader_MsgID_APPLY_JOINT_TORQUE;
  static const MsgID GET_POSE =
    PacketHeader_MsgID_GET_POSE;
  static const MsgID GET_TOPIC_LIST =
    PacketHeader_MsgID_GET_TOPIC_LIST;
  static const MsgID TOPIC_LIST =
    PacketHeader_MsgID_TOPIC_LIST;
  static const MsgID GET_MODEL_INFO =
    PacketHeader_MsgID_GET_MODEL_INFO;
  static const MsgID MODEL_INFO =
    PacketHeader_MsgID_MODEL_INFO;
  static const MsgID APPLY_LINK_WRENCH =
    PacketHeader_MsgID_APPLY_LINK_WRENCH;
  static const MsgID MAX_STEP_SIZE =
    PacketHeader_MsgID_MAX_STEP_SIZE;
  static const MsgID CUSTOM_MESSAGE_SUBSCRIBER =
    PacketHeader_MsgID_CUSTOM_MESSAGE_SUBSCRIBER;
  static const MsgID CUSTOM_MESSAGE_PUBLISHER =
    PacketHeader_MsgID_CUSTOM_MESSAGE_PUBLISHER;
  static const MsgID INIT_CUSTOM_MESSAGE_PUBLISHER =
    PacketHeader_MsgID_INIT_CUSTOM_MESSAGE_PUBLISHER;
  static const MsgID INIT_CUSTOM_MESSAGE_SUBSCRIBER =
    PacketHeader_MsgID_INIT_CUSTOM_MESSAGE_SUBSCRIBER;
  static const MsgID SET_JOINT_POSITION =
    PacketHeader_MsgID_SET_JOINT_POSITION;
  static const MsgID SET_JOINT_VELOCITY =
    PacketHeader_MsgID_SET_JOINT_VELOCITY;
  static const MsgID GET_JOINT_STATE =
    PacketHeader_MsgID_GET_JOINT_STATE;
  static const MsgID JOINT_STATE =
    PacketHeader_MsgID_JOINT_STATE;
  static const MsgID SET_LINK_WORLD_POSE =
    PacketHeader_MsgID_SET_LINK_WORLD_POSE;
  static const MsgID SET_LINK_LINEAR_VELOCITY =
    PacketHeader_MsgID_SET_LINK_LINEAR_VELOCITY;
  static const MsgID SET_LINK_ANGULAR_VELOCITY =
    PacketHeader_MsgID_SET_LINK_ANGULAR_VELOCITY;
  static const MsgID GET_LINK_STATE =
    PacketHeader_MsgID_GET_LINK_STATE;
  static const MsgID LINK_STATE =
    PacketHeader_MsgID_LINK_STATE;
  static inline bool MsgID_IsValid(int value) {
    return PacketHeader_MsgID_IsValid(value);
  }
  static const MsgID MsgID_MIN =
    PacketHeader_MsgID_MsgID_MIN;
  static const MsgID MsgID_MAX =
    PacketHeader_MsgID_MsgID_MAX;
  static const int MsgID_ARRAYSIZE =
    PacketHeader_MsgID_MsgID_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MsgID_descriptor() {
    return PacketHeader_MsgID_descriptor();
  }
  static inline const ::std::string& MsgID_Name(MsgID value) {
    return PacketHeader_MsgID_Name(value);
  }
  static inline bool MsgID_Parse(const ::std::string& name,
      MsgID* value) {
    return PacketHeader_MsgID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mw.internal.robotics.gazebotransport.Time time_stamp = 2;
  bool has_time_stamp() const;
  void clear_time_stamp();
  static const int kTimeStampFieldNumber = 2;
  private:
  const ::mw::internal::robotics::gazebotransport::Time& _internal_time_stamp() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Time& time_stamp() const;
  ::mw::internal::robotics::gazebotransport::Time* release_time_stamp();
  ::mw::internal::robotics::gazebotransport::Time* mutable_time_stamp();
  void set_allocated_time_stamp(::mw::internal::robotics::gazebotransport::Time* time_stamp);

  // required .mw.internal.robotics.gazebotransport.PacketHeader.MsgID id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID id() const;
  void set_id(::mw::internal::robotics::gazebotransport::PacketHeader_MsgID value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.PacketHeader)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_time_stamp();
  void clear_has_time_stamp();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::mw::internal::robotics::gazebotransport::Time* time_stamp_;
  int id_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Packet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Packet) */ {
 public:
  Packet();
  virtual ~Packet();

  Packet(const Packet& from);

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Packet(Packet&& from) noexcept
    : Packet() {
    *this = ::std::move(from);
  }

  inline Packet& operator=(Packet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Packet& default_instance();

  enum PayloadCase {
    kStatus = 2,
    kStepSimulation = 3,
    kResetSimulation = 4,
    kImage = 5,
    kRequestImage = 6,
    kRequestCosim = 7,
    kStopCosim = 8,
    kGetGroundTruthWorldPose = 9,
    kPose = 10,
    kStopSimulation = 11,
    kLaserData = 12,
    kRequestLaser = 13,
    kImuData = 14,
    kRequestImu = 15,
    kSubscribeImage = 16,
    kSubscribeLaser = 17,
    kSubscribeImu = 18,
    kApplyJointTorque = 19,
    kGetPose = 20,
    kGetTopicList = 21,
    kTopicList = 22,
    kGetModelInfo = 23,
    kModelInfo = 24,
    kApplyLinkWrench = 25,
    kMaxStepSize = 26,
    kCustomMessageSupport = 27,
    kInitCustomPublisher = 28,
    kInitCustomSubscriber = 29,
    kRequestCustomMessageSupport = 30,
    kSetJointPosition = 31,
    kSetJointVelocity = 32,
    kGetJointState = 33,
    kJointState = 34,
    kSetLinkWorldPose = 35,
    kSetLinkLinearVelocity = 36,
    kSetLinkAngularVelocity = 37,
    kGetLinkState = 38,
    kLinkState = 39,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Packet* internal_default_instance() {
    return reinterpret_cast<const Packet*>(
               &_Packet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Packet* other);
  friend void swap(Packet& a, Packet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Packet* New() const final {
    return CreateMaybeMessage<Packet>(NULL);
  }

  Packet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Packet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Packet& from);
  void MergeFrom(const Packet& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Packet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Packet_CoSimError CoSimError;
  static const CoSimError NONE =
    Packet_CoSimError_NONE;
  static const CoSimError STEP_FAILED =
    Packet_CoSimError_STEP_FAILED;
  static const CoSimError MSG_INVALID =
    Packet_CoSimError_MSG_INVALID;
  static const CoSimError SOCKET_FAILED =
    Packet_CoSimError_SOCKET_FAILED;
  static const CoSimError RESET_FAILED =
    Packet_CoSimError_RESET_FAILED;
  static const CoSimError COSIM_FAILED =
    Packet_CoSimError_COSIM_FAILED;
  static const CoSimError STOP_COSIM_FAILED =
    Packet_CoSimError_STOP_COSIM_FAILED;
  static const CoSimError GET_GROUND_TRUTH_WORLD_POSE_FAILED =
    Packet_CoSimError_GET_GROUND_TRUTH_WORLD_POSE_FAILED;
  static const CoSimError RESET_TIME_SCENE_FAILED =
    Packet_CoSimError_RESET_TIME_SCENE_FAILED;
  static const CoSimError RESET_TIME_FAILED =
    Packet_CoSimError_RESET_TIME_FAILED;
  static const CoSimError STOP_FAILED =
    Packet_CoSimError_STOP_FAILED;
  static const CoSimError FORCE_TYPE_INVALID =
    Packet_CoSimError_FORCE_TYPE_INVALID;
  static const CoSimError MODEL_NAME_INVALID =
    Packet_CoSimError_MODEL_NAME_INVALID;
  static const CoSimError LINK_NAME_INVALID =
    Packet_CoSimError_LINK_NAME_INVALID;
  static const CoSimError JOINT_NAME_INVALID =
    Packet_CoSimError_JOINT_NAME_INVALID;
  static const CoSimError TOPIC_NAME_INVALID =
    Packet_CoSimError_TOPIC_NAME_INVALID;
  static const CoSimError TORQUE_TYPE_INVALID =
    Packet_CoSimError_TORQUE_TYPE_INVALID;
  static const CoSimError MAX_STEP_SIZE_ERROR =
    Packet_CoSimError_MAX_STEP_SIZE_ERROR;
  static const CoSimError CUSTOM_MESSAGE_INVALID =
    Packet_CoSimError_CUSTOM_MESSAGE_INVALID;
  static const CoSimError MESSAGE_TYPE_INVALID =
    Packet_CoSimError_MESSAGE_TYPE_INVALID;
  static inline bool CoSimError_IsValid(int value) {
    return Packet_CoSimError_IsValid(value);
  }
  static const CoSimError CoSimError_MIN =
    Packet_CoSimError_CoSimError_MIN;
  static const CoSimError CoSimError_MAX =
    Packet_CoSimError_CoSimError_MAX;
  static const int CoSimError_ARRAYSIZE =
    Packet_CoSimError_CoSimError_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CoSimError_descriptor() {
    return Packet_CoSimError_descriptor();
  }
  static inline const ::std::string& CoSimError_Name(CoSimError value) {
    return Packet_CoSimError_Name(value);
  }
  static inline bool CoSimError_Parse(const ::std::string& name,
      CoSimError* value) {
    return Packet_CoSimError_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mw.internal.robotics.gazebotransport.PacketHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  private:
  const ::mw::internal::robotics::gazebotransport::PacketHeader& _internal_header() const;
  public:
  const ::mw::internal::robotics::gazebotransport::PacketHeader& header() const;
  ::mw::internal::robotics::gazebotransport::PacketHeader* release_header();
  ::mw::internal::robotics::gazebotransport::PacketHeader* mutable_header();
  void set_allocated_header(::mw::internal::robotics::gazebotransport::PacketHeader* header);

  // optional .mw.internal.robotics.gazebotransport.Packet.CoSimError status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::mw::internal::robotics::gazebotransport::Packet_CoSimError status() const;
  void set_status(::mw::internal::robotics::gazebotransport::Packet_CoSimError value);

  // optional .mw.internal.robotics.gazebotransport.StepSimulation step_simulation = 3;
  bool has_step_simulation() const;
  void clear_step_simulation();
  static const int kStepSimulationFieldNumber = 3;
  private:
  const ::mw::internal::robotics::gazebotransport::StepSimulation& _internal_step_simulation() const;
  public:
  const ::mw::internal::robotics::gazebotransport::StepSimulation& step_simulation() const;
  ::mw::internal::robotics::gazebotransport::StepSimulation* release_step_simulation();
  ::mw::internal::robotics::gazebotransport::StepSimulation* mutable_step_simulation();
  void set_allocated_step_simulation(::mw::internal::robotics::gazebotransport::StepSimulation* step_simulation);

  // optional .mw.internal.robotics.gazebotransport.ResetSimulation reset_simulation = 4;
  bool has_reset_simulation() const;
  void clear_reset_simulation();
  static const int kResetSimulationFieldNumber = 4;
  private:
  const ::mw::internal::robotics::gazebotransport::ResetSimulation& _internal_reset_simulation() const;
  public:
  const ::mw::internal::robotics::gazebotransport::ResetSimulation& reset_simulation() const;
  ::mw::internal::robotics::gazebotransport::ResetSimulation* release_reset_simulation();
  ::mw::internal::robotics::gazebotransport::ResetSimulation* mutable_reset_simulation();
  void set_allocated_reset_simulation(::mw::internal::robotics::gazebotransport::ResetSimulation* reset_simulation);

  // optional .mw.internal.robotics.gazebotransport.Image image = 5;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 5;
  private:
  const ::mw::internal::robotics::gazebotransport::Image& _internal_image() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Image& image() const;
  ::mw::internal::robotics::gazebotransport::Image* release_image();
  ::mw::internal::robotics::gazebotransport::Image* mutable_image();
  void set_allocated_image(::mw::internal::robotics::gazebotransport::Image* image);

  // optional .mw.internal.robotics.gazebotransport.RequestImage request_image = 6;
  bool has_request_image() const;
  void clear_request_image();
  static const int kRequestImageFieldNumber = 6;
  private:
  const ::mw::internal::robotics::gazebotransport::RequestImage& _internal_request_image() const;
  public:
  const ::mw::internal::robotics::gazebotransport::RequestImage& request_image() const;
  ::mw::internal::robotics::gazebotransport::RequestImage* release_request_image();
  ::mw::internal::robotics::gazebotransport::RequestImage* mutable_request_image();
  void set_allocated_request_image(::mw::internal::robotics::gazebotransport::RequestImage* request_image);

  // optional .mw.internal.robotics.gazebotransport.RequestCoSim request_cosim = 7;
  bool has_request_cosim() const;
  void clear_request_cosim();
  static const int kRequestCosimFieldNumber = 7;
  private:
  const ::mw::internal::robotics::gazebotransport::RequestCoSim& _internal_request_cosim() const;
  public:
  const ::mw::internal::robotics::gazebotransport::RequestCoSim& request_cosim() const;
  ::mw::internal::robotics::gazebotransport::RequestCoSim* release_request_cosim();
  ::mw::internal::robotics::gazebotransport::RequestCoSim* mutable_request_cosim();
  void set_allocated_request_cosim(::mw::internal::robotics::gazebotransport::RequestCoSim* request_cosim);

  // optional .mw.internal.robotics.gazebotransport.StopCoSim stop_cosim = 8;
  bool has_stop_cosim() const;
  void clear_stop_cosim();
  static const int kStopCosimFieldNumber = 8;
  private:
  const ::mw::internal::robotics::gazebotransport::StopCoSim& _internal_stop_cosim() const;
  public:
  const ::mw::internal::robotics::gazebotransport::StopCoSim& stop_cosim() const;
  ::mw::internal::robotics::gazebotransport::StopCoSim* release_stop_cosim();
  ::mw::internal::robotics::gazebotransport::StopCoSim* mutable_stop_cosim();
  void set_allocated_stop_cosim(::mw::internal::robotics::gazebotransport::StopCoSim* stop_cosim);

  // optional .mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
  bool has_get_ground_truth_world_pose() const;
  void clear_get_ground_truth_world_pose();
  static const int kGetGroundTruthWorldPoseFieldNumber = 9;
  private:
  const ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose& _internal_get_ground_truth_world_pose() const;
  public:
  const ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose& get_ground_truth_world_pose() const;
  ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* release_get_ground_truth_world_pose();
  ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* mutable_get_ground_truth_world_pose();
  void set_allocated_get_ground_truth_world_pose(::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose);

  // optional .mw.internal.robotics.gazebotransport.Pose pose = 10;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 10;
  private:
  const ::mw::internal::robotics::gazebotransport::Pose& _internal_pose() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Pose& pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* release_pose();
  ::mw::internal::robotics::gazebotransport::Pose* mutable_pose();
  void set_allocated_pose(::mw::internal::robotics::gazebotransport::Pose* pose);

  // optional .mw.internal.robotics.gazebotransport.StopSimulation stop_simulation = 11;
  bool has_stop_simulation() const;
  void clear_stop_simulation();
  static const int kStopSimulationFieldNumber = 11;
  private:
  const ::mw::internal::robotics::gazebotransport::StopSimulation& _internal_stop_simulation() const;
  public:
  const ::mw::internal::robotics::gazebotransport::StopSimulation& stop_simulation() const;
  ::mw::internal::robotics::gazebotransport::StopSimulation* release_stop_simulation();
  ::mw::internal::robotics::gazebotransport::StopSimulation* mutable_stop_simulation();
  void set_allocated_stop_simulation(::mw::internal::robotics::gazebotransport::StopSimulation* stop_simulation);

  // optional .mw.internal.robotics.gazebotransport.LaserData laser_data = 12;
  bool has_laser_data() const;
  void clear_laser_data();
  static const int kLaserDataFieldNumber = 12;
  private:
  const ::mw::internal::robotics::gazebotransport::LaserData& _internal_laser_data() const;
  public:
  const ::mw::internal::robotics::gazebotransport::LaserData& laser_data() const;
  ::mw::internal::robotics::gazebotransport::LaserData* release_laser_data();
  ::mw::internal::robotics::gazebotransport::LaserData* mutable_laser_data();
  void set_allocated_laser_data(::mw::internal::robotics::gazebotransport::LaserData* laser_data);

  // optional .mw.internal.robotics.gazebotransport.RequestLaser request_laser = 13;
  bool has_request_laser() const;
  void clear_request_laser();
  static const int kRequestLaserFieldNumber = 13;
  private:
  const ::mw::internal::robotics::gazebotransport::RequestLaser& _internal_request_laser() const;
  public:
  const ::mw::internal::robotics::gazebotransport::RequestLaser& request_laser() const;
  ::mw::internal::robotics::gazebotransport::RequestLaser* release_request_laser();
  ::mw::internal::robotics::gazebotransport::RequestLaser* mutable_request_laser();
  void set_allocated_request_laser(::mw::internal::robotics::gazebotransport::RequestLaser* request_laser);

  // optional .mw.internal.robotics.gazebotransport.ImuData imu_data = 14;
  bool has_imu_data() const;
  void clear_imu_data();
  static const int kImuDataFieldNumber = 14;
  private:
  const ::mw::internal::robotics::gazebotransport::ImuData& _internal_imu_data() const;
  public:
  const ::mw::internal::robotics::gazebotransport::ImuData& imu_data() const;
  ::mw::internal::robotics::gazebotransport::ImuData* release_imu_data();
  ::mw::internal::robotics::gazebotransport::ImuData* mutable_imu_data();
  void set_allocated_imu_data(::mw::internal::robotics::gazebotransport::ImuData* imu_data);

  // optional .mw.internal.robotics.gazebotransport.RequestImu request_imu = 15;
  bool has_request_imu() const;
  void clear_request_imu();
  static const int kRequestImuFieldNumber = 15;
  private:
  const ::mw::internal::robotics::gazebotransport::RequestImu& _internal_request_imu() const;
  public:
  const ::mw::internal::robotics::gazebotransport::RequestImu& request_imu() const;
  ::mw::internal::robotics::gazebotransport::RequestImu* release_request_imu();
  ::mw::internal::robotics::gazebotransport::RequestImu* mutable_request_imu();
  void set_allocated_request_imu(::mw::internal::robotics::gazebotransport::RequestImu* request_imu);

  // optional .mw.internal.robotics.gazebotransport.SubscribeImage subscribe_image = 16;
  bool has_subscribe_image() const;
  void clear_subscribe_image();
  static const int kSubscribeImageFieldNumber = 16;
  private:
  const ::mw::internal::robotics::gazebotransport::SubscribeImage& _internal_subscribe_image() const;
  public:
  const ::mw::internal::robotics::gazebotransport::SubscribeImage& subscribe_image() const;
  ::mw::internal::robotics::gazebotransport::SubscribeImage* release_subscribe_image();
  ::mw::internal::robotics::gazebotransport::SubscribeImage* mutable_subscribe_image();
  void set_allocated_subscribe_image(::mw::internal::robotics::gazebotransport::SubscribeImage* subscribe_image);

  // optional .mw.internal.robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
  bool has_subscribe_laser() const;
  void clear_subscribe_laser();
  static const int kSubscribeLaserFieldNumber = 17;
  private:
  const ::mw::internal::robotics::gazebotransport::SubscribeLaser& _internal_subscribe_laser() const;
  public:
  const ::mw::internal::robotics::gazebotransport::SubscribeLaser& subscribe_laser() const;
  ::mw::internal::robotics::gazebotransport::SubscribeLaser* release_subscribe_laser();
  ::mw::internal::robotics::gazebotransport::SubscribeLaser* mutable_subscribe_laser();
  void set_allocated_subscribe_laser(::mw::internal::robotics::gazebotransport::SubscribeLaser* subscribe_laser);

  // optional .mw.internal.robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
  bool has_subscribe_imu() const;
  void clear_subscribe_imu();
  static const int kSubscribeImuFieldNumber = 18;
  private:
  const ::mw::internal::robotics::gazebotransport::SubscribeImu& _internal_subscribe_imu() const;
  public:
  const ::mw::internal::robotics::gazebotransport::SubscribeImu& subscribe_imu() const;
  ::mw::internal::robotics::gazebotransport::SubscribeImu* release_subscribe_imu();
  ::mw::internal::robotics::gazebotransport::SubscribeImu* mutable_subscribe_imu();
  void set_allocated_subscribe_imu(::mw::internal::robotics::gazebotransport::SubscribeImu* subscribe_imu);

  // optional .mw.internal.robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
  bool has_apply_joint_torque() const;
  void clear_apply_joint_torque();
  static const int kApplyJointTorqueFieldNumber = 19;
  private:
  const ::mw::internal::robotics::gazebotransport::ApplyJointTorque& _internal_apply_joint_torque() const;
  public:
  const ::mw::internal::robotics::gazebotransport::ApplyJointTorque& apply_joint_torque() const;
  ::mw::internal::robotics::gazebotransport::ApplyJointTorque* release_apply_joint_torque();
  ::mw::internal::robotics::gazebotransport::ApplyJointTorque* mutable_apply_joint_torque();
  void set_allocated_apply_joint_torque(::mw::internal::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque);

  // optional .mw.internal.robotics.gazebotransport.GetPose get_pose = 20;
  bool has_get_pose() const;
  void clear_get_pose();
  static const int kGetPoseFieldNumber = 20;
  private:
  const ::mw::internal::robotics::gazebotransport::GetPose& _internal_get_pose() const;
  public:
  const ::mw::internal::robotics::gazebotransport::GetPose& get_pose() const;
  ::mw::internal::robotics::gazebotransport::GetPose* release_get_pose();
  ::mw::internal::robotics::gazebotransport::GetPose* mutable_get_pose();
  void set_allocated_get_pose(::mw::internal::robotics::gazebotransport::GetPose* get_pose);

  // optional .mw.internal.robotics.gazebotransport.GetTopicList get_topic_list = 21;
  bool has_get_topic_list() const;
  void clear_get_topic_list();
  static const int kGetTopicListFieldNumber = 21;
  private:
  const ::mw::internal::robotics::gazebotransport::GetTopicList& _internal_get_topic_list() const;
  public:
  const ::mw::internal::robotics::gazebotransport::GetTopicList& get_topic_list() const;
  ::mw::internal::robotics::gazebotransport::GetTopicList* release_get_topic_list();
  ::mw::internal::robotics::gazebotransport::GetTopicList* mutable_get_topic_list();
  void set_allocated_get_topic_list(::mw::internal::robotics::gazebotransport::GetTopicList* get_topic_list);

  // optional .mw.internal.robotics.gazebotransport.TopicList topic_list = 22;
  bool has_topic_list() const;
  void clear_topic_list();
  static const int kTopicListFieldNumber = 22;
  private:
  const ::mw::internal::robotics::gazebotransport::TopicList& _internal_topic_list() const;
  public:
  const ::mw::internal::robotics::gazebotransport::TopicList& topic_list() const;
  ::mw::internal::robotics::gazebotransport::TopicList* release_topic_list();
  ::mw::internal::robotics::gazebotransport::TopicList* mutable_topic_list();
  void set_allocated_topic_list(::mw::internal::robotics::gazebotransport::TopicList* topic_list);

  // optional .mw.internal.robotics.gazebotransport.GetModelInfo get_model_info = 23;
  bool has_get_model_info() const;
  void clear_get_model_info();
  static const int kGetModelInfoFieldNumber = 23;
  private:
  const ::mw::internal::robotics::gazebotransport::GetModelInfo& _internal_get_model_info() const;
  public:
  const ::mw::internal::robotics::gazebotransport::GetModelInfo& get_model_info() const;
  ::mw::internal::robotics::gazebotransport::GetModelInfo* release_get_model_info();
  ::mw::internal::robotics::gazebotransport::GetModelInfo* mutable_get_model_info();
  void set_allocated_get_model_info(::mw::internal::robotics::gazebotransport::GetModelInfo* get_model_info);

  // optional .mw.internal.robotics.gazebotransport.ModelInfo model_info = 24;
  bool has_model_info() const;
  void clear_model_info();
  static const int kModelInfoFieldNumber = 24;
  private:
  const ::mw::internal::robotics::gazebotransport::ModelInfo& _internal_model_info() const;
  public:
  const ::mw::internal::robotics::gazebotransport::ModelInfo& model_info() const;
  ::mw::internal::robotics::gazebotransport::ModelInfo* release_model_info();
  ::mw::internal::robotics::gazebotransport::ModelInfo* mutable_model_info();
  void set_allocated_model_info(::mw::internal::robotics::gazebotransport::ModelInfo* model_info);

  // optional .mw.internal.robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
  bool has_apply_link_wrench() const;
  void clear_apply_link_wrench();
  static const int kApplyLinkWrenchFieldNumber = 25;
  private:
  const ::mw::internal::robotics::gazebotransport::ApplyLinkWrench& _internal_apply_link_wrench() const;
  public:
  const ::mw::internal::robotics::gazebotransport::ApplyLinkWrench& apply_link_wrench() const;
  ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* release_apply_link_wrench();
  ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* mutable_apply_link_wrench();
  void set_allocated_apply_link_wrench(::mw::internal::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench);

  // optional .mw.internal.robotics.gazebotransport.MaxStepSize max_step_size = 26;
  bool has_max_step_size() const;
  void clear_max_step_size();
  static const int kMaxStepSizeFieldNumber = 26;
  private:
  const ::mw::internal::robotics::gazebotransport::MaxStepSize& _internal_max_step_size() const;
  public:
  const ::mw::internal::robotics::gazebotransport::MaxStepSize& max_step_size() const;
  ::mw::internal::robotics::gazebotransport::MaxStepSize* release_max_step_size();
  ::mw::internal::robotics::gazebotransport::MaxStepSize* mutable_max_step_size();
  void set_allocated_max_step_size(::mw::internal::robotics::gazebotransport::MaxStepSize* max_step_size);

  // optional .mw.internal.robotics.gazebotransport.CustomMessageSupport custom_message_support = 27;
  bool has_custom_message_support() const;
  void clear_custom_message_support();
  static const int kCustomMessageSupportFieldNumber = 27;
  private:
  const ::mw::internal::robotics::gazebotransport::CustomMessageSupport& _internal_custom_message_support() const;
  public:
  const ::mw::internal::robotics::gazebotransport::CustomMessageSupport& custom_message_support() const;
  ::mw::internal::robotics::gazebotransport::CustomMessageSupport* release_custom_message_support();
  ::mw::internal::robotics::gazebotransport::CustomMessageSupport* mutable_custom_message_support();
  void set_allocated_custom_message_support(::mw::internal::robotics::gazebotransport::CustomMessageSupport* custom_message_support);

  // optional .mw.internal.robotics.gazebotransport.InitCustomPublisher init_custom_publisher = 28;
  bool has_init_custom_publisher() const;
  void clear_init_custom_publisher();
  static const int kInitCustomPublisherFieldNumber = 28;
  private:
  const ::mw::internal::robotics::gazebotransport::InitCustomPublisher& _internal_init_custom_publisher() const;
  public:
  const ::mw::internal::robotics::gazebotransport::InitCustomPublisher& init_custom_publisher() const;
  ::mw::internal::robotics::gazebotransport::InitCustomPublisher* release_init_custom_publisher();
  ::mw::internal::robotics::gazebotransport::InitCustomPublisher* mutable_init_custom_publisher();
  void set_allocated_init_custom_publisher(::mw::internal::robotics::gazebotransport::InitCustomPublisher* init_custom_publisher);

  // optional .mw.internal.robotics.gazebotransport.InitCustomSubscriber init_custom_subscriber = 29;
  bool has_init_custom_subscriber() const;
  void clear_init_custom_subscriber();
  static const int kInitCustomSubscriberFieldNumber = 29;
  private:
  const ::mw::internal::robotics::gazebotransport::InitCustomSubscriber& _internal_init_custom_subscriber() const;
  public:
  const ::mw::internal::robotics::gazebotransport::InitCustomSubscriber& init_custom_subscriber() const;
  ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* release_init_custom_subscriber();
  ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* mutable_init_custom_subscriber();
  void set_allocated_init_custom_subscriber(::mw::internal::robotics::gazebotransport::InitCustomSubscriber* init_custom_subscriber);

  // optional .mw.internal.robotics.gazebotransport.RequestCustomMessageSupport request_custom_message_support = 30;
  bool has_request_custom_message_support() const;
  void clear_request_custom_message_support();
  static const int kRequestCustomMessageSupportFieldNumber = 30;
  private:
  const ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport& _internal_request_custom_message_support() const;
  public:
  const ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport& request_custom_message_support() const;
  ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* release_request_custom_message_support();
  ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* mutable_request_custom_message_support();
  void set_allocated_request_custom_message_support(::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* request_custom_message_support);

  // optional .mw.internal.robotics.gazebotransport.SetJointPosition set_joint_position = 31;
  bool has_set_joint_position() const;
  void clear_set_joint_position();
  static const int kSetJointPositionFieldNumber = 31;
  private:
  const ::mw::internal::robotics::gazebotransport::SetJointPosition& _internal_set_joint_position() const;
  public:
  const ::mw::internal::robotics::gazebotransport::SetJointPosition& set_joint_position() const;
  ::mw::internal::robotics::gazebotransport::SetJointPosition* release_set_joint_position();
  ::mw::internal::robotics::gazebotransport::SetJointPosition* mutable_set_joint_position();
  void set_allocated_set_joint_position(::mw::internal::robotics::gazebotransport::SetJointPosition* set_joint_position);

  // optional .mw.internal.robotics.gazebotransport.SetJointVelocity set_joint_velocity = 32;
  bool has_set_joint_velocity() const;
  void clear_set_joint_velocity();
  static const int kSetJointVelocityFieldNumber = 32;
  private:
  const ::mw::internal::robotics::gazebotransport::SetJointVelocity& _internal_set_joint_velocity() const;
  public:
  const ::mw::internal::robotics::gazebotransport::SetJointVelocity& set_joint_velocity() const;
  ::mw::internal::robotics::gazebotransport::SetJointVelocity* release_set_joint_velocity();
  ::mw::internal::robotics::gazebotransport::SetJointVelocity* mutable_set_joint_velocity();
  void set_allocated_set_joint_velocity(::mw::internal::robotics::gazebotransport::SetJointVelocity* set_joint_velocity);

  // optional .mw.internal.robotics.gazebotransport.GetJointState get_joint_state = 33;
  bool has_get_joint_state() const;
  void clear_get_joint_state();
  static const int kGetJointStateFieldNumber = 33;
  private:
  const ::mw::internal::robotics::gazebotransport::GetJointState& _internal_get_joint_state() const;
  public:
  const ::mw::internal::robotics::gazebotransport::GetJointState& get_joint_state() const;
  ::mw::internal::robotics::gazebotransport::GetJointState* release_get_joint_state();
  ::mw::internal::robotics::gazebotransport::GetJointState* mutable_get_joint_state();
  void set_allocated_get_joint_state(::mw::internal::robotics::gazebotransport::GetJointState* get_joint_state);

  // optional .mw.internal.robotics.gazebotransport.JointState joint_state = 34;
  bool has_joint_state() const;
  void clear_joint_state();
  static const int kJointStateFieldNumber = 34;
  private:
  const ::mw::internal::robotics::gazebotransport::JointState& _internal_joint_state() const;
  public:
  const ::mw::internal::robotics::gazebotransport::JointState& joint_state() const;
  ::mw::internal::robotics::gazebotransport::JointState* release_joint_state();
  ::mw::internal::robotics::gazebotransport::JointState* mutable_joint_state();
  void set_allocated_joint_state(::mw::internal::robotics::gazebotransport::JointState* joint_state);

  // optional .mw.internal.robotics.gazebotransport.SetLinkWorldPose set_link_world_pose = 35;
  bool has_set_link_world_pose() const;
  void clear_set_link_world_pose();
  static const int kSetLinkWorldPoseFieldNumber = 35;
  private:
  const ::mw::internal::robotics::gazebotransport::SetLinkWorldPose& _internal_set_link_world_pose() const;
  public:
  const ::mw::internal::robotics::gazebotransport::SetLinkWorldPose& set_link_world_pose() const;
  ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* release_set_link_world_pose();
  ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* mutable_set_link_world_pose();
  void set_allocated_set_link_world_pose(::mw::internal::robotics::gazebotransport::SetLinkWorldPose* set_link_world_pose);

  // optional .mw.internal.robotics.gazebotransport.SetLinkLinearVelocity set_link_linear_velocity = 36;
  bool has_set_link_linear_velocity() const;
  void clear_set_link_linear_velocity();
  static const int kSetLinkLinearVelocityFieldNumber = 36;
  private:
  const ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity& _internal_set_link_linear_velocity() const;
  public:
  const ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity& set_link_linear_velocity() const;
  ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* release_set_link_linear_velocity();
  ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* mutable_set_link_linear_velocity();
  void set_allocated_set_link_linear_velocity(::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* set_link_linear_velocity);

  // optional .mw.internal.robotics.gazebotransport.SetLinkAngularVelocity set_link_angular_velocity = 37;
  bool has_set_link_angular_velocity() const;
  void clear_set_link_angular_velocity();
  static const int kSetLinkAngularVelocityFieldNumber = 37;
  private:
  const ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity& _internal_set_link_angular_velocity() const;
  public:
  const ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity& set_link_angular_velocity() const;
  ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* release_set_link_angular_velocity();
  ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* mutable_set_link_angular_velocity();
  void set_allocated_set_link_angular_velocity(::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* set_link_angular_velocity);

  // optional .mw.internal.robotics.gazebotransport.GetLinkState get_link_state = 38;
  bool has_get_link_state() const;
  void clear_get_link_state();
  static const int kGetLinkStateFieldNumber = 38;
  private:
  const ::mw::internal::robotics::gazebotransport::GetLinkState& _internal_get_link_state() const;
  public:
  const ::mw::internal::robotics::gazebotransport::GetLinkState& get_link_state() const;
  ::mw::internal::robotics::gazebotransport::GetLinkState* release_get_link_state();
  ::mw::internal::robotics::gazebotransport::GetLinkState* mutable_get_link_state();
  void set_allocated_get_link_state(::mw::internal::robotics::gazebotransport::GetLinkState* get_link_state);

  // optional .mw.internal.robotics.gazebotransport.LinkState link_state = 39;
  bool has_link_state() const;
  void clear_link_state();
  static const int kLinkStateFieldNumber = 39;
  private:
  const ::mw::internal::robotics::gazebotransport::LinkState& _internal_link_state() const;
  public:
  const ::mw::internal::robotics::gazebotransport::LinkState& link_state() const;
  ::mw::internal::robotics::gazebotransport::LinkState* release_link_state();
  ::mw::internal::robotics::gazebotransport::LinkState* mutable_link_state();
  void set_allocated_link_state(::mw::internal::robotics::gazebotransport::LinkState* link_state);

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Packet)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_status();
  void set_has_step_simulation();
  void set_has_reset_simulation();
  void set_has_image();
  void set_has_request_image();
  void set_has_request_cosim();
  void set_has_stop_cosim();
  void set_has_get_ground_truth_world_pose();
  void set_has_pose();
  void set_has_stop_simulation();
  void set_has_laser_data();
  void set_has_request_laser();
  void set_has_imu_data();
  void set_has_request_imu();
  void set_has_subscribe_image();
  void set_has_subscribe_laser();
  void set_has_subscribe_imu();
  void set_has_apply_joint_torque();
  void set_has_get_pose();
  void set_has_get_topic_list();
  void set_has_topic_list();
  void set_has_get_model_info();
  void set_has_model_info();
  void set_has_apply_link_wrench();
  void set_has_max_step_size();
  void set_has_custom_message_support();
  void set_has_init_custom_publisher();
  void set_has_init_custom_subscriber();
  void set_has_request_custom_message_support();
  void set_has_set_joint_position();
  void set_has_set_joint_velocity();
  void set_has_get_joint_state();
  void set_has_joint_state();
  void set_has_set_link_world_pose();
  void set_has_set_link_linear_velocity();
  void set_has_set_link_angular_velocity();
  void set_has_get_link_state();
  void set_has_link_state();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::mw::internal::robotics::gazebotransport::PacketHeader* header_;
  union PayloadUnion {
    PayloadUnion() {}
    int status_;
    ::mw::internal::robotics::gazebotransport::StepSimulation* step_simulation_;
    ::mw::internal::robotics::gazebotransport::ResetSimulation* reset_simulation_;
    ::mw::internal::robotics::gazebotransport::Image* image_;
    ::mw::internal::robotics::gazebotransport::RequestImage* request_image_;
    ::mw::internal::robotics::gazebotransport::RequestCoSim* request_cosim_;
    ::mw::internal::robotics::gazebotransport::StopCoSim* stop_cosim_;
    ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* get_ground_truth_world_pose_;
    ::mw::internal::robotics::gazebotransport::Pose* pose_;
    ::mw::internal::robotics::gazebotransport::StopSimulation* stop_simulation_;
    ::mw::internal::robotics::gazebotransport::LaserData* laser_data_;
    ::mw::internal::robotics::gazebotransport::RequestLaser* request_laser_;
    ::mw::internal::robotics::gazebotransport::ImuData* imu_data_;
    ::mw::internal::robotics::gazebotransport::RequestImu* request_imu_;
    ::mw::internal::robotics::gazebotransport::SubscribeImage* subscribe_image_;
    ::mw::internal::robotics::gazebotransport::SubscribeLaser* subscribe_laser_;
    ::mw::internal::robotics::gazebotransport::SubscribeImu* subscribe_imu_;
    ::mw::internal::robotics::gazebotransport::ApplyJointTorque* apply_joint_torque_;
    ::mw::internal::robotics::gazebotransport::GetPose* get_pose_;
    ::mw::internal::robotics::gazebotransport::GetTopicList* get_topic_list_;
    ::mw::internal::robotics::gazebotransport::TopicList* topic_list_;
    ::mw::internal::robotics::gazebotransport::GetModelInfo* get_model_info_;
    ::mw::internal::robotics::gazebotransport::ModelInfo* model_info_;
    ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* apply_link_wrench_;
    ::mw::internal::robotics::gazebotransport::MaxStepSize* max_step_size_;
    ::mw::internal::robotics::gazebotransport::CustomMessageSupport* custom_message_support_;
    ::mw::internal::robotics::gazebotransport::InitCustomPublisher* init_custom_publisher_;
    ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* init_custom_subscriber_;
    ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* request_custom_message_support_;
    ::mw::internal::robotics::gazebotransport::SetJointPosition* set_joint_position_;
    ::mw::internal::robotics::gazebotransport::SetJointVelocity* set_joint_velocity_;
    ::mw::internal::robotics::gazebotransport::GetJointState* get_joint_state_;
    ::mw::internal::robotics::gazebotransport::JointState* joint_state_;
    ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* set_link_world_pose_;
    ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* set_link_linear_velocity_;
    ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* set_link_angular_velocity_;
    ::mw::internal::robotics::gazebotransport::GetLinkState* get_link_state_;
    ::mw::internal::robotics::gazebotransport::LinkState* link_state_;
  } payload_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StepSimulation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.StepSimulation) */ {
 public:
  StepSimulation();
  virtual ~StepSimulation();

  StepSimulation(const StepSimulation& from);

  inline StepSimulation& operator=(const StepSimulation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StepSimulation(StepSimulation&& from) noexcept
    : StepSimulation() {
    *this = ::std::move(from);
  }

  inline StepSimulation& operator=(StepSimulation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StepSimulation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StepSimulation* internal_default_instance() {
    return reinterpret_cast<const StepSimulation*>(
               &_StepSimulation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(StepSimulation* other);
  friend void swap(StepSimulation& a, StepSimulation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StepSimulation* New() const final {
    return CreateMaybeMessage<StepSimulation>(NULL);
  }

  StepSimulation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StepSimulation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StepSimulation& from);
  void MergeFrom(const StepSimulation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepSimulation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 num_steps = 1;
  bool has_num_steps() const;
  void clear_num_steps();
  static const int kNumStepsFieldNumber = 1;
  ::google::protobuf::uint32 num_steps() const;
  void set_num_steps(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.StepSimulation)
 private:
  void set_has_num_steps();
  void clear_has_num_steps();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 num_steps_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResetSimulation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ResetSimulation) */ {
 public:
  ResetSimulation();
  virtual ~ResetSimulation();

  ResetSimulation(const ResetSimulation& from);

  inline ResetSimulation& operator=(const ResetSimulation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResetSimulation(ResetSimulation&& from) noexcept
    : ResetSimulation() {
    *this = ::std::move(from);
  }

  inline ResetSimulation& operator=(ResetSimulation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetSimulation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetSimulation* internal_default_instance() {
    return reinterpret_cast<const ResetSimulation*>(
               &_ResetSimulation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ResetSimulation* other);
  friend void swap(ResetSimulation& a, ResetSimulation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResetSimulation* New() const final {
    return CreateMaybeMessage<ResetSimulation>(NULL);
  }

  ResetSimulation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResetSimulation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResetSimulation& from);
  void MergeFrom(const ResetSimulation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetSimulation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ResetSimulation_ResetBehavior ResetBehavior;
  static const ResetBehavior RESET_TIME =
    ResetSimulation_ResetBehavior_RESET_TIME;
  static const ResetBehavior RESET_TIME_AND_SCENE =
    ResetSimulation_ResetBehavior_RESET_TIME_AND_SCENE;
  static inline bool ResetBehavior_IsValid(int value) {
    return ResetSimulation_ResetBehavior_IsValid(value);
  }
  static const ResetBehavior ResetBehavior_MIN =
    ResetSimulation_ResetBehavior_ResetBehavior_MIN;
  static const ResetBehavior ResetBehavior_MAX =
    ResetSimulation_ResetBehavior_ResetBehavior_MAX;
  static const int ResetBehavior_ARRAYSIZE =
    ResetSimulation_ResetBehavior_ResetBehavior_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResetBehavior_descriptor() {
    return ResetSimulation_ResetBehavior_descriptor();
  }
  static inline const ::std::string& ResetBehavior_Name(ResetBehavior value) {
    return ResetSimulation_ResetBehavior_Name(value);
  }
  static inline bool ResetBehavior_Parse(const ::std::string& name,
      ResetBehavior* value) {
    return ResetSimulation_ResetBehavior_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .mw.internal.robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
  bool has_behavior() const;
  void clear_behavior();
  static const int kBehaviorFieldNumber = 1;
  ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior behavior() const;
  void set_behavior(::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ResetSimulation)
 private:
  void set_has_behavior();
  void clear_has_behavior();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int behavior_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Image : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Image) */ {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(Image&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Image* other);
  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Image* New() const final {
    return CreateMaybeMessage<Image>(NULL);
  }

  Image* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // required string data_type = 4;
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 4;
  const ::std::string& data_type() const;
  void set_data_type(const ::std::string& value);
  #if LANG_CXX11
  void set_data_type(::std::string&& value);
  #endif
  void set_data_type(const char* value);
  void set_data_type(const char* value, size_t size);
  ::std::string* mutable_data_type();
  ::std::string* release_data_type();
  void set_allocated_data_type(::std::string* data_type);

  // required uint32 width = 1;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // required uint32 height = 2;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Image)
 private:
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_data();
  void clear_has_data();
  void set_has_data_type();
  void clear_has_data_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr data_type_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.RequestImage) */ {
 public:
  RequestImage();
  virtual ~RequestImage();

  RequestImage(const RequestImage& from);

  inline RequestImage& operator=(const RequestImage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestImage(RequestImage&& from) noexcept
    : RequestImage() {
    *this = ::std::move(from);
  }

  inline RequestImage& operator=(RequestImage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestImage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestImage* internal_default_instance() {
    return reinterpret_cast<const RequestImage*>(
               &_RequestImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RequestImage* other);
  friend void swap(RequestImage& a, RequestImage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestImage* New() const final {
    return CreateMaybeMessage<RequestImage>(NULL);
  }

  RequestImage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestImage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestImage& from);
  void MergeFrom(const RequestImage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  #if LANG_CXX11
  void set_topic_name(::std::string&& value);
  #endif
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.RequestImage)
 private:
  void set_has_topic_name();
  void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestCoSim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.RequestCoSim) */ {
 public:
  RequestCoSim();
  virtual ~RequestCoSim();

  RequestCoSim(const RequestCoSim& from);

  inline RequestCoSim& operator=(const RequestCoSim& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestCoSim(RequestCoSim&& from) noexcept
    : RequestCoSim() {
    *this = ::std::move(from);
  }

  inline RequestCoSim& operator=(RequestCoSim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCoSim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestCoSim* internal_default_instance() {
    return reinterpret_cast<const RequestCoSim*>(
               &_RequestCoSim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(RequestCoSim* other);
  friend void swap(RequestCoSim& a, RequestCoSim& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestCoSim* New() const final {
    return CreateMaybeMessage<RequestCoSim>(NULL);
  }

  RequestCoSim* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestCoSim>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestCoSim& from);
  void MergeFrom(const RequestCoSim& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestCoSim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client_id = 1;
  bool has_client_id() const;
  void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // required double duration = 2;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 2;
  double duration() const;
  void set_duration(double value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.RequestCoSim)
 private:
  void set_has_client_id();
  void clear_has_client_id();
  void set_has_duration();
  void clear_has_duration();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  double duration_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StopCoSim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.StopCoSim) */ {
 public:
  StopCoSim();
  virtual ~StopCoSim();

  StopCoSim(const StopCoSim& from);

  inline StopCoSim& operator=(const StopCoSim& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StopCoSim(StopCoSim&& from) noexcept
    : StopCoSim() {
    *this = ::std::move(from);
  }

  inline StopCoSim& operator=(StopCoSim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopCoSim& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopCoSim* internal_default_instance() {
    return reinterpret_cast<const StopCoSim*>(
               &_StopCoSim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(StopCoSim* other);
  friend void swap(StopCoSim& a, StopCoSim& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StopCoSim* New() const final {
    return CreateMaybeMessage<StopCoSim>(NULL);
  }

  StopCoSim* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StopCoSim>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StopCoSim& from);
  void MergeFrom(const StopCoSim& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopCoSim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string client_id = 1;
  bool has_client_id() const;
  void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  const ::std::string& client_id() const;
  void set_client_id(const ::std::string& value);
  #if LANG_CXX11
  void set_client_id(::std::string&& value);
  #endif
  void set_client_id(const char* value);
  void set_client_id(const char* value, size_t size);
  ::std::string* mutable_client_id();
  ::std::string* release_client_id();
  void set_allocated_client_id(::std::string* client_id);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.StopCoSim)
 private:
  void set_has_client_id();
  void clear_has_client_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr client_id_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetGroundTruthWorldPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose) */ {
 public:
  GetGroundTruthWorldPose();
  virtual ~GetGroundTruthWorldPose();

  GetGroundTruthWorldPose(const GetGroundTruthWorldPose& from);

  inline GetGroundTruthWorldPose& operator=(const GetGroundTruthWorldPose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetGroundTruthWorldPose(GetGroundTruthWorldPose&& from) noexcept
    : GetGroundTruthWorldPose() {
    *this = ::std::move(from);
  }

  inline GetGroundTruthWorldPose& operator=(GetGroundTruthWorldPose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetGroundTruthWorldPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetGroundTruthWorldPose* internal_default_instance() {
    return reinterpret_cast<const GetGroundTruthWorldPose*>(
               &_GetGroundTruthWorldPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetGroundTruthWorldPose* other);
  friend void swap(GetGroundTruthWorldPose& a, GetGroundTruthWorldPose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetGroundTruthWorldPose* New() const final {
    return CreateMaybeMessage<GetGroundTruthWorldPose>(NULL);
  }

  GetGroundTruthWorldPose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetGroundTruthWorldPose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetGroundTruthWorldPose& from);
  void MergeFrom(const GetGroundTruthWorldPose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetGroundTruthWorldPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  #if LANG_CXX11
  void set_model_name(::std::string&& value);
  #endif
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  #if LANG_CXX11
  void set_link_name(::std::string&& value);
  #endif
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose)
 private:
  void set_has_model_name();
  void clear_has_model_name();
  void set_has_link_name();
  void clear_has_link_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Point* other);
  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const final {
    return CreateMaybeMessage<Point>(NULL);
  }

  Point* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Point)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Quaternion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Quaternion) */ {
 public:
  Quaternion();
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Quaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Quaternion* other);
  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quaternion* New() const final {
    return CreateMaybeMessage<Quaternion>(NULL);
  }

  Quaternion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // required double w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  double w() const;
  void set_w(double value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Quaternion)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_w();
  void clear_has_w();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  double w_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Pose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Pose) */ {
 public:
  Pose();
  virtual ~Pose();

  Pose(const Pose& from);

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(Pose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(Pose* other);
  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pose* New() const final {
    return CreateMaybeMessage<Pose>(NULL);
  }

  Pose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mw.internal.robotics.gazebotransport.Point position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_position() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Point& position() const;
  ::mw::internal::robotics::gazebotransport::Point* release_position();
  ::mw::internal::robotics::gazebotransport::Point* mutable_position();
  void set_allocated_position(::mw::internal::robotics::gazebotransport::Point* position);

  // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 2;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 2;
  private:
  const ::mw::internal::robotics::gazebotransport::Quaternion& _internal_orientation() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Quaternion& orientation() const;
  ::mw::internal::robotics::gazebotransport::Quaternion* release_orientation();
  ::mw::internal::robotics::gazebotransport::Quaternion* mutable_orientation();
  void set_allocated_orientation(::mw::internal::robotics::gazebotransport::Quaternion* orientation);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Pose)
 private:
  void set_has_position();
  void clear_has_position();
  void set_has_orientation();
  void clear_has_orientation();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::mw::internal::robotics::gazebotransport::Point* position_;
  ::mw::internal::robotics::gazebotransport::Quaternion* orientation_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StopSimulation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.StopSimulation) */ {
 public:
  StopSimulation();
  virtual ~StopSimulation();

  StopSimulation(const StopSimulation& from);

  inline StopSimulation& operator=(const StopSimulation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StopSimulation(StopSimulation&& from) noexcept
    : StopSimulation() {
    *this = ::std::move(from);
  }

  inline StopSimulation& operator=(StopSimulation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopSimulation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StopSimulation* internal_default_instance() {
    return reinterpret_cast<const StopSimulation*>(
               &_StopSimulation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(StopSimulation* other);
  friend void swap(StopSimulation& a, StopSimulation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StopSimulation* New() const final {
    return CreateMaybeMessage<StopSimulation>(NULL);
  }

  StopSimulation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StopSimulation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StopSimulation& from);
  void MergeFrom(const StopSimulation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopSimulation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool stop_scene = 1;
  bool has_stop_scene() const;
  void clear_stop_scene();
  static const int kStopSceneFieldNumber = 1;
  bool stop_scene() const;
  void set_stop_scene(bool value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.StopSimulation)
 private:
  void set_has_stop_scene();
  void clear_has_stop_scene();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool stop_scene_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaserData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.LaserData) */ {
 public:
  LaserData();
  virtual ~LaserData();

  LaserData(const LaserData& from);

  inline LaserData& operator=(const LaserData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaserData(LaserData&& from) noexcept
    : LaserData() {
    *this = ::std::move(from);
  }

  inline LaserData& operator=(LaserData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaserData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaserData* internal_default_instance() {
    return reinterpret_cast<const LaserData*>(
               &_LaserData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(LaserData* other);
  friend void swap(LaserData& a, LaserData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaserData* New() const final {
    return CreateMaybeMessage<LaserData>(NULL);
  }

  LaserData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaserData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaserData& from);
  void MergeFrom(const LaserData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaserData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double range = 10;
  int range_size() const;
  void clear_range();
  static const int kRangeFieldNumber = 10;
  double range(int index) const;
  void set_range(int index, double value);
  void add_range(double value);
  const ::google::protobuf::RepeatedField< double >&
      range() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_range();

  // repeated double intensities = 11;
  int intensities_size() const;
  void clear_intensities();
  static const int kIntensitiesFieldNumber = 11;
  double intensities(int index) const;
  void set_intensities(int index, double value);
  void add_intensities(double value);
  const ::google::protobuf::RepeatedField< double >&
      intensities() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_intensities();

  // required double angle_min = 1;
  bool has_angle_min() const;
  void clear_angle_min();
  static const int kAngleMinFieldNumber = 1;
  double angle_min() const;
  void set_angle_min(double value);

  // required double angle_max = 2;
  bool has_angle_max() const;
  void clear_angle_max();
  static const int kAngleMaxFieldNumber = 2;
  double angle_max() const;
  void set_angle_max(double value);

  // required double angle_step = 3;
  bool has_angle_step() const;
  void clear_angle_step();
  static const int kAngleStepFieldNumber = 3;
  double angle_step() const;
  void set_angle_step(double value);

  // required double range_min = 4;
  bool has_range_min() const;
  void clear_range_min();
  static const int kRangeMinFieldNumber = 4;
  double range_min() const;
  void set_range_min(double value);

  // required double range_max = 5;
  bool has_range_max() const;
  void clear_range_max();
  static const int kRangeMaxFieldNumber = 5;
  double range_max() const;
  void set_range_max(double value);

  // required double count = 6;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 6;
  double count() const;
  void set_count(double value);

  // required double vertical_angle_min = 7;
  bool has_vertical_angle_min() const;
  void clear_vertical_angle_min();
  static const int kVerticalAngleMinFieldNumber = 7;
  double vertical_angle_min() const;
  void set_vertical_angle_min(double value);

  // required double vertical_angle_max = 8;
  bool has_vertical_angle_max() const;
  void clear_vertical_angle_max();
  static const int kVerticalAngleMaxFieldNumber = 8;
  double vertical_angle_max() const;
  void set_vertical_angle_max(double value);

  // required double vertical_angle_step = 9;
  bool has_vertical_angle_step() const;
  void clear_vertical_angle_step();
  static const int kVerticalAngleStepFieldNumber = 9;
  double vertical_angle_step() const;
  void set_vertical_angle_step(double value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.LaserData)
 private:
  void set_has_angle_min();
  void clear_has_angle_min();
  void set_has_angle_max();
  void clear_has_angle_max();
  void set_has_angle_step();
  void clear_has_angle_step();
  void set_has_range_min();
  void clear_has_range_min();
  void set_has_range_max();
  void clear_has_range_max();
  void set_has_count();
  void clear_has_count();
  void set_has_vertical_angle_min();
  void clear_has_vertical_angle_min();
  void set_has_vertical_angle_max();
  void clear_has_vertical_angle_max();
  void set_has_vertical_angle_step();
  void clear_has_vertical_angle_step();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< double > range_;
  ::google::protobuf::RepeatedField< double > intensities_;
  double angle_min_;
  double angle_max_;
  double angle_step_;
  double range_min_;
  double range_max_;
  double count_;
  double vertical_angle_min_;
  double vertical_angle_max_;
  double vertical_angle_step_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestLaser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.RequestLaser) */ {
 public:
  RequestLaser();
  virtual ~RequestLaser();

  RequestLaser(const RequestLaser& from);

  inline RequestLaser& operator=(const RequestLaser& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestLaser(RequestLaser&& from) noexcept
    : RequestLaser() {
    *this = ::std::move(from);
  }

  inline RequestLaser& operator=(RequestLaser&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestLaser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestLaser* internal_default_instance() {
    return reinterpret_cast<const RequestLaser*>(
               &_RequestLaser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(RequestLaser* other);
  friend void swap(RequestLaser& a, RequestLaser& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestLaser* New() const final {
    return CreateMaybeMessage<RequestLaser>(NULL);
  }

  RequestLaser* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestLaser>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestLaser& from);
  void MergeFrom(const RequestLaser& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestLaser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  #if LANG_CXX11
  void set_topic_name(::std::string&& value);
  #endif
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.RequestLaser)
 private:
  void set_has_topic_name();
  void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ImuData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ImuData) */ {
 public:
  ImuData();
  virtual ~ImuData();

  ImuData(const ImuData& from);

  inline ImuData& operator=(const ImuData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImuData(ImuData&& from) noexcept
    : ImuData() {
    *this = ::std::move(from);
  }

  inline ImuData& operator=(ImuData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImuData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImuData* internal_default_instance() {
    return reinterpret_cast<const ImuData*>(
               &_ImuData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ImuData* other);
  friend void swap(ImuData& a, ImuData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImuData* New() const final {
    return CreateMaybeMessage<ImuData>(NULL);
  }

  ImuData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImuData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImuData& from);
  void MergeFrom(const ImuData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImuData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mw.internal.robotics.gazebotransport.Point linear_acceleration = 1;
  bool has_linear_acceleration() const;
  void clear_linear_acceleration();
  static const int kLinearAccelerationFieldNumber = 1;
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_linear_acceleration() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Point& linear_acceleration() const;
  ::mw::internal::robotics::gazebotransport::Point* release_linear_acceleration();
  ::mw::internal::robotics::gazebotransport::Point* mutable_linear_acceleration();
  void set_allocated_linear_acceleration(::mw::internal::robotics::gazebotransport::Point* linear_acceleration);

  // required .mw.internal.robotics.gazebotransport.Point angular_velocity = 2;
  bool has_angular_velocity() const;
  void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 2;
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_angular_velocity() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Point& angular_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* release_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* mutable_angular_velocity();
  void set_allocated_angular_velocity(::mw::internal::robotics::gazebotransport::Point* angular_velocity);

  // required .mw.internal.robotics.gazebotransport.Quaternion orientation = 3;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 3;
  private:
  const ::mw::internal::robotics::gazebotransport::Quaternion& _internal_orientation() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Quaternion& orientation() const;
  ::mw::internal::robotics::gazebotransport::Quaternion* release_orientation();
  ::mw::internal::robotics::gazebotransport::Quaternion* mutable_orientation();
  void set_allocated_orientation(::mw::internal::robotics::gazebotransport::Quaternion* orientation);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ImuData)
 private:
  void set_has_linear_acceleration();
  void clear_has_linear_acceleration();
  void set_has_angular_velocity();
  void clear_has_angular_velocity();
  void set_has_orientation();
  void clear_has_orientation();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::mw::internal::robotics::gazebotransport::Point* linear_acceleration_;
  ::mw::internal::robotics::gazebotransport::Point* angular_velocity_;
  ::mw::internal::robotics::gazebotransport::Quaternion* orientation_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestImu : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.RequestImu) */ {
 public:
  RequestImu();
  virtual ~RequestImu();

  RequestImu(const RequestImu& from);

  inline RequestImu& operator=(const RequestImu& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestImu(RequestImu&& from) noexcept
    : RequestImu() {
    *this = ::std::move(from);
  }

  inline RequestImu& operator=(RequestImu&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestImu& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestImu* internal_default_instance() {
    return reinterpret_cast<const RequestImu*>(
               &_RequestImu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(RequestImu* other);
  friend void swap(RequestImu& a, RequestImu& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestImu* New() const final {
    return CreateMaybeMessage<RequestImu>(NULL);
  }

  RequestImu* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestImu>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestImu& from);
  void MergeFrom(const RequestImu& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestImu* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  #if LANG_CXX11
  void set_topic_name(::std::string&& value);
  #endif
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.RequestImu)
 private:
  void set_has_topic_name();
  void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubscribeImage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SubscribeImage) */ {
 public:
  SubscribeImage();
  virtual ~SubscribeImage();

  SubscribeImage(const SubscribeImage& from);

  inline SubscribeImage& operator=(const SubscribeImage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubscribeImage(SubscribeImage&& from) noexcept
    : SubscribeImage() {
    *this = ::std::move(from);
  }

  inline SubscribeImage& operator=(SubscribeImage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeImage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscribeImage* internal_default_instance() {
    return reinterpret_cast<const SubscribeImage*>(
               &_SubscribeImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(SubscribeImage* other);
  friend void swap(SubscribeImage& a, SubscribeImage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubscribeImage* New() const final {
    return CreateMaybeMessage<SubscribeImage>(NULL);
  }

  SubscribeImage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SubscribeImage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SubscribeImage& from);
  void MergeFrom(const SubscribeImage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeImage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  #if LANG_CXX11
  void set_topic_name(::std::string&& value);
  #endif
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SubscribeImage)
 private:
  void set_has_topic_name();
  void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubscribeLaser : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SubscribeLaser) */ {
 public:
  SubscribeLaser();
  virtual ~SubscribeLaser();

  SubscribeLaser(const SubscribeLaser& from);

  inline SubscribeLaser& operator=(const SubscribeLaser& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubscribeLaser(SubscribeLaser&& from) noexcept
    : SubscribeLaser() {
    *this = ::std::move(from);
  }

  inline SubscribeLaser& operator=(SubscribeLaser&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeLaser& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscribeLaser* internal_default_instance() {
    return reinterpret_cast<const SubscribeLaser*>(
               &_SubscribeLaser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(SubscribeLaser* other);
  friend void swap(SubscribeLaser& a, SubscribeLaser& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubscribeLaser* New() const final {
    return CreateMaybeMessage<SubscribeLaser>(NULL);
  }

  SubscribeLaser* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SubscribeLaser>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SubscribeLaser& from);
  void MergeFrom(const SubscribeLaser& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeLaser* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  #if LANG_CXX11
  void set_topic_name(::std::string&& value);
  #endif
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SubscribeLaser)
 private:
  void set_has_topic_name();
  void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SubscribeImu : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SubscribeImu) */ {
 public:
  SubscribeImu();
  virtual ~SubscribeImu();

  SubscribeImu(const SubscribeImu& from);

  inline SubscribeImu& operator=(const SubscribeImu& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SubscribeImu(SubscribeImu&& from) noexcept
    : SubscribeImu() {
    *this = ::std::move(from);
  }

  inline SubscribeImu& operator=(SubscribeImu&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubscribeImu& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SubscribeImu* internal_default_instance() {
    return reinterpret_cast<const SubscribeImu*>(
               &_SubscribeImu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(SubscribeImu* other);
  friend void swap(SubscribeImu& a, SubscribeImu& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SubscribeImu* New() const final {
    return CreateMaybeMessage<SubscribeImu>(NULL);
  }

  SubscribeImu* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SubscribeImu>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SubscribeImu& from);
  void MergeFrom(const SubscribeImu& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SubscribeImu* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  #if LANG_CXX11
  void set_topic_name(::std::string&& value);
  #endif
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SubscribeImu)
 private:
  void set_has_topic_name();
  void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ApplyLinkWrench : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ApplyLinkWrench) */ {
 public:
  ApplyLinkWrench();
  virtual ~ApplyLinkWrench();

  ApplyLinkWrench(const ApplyLinkWrench& from);

  inline ApplyLinkWrench& operator=(const ApplyLinkWrench& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ApplyLinkWrench(ApplyLinkWrench&& from) noexcept
    : ApplyLinkWrench() {
    *this = ::std::move(from);
  }

  inline ApplyLinkWrench& operator=(ApplyLinkWrench&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyLinkWrench& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApplyLinkWrench* internal_default_instance() {
    return reinterpret_cast<const ApplyLinkWrench*>(
               &_ApplyLinkWrench_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ApplyLinkWrench* other);
  friend void swap(ApplyLinkWrench& a, ApplyLinkWrench& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ApplyLinkWrench* New() const final {
    return CreateMaybeMessage<ApplyLinkWrench>(NULL);
  }

  ApplyLinkWrench* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ApplyLinkWrench>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ApplyLinkWrench& from);
  void MergeFrom(const ApplyLinkWrench& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyLinkWrench* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  #if LANG_CXX11
  void set_model_name(::std::string&& value);
  #endif
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  #if LANG_CXX11
  void set_link_name(::std::string&& value);
  #endif
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // required string force_type = 3;
  bool has_force_type() const;
  void clear_force_type();
  static const int kForceTypeFieldNumber = 3;
  const ::std::string& force_type() const;
  void set_force_type(const ::std::string& value);
  #if LANG_CXX11
  void set_force_type(::std::string&& value);
  #endif
  void set_force_type(const char* value);
  void set_force_type(const char* value, size_t size);
  ::std::string* mutable_force_type();
  ::std::string* release_force_type();
  void set_allocated_force_type(::std::string* force_type);

  // required string torque_type = 7;
  bool has_torque_type() const;
  void clear_torque_type();
  static const int kTorqueTypeFieldNumber = 7;
  const ::std::string& torque_type() const;
  void set_torque_type(const ::std::string& value);
  #if LANG_CXX11
  void set_torque_type(::std::string&& value);
  #endif
  void set_torque_type(const char* value);
  void set_torque_type(const char* value, size_t size);
  ::std::string* mutable_torque_type();
  ::std::string* release_torque_type();
  void set_allocated_torque_type(::std::string* torque_type);

  // required .mw.internal.robotics.gazebotransport.Time duration = 11;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 11;
  private:
  const ::mw::internal::robotics::gazebotransport::Time& _internal_duration() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);

  // required double fx = 4;
  bool has_fx() const;
  void clear_fx();
  static const int kFxFieldNumber = 4;
  double fx() const;
  void set_fx(double value);

  // required double fy = 5;
  bool has_fy() const;
  void clear_fy();
  static const int kFyFieldNumber = 5;
  double fy() const;
  void set_fy(double value);

  // required double fz = 6;
  bool has_fz() const;
  void clear_fz();
  static const int kFzFieldNumber = 6;
  double fz() const;
  void set_fz(double value);

  // required double tx = 8;
  bool has_tx() const;
  void clear_tx();
  static const int kTxFieldNumber = 8;
  double tx() const;
  void set_tx(double value);

  // required double ty = 9;
  bool has_ty() const;
  void clear_ty();
  static const int kTyFieldNumber = 9;
  double ty() const;
  void set_ty(double value);

  // required double tz = 10;
  bool has_tz() const;
  void clear_tz();
  static const int kTzFieldNumber = 10;
  double tz() const;
  void set_tz(double value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ApplyLinkWrench)
 private:
  void set_has_model_name();
  void clear_has_model_name();
  void set_has_link_name();
  void clear_has_link_name();
  void set_has_force_type();
  void clear_has_force_type();
  void set_has_fx();
  void clear_has_fx();
  void set_has_fy();
  void clear_has_fy();
  void set_has_fz();
  void clear_has_fz();
  void set_has_torque_type();
  void clear_has_torque_type();
  void set_has_tx();
  void clear_has_tx();
  void set_has_ty();
  void clear_has_ty();
  void set_has_tz();
  void clear_has_tz();
  void set_has_duration();
  void clear_has_duration();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  ::google::protobuf::internal::ArenaStringPtr force_type_;
  ::google::protobuf::internal::ArenaStringPtr torque_type_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  double fx_;
  double fy_;
  double fz_;
  double tx_;
  double ty_;
  double tz_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ApplyJointTorque : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ApplyJointTorque) */ {
 public:
  ApplyJointTorque();
  virtual ~ApplyJointTorque();

  ApplyJointTorque(const ApplyJointTorque& from);

  inline ApplyJointTorque& operator=(const ApplyJointTorque& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ApplyJointTorque(ApplyJointTorque&& from) noexcept
    : ApplyJointTorque() {
    *this = ::std::move(from);
  }

  inline ApplyJointTorque& operator=(ApplyJointTorque&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplyJointTorque& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ApplyJointTorque* internal_default_instance() {
    return reinterpret_cast<const ApplyJointTorque*>(
               &_ApplyJointTorque_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(ApplyJointTorque* other);
  friend void swap(ApplyJointTorque& a, ApplyJointTorque& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ApplyJointTorque* New() const final {
    return CreateMaybeMessage<ApplyJointTorque>(NULL);
  }

  ApplyJointTorque* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ApplyJointTorque>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ApplyJointTorque& from);
  void MergeFrom(const ApplyJointTorque& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyJointTorque* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  #if LANG_CXX11
  void set_model_name(::std::string&& value);
  #endif
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string joint_name = 2;
  bool has_joint_name() const;
  void clear_joint_name();
  static const int kJointNameFieldNumber = 2;
  const ::std::string& joint_name() const;
  void set_joint_name(const ::std::string& value);
  #if LANG_CXX11
  void set_joint_name(::std::string&& value);
  #endif
  void set_joint_name(const char* value);
  void set_joint_name(const char* value, size_t size);
  ::std::string* mutable_joint_name();
  ::std::string* release_joint_name();
  void set_allocated_joint_name(::std::string* joint_name);

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 5;
  private:
  const ::mw::internal::robotics::gazebotransport::Time& _internal_duration() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);

  // required double effort = 4;
  bool has_effort() const;
  void clear_effort();
  static const int kEffortFieldNumber = 4;
  double effort() const;
  void set_effort(double value);

  // required uint32 index = 3;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ApplyJointTorque)
 private:
  void set_has_model_name();
  void clear_has_model_name();
  void set_has_joint_name();
  void clear_has_joint_name();
  void set_has_index();
  void clear_has_index();
  void set_has_effort();
  void clear_has_effort();
  void set_has_duration();
  void clear_has_duration();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr joint_name_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  double effort_;
  ::google::protobuf::uint32 index_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetPose) */ {
 public:
  GetPose();
  virtual ~GetPose();

  GetPose(const GetPose& from);

  inline GetPose& operator=(const GetPose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetPose(GetPose&& from) noexcept
    : GetPose() {
    *this = ::std::move(from);
  }

  inline GetPose& operator=(GetPose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetPose* internal_default_instance() {
    return reinterpret_cast<const GetPose*>(
               &_GetPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(GetPose* other);
  friend void swap(GetPose& a, GetPose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetPose* New() const final {
    return CreateMaybeMessage<GetPose>(NULL);
  }

  GetPose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetPose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetPose& from);
  void MergeFrom(const GetPose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  #if LANG_CXX11
  void set_model_name(::std::string&& value);
  #endif
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetPose)
 private:
  void set_has_model_name();
  void clear_has_model_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTopicList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetTopicList) */ {
 public:
  GetTopicList();
  virtual ~GetTopicList();

  GetTopicList(const GetTopicList& from);

  inline GetTopicList& operator=(const GetTopicList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTopicList(GetTopicList&& from) noexcept
    : GetTopicList() {
    *this = ::std::move(from);
  }

  inline GetTopicList& operator=(GetTopicList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTopicList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTopicList* internal_default_instance() {
    return reinterpret_cast<const GetTopicList*>(
               &_GetTopicList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(GetTopicList* other);
  friend void swap(GetTopicList& a, GetTopicList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTopicList* New() const final {
    return CreateMaybeMessage<GetTopicList>(NULL);
  }

  GetTopicList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTopicList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTopicList& from);
  void MergeFrom(const GetTopicList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTopicList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  #if LANG_CXX11
  void set_topic_name(::std::string&& value);
  #endif
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetTopicList)
 private:
  void set_has_topic_name();
  void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TopicList_TopicInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.TopicList.TopicInfo) */ {
 public:
  TopicList_TopicInfo();
  virtual ~TopicList_TopicInfo();

  TopicList_TopicInfo(const TopicList_TopicInfo& from);

  inline TopicList_TopicInfo& operator=(const TopicList_TopicInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TopicList_TopicInfo(TopicList_TopicInfo&& from) noexcept
    : TopicList_TopicInfo() {
    *this = ::std::move(from);
  }

  inline TopicList_TopicInfo& operator=(TopicList_TopicInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicList_TopicInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TopicList_TopicInfo* internal_default_instance() {
    return reinterpret_cast<const TopicList_TopicInfo*>(
               &_TopicList_TopicInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(TopicList_TopicInfo* other);
  friend void swap(TopicList_TopicInfo& a, TopicList_TopicInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TopicList_TopicInfo* New() const final {
    return CreateMaybeMessage<TopicList_TopicInfo>(NULL);
  }

  TopicList_TopicInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TopicList_TopicInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TopicList_TopicInfo& from);
  void MergeFrom(const TopicList_TopicInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TopicList_TopicInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.TopicList.TopicInfo)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TopicList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.TopicList) */ {
 public:
  TopicList();
  virtual ~TopicList();

  TopicList(const TopicList& from);

  inline TopicList& operator=(const TopicList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TopicList(TopicList&& from) noexcept
    : TopicList() {
    *this = ::std::move(from);
  }

  inline TopicList& operator=(TopicList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TopicList* internal_default_instance() {
    return reinterpret_cast<const TopicList*>(
               &_TopicList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(TopicList* other);
  friend void swap(TopicList& a, TopicList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TopicList* New() const final {
    return CreateMaybeMessage<TopicList>(NULL);
  }

  TopicList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TopicList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TopicList& from);
  void MergeFrom(const TopicList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TopicList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TopicList_TopicInfo TopicInfo;

  // accessors -------------------------------------------------------

  // repeated .mw.internal.robotics.gazebotransport.TopicList.TopicInfo data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* mutable_data(int index);
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo >*
      mutable_data();
  const ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo& data(int index) const;
  ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* add_data();
  const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo >&
      data() const;

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.TopicList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo > data_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetModelInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetModelInfo) */ {
 public:
  GetModelInfo();
  virtual ~GetModelInfo();

  GetModelInfo(const GetModelInfo& from);

  inline GetModelInfo& operator=(const GetModelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetModelInfo(GetModelInfo&& from) noexcept
    : GetModelInfo() {
    *this = ::std::move(from);
  }

  inline GetModelInfo& operator=(GetModelInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetModelInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetModelInfo* internal_default_instance() {
    return reinterpret_cast<const GetModelInfo*>(
               &_GetModelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(GetModelInfo* other);
  friend void swap(GetModelInfo& a, GetModelInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetModelInfo* New() const final {
    return CreateMaybeMessage<GetModelInfo>(NULL);
  }

  GetModelInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetModelInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetModelInfo& from);
  void MergeFrom(const GetModelInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetModelInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  #if LANG_CXX11
  void set_topic_name(::std::string&& value);
  #endif
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetModelInfo)
 private:
  void set_has_topic_name();
  void clear_has_topic_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModelInfo_LINKS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ModelInfo.LINKS) */ {
 public:
  ModelInfo_LINKS();
  virtual ~ModelInfo_LINKS();

  ModelInfo_LINKS(const ModelInfo_LINKS& from);

  inline ModelInfo_LINKS& operator=(const ModelInfo_LINKS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModelInfo_LINKS(ModelInfo_LINKS&& from) noexcept
    : ModelInfo_LINKS() {
    *this = ::std::move(from);
  }

  inline ModelInfo_LINKS& operator=(ModelInfo_LINKS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelInfo_LINKS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelInfo_LINKS* internal_default_instance() {
    return reinterpret_cast<const ModelInfo_LINKS*>(
               &_ModelInfo_LINKS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(ModelInfo_LINKS* other);
  friend void swap(ModelInfo_LINKS& a, ModelInfo_LINKS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModelInfo_LINKS* New() const final {
    return CreateMaybeMessage<ModelInfo_LINKS>(NULL);
  }

  ModelInfo_LINKS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModelInfo_LINKS>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModelInfo_LINKS& from);
  void MergeFrom(const ModelInfo_LINKS& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInfo_LINKS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string link_name = 1;
  int link_name_size() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 1;
  const ::std::string& link_name(int index) const;
  ::std::string* mutable_link_name(int index);
  void set_link_name(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_link_name(int index, ::std::string&& value);
  #endif
  void set_link_name(int index, const char* value);
  void set_link_name(int index, const char* value, size_t size);
  ::std::string* add_link_name();
  void add_link_name(const ::std::string& value);
  #if LANG_CXX11
  void add_link_name(::std::string&& value);
  #endif
  void add_link_name(const char* value);
  void add_link_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& link_name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_link_name();

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ModelInfo.LINKS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> link_name_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModelInfo_JOINTS : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS) */ {
 public:
  ModelInfo_JOINTS();
  virtual ~ModelInfo_JOINTS();

  ModelInfo_JOINTS(const ModelInfo_JOINTS& from);

  inline ModelInfo_JOINTS& operator=(const ModelInfo_JOINTS& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModelInfo_JOINTS(ModelInfo_JOINTS&& from) noexcept
    : ModelInfo_JOINTS() {
    *this = ::std::move(from);
  }

  inline ModelInfo_JOINTS& operator=(ModelInfo_JOINTS&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelInfo_JOINTS& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelInfo_JOINTS* internal_default_instance() {
    return reinterpret_cast<const ModelInfo_JOINTS*>(
               &_ModelInfo_JOINTS_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(ModelInfo_JOINTS* other);
  friend void swap(ModelInfo_JOINTS& a, ModelInfo_JOINTS& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModelInfo_JOINTS* New() const final {
    return CreateMaybeMessage<ModelInfo_JOINTS>(NULL);
  }

  ModelInfo_JOINTS* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModelInfo_JOINTS>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModelInfo_JOINTS& from);
  void MergeFrom(const ModelInfo_JOINTS& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInfo_JOINTS* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string joint_name = 1;
  int joint_name_size() const;
  void clear_joint_name();
  static const int kJointNameFieldNumber = 1;
  const ::std::string& joint_name(int index) const;
  ::std::string* mutable_joint_name(int index);
  void set_joint_name(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_joint_name(int index, ::std::string&& value);
  #endif
  void set_joint_name(int index, const char* value);
  void set_joint_name(int index, const char* value, size_t size);
  ::std::string* add_joint_name();
  void add_joint_name(const ::std::string& value);
  #if LANG_CXX11
  void add_joint_name(::std::string&& value);
  #endif
  void add_joint_name(const char* value);
  void add_joint_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& joint_name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_joint_name();

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> joint_name_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModelInfo_Model : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ModelInfo.Model) */ {
 public:
  ModelInfo_Model();
  virtual ~ModelInfo_Model();

  ModelInfo_Model(const ModelInfo_Model& from);

  inline ModelInfo_Model& operator=(const ModelInfo_Model& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModelInfo_Model(ModelInfo_Model&& from) noexcept
    : ModelInfo_Model() {
    *this = ::std::move(from);
  }

  inline ModelInfo_Model& operator=(ModelInfo_Model&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelInfo_Model& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelInfo_Model* internal_default_instance() {
    return reinterpret_cast<const ModelInfo_Model*>(
               &_ModelInfo_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(ModelInfo_Model* other);
  friend void swap(ModelInfo_Model& a, ModelInfo_Model& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModelInfo_Model* New() const final {
    return CreateMaybeMessage<ModelInfo_Model>(NULL);
  }

  ModelInfo_Model* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModelInfo_Model>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModelInfo_Model& from);
  void MergeFrom(const ModelInfo_Model& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInfo_Model* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  #if LANG_CXX11
  void set_model_name(::std::string&& value);
  #endif
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // optional .mw.internal.robotics.gazebotransport.ModelInfo.LINKS links = 2;
  bool has_links() const;
  void clear_links();
  static const int kLinksFieldNumber = 2;
  private:
  const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS& _internal_links() const;
  public:
  const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS& links() const;
  ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* release_links();
  ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* mutable_links();
  void set_allocated_links(::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* links);

  // optional .mw.internal.robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
  bool has_joints() const;
  void clear_joints();
  static const int kJointsFieldNumber = 3;
  private:
  const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS& _internal_joints() const;
  public:
  const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS& joints() const;
  ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* release_joints();
  ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* mutable_joints();
  void set_allocated_joints(::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* joints);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ModelInfo.Model)
 private:
  void set_has_model_name();
  void clear_has_model_name();
  void set_has_links();
  void clear_has_links();
  void set_has_joints();
  void clear_has_joints();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* links_;
  ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* joints_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ModelInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.ModelInfo) */ {
 public:
  ModelInfo();
  virtual ~ModelInfo();

  ModelInfo(const ModelInfo& from);

  inline ModelInfo& operator=(const ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ModelInfo(ModelInfo&& from) noexcept
    : ModelInfo() {
    *this = ::std::move(from);
  }

  inline ModelInfo& operator=(ModelInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ModelInfo* internal_default_instance() {
    return reinterpret_cast<const ModelInfo*>(
               &_ModelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(ModelInfo* other);
  friend void swap(ModelInfo& a, ModelInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ModelInfo* New() const final {
    return CreateMaybeMessage<ModelInfo>(NULL);
  }

  ModelInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ModelInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ModelInfo& from);
  void MergeFrom(const ModelInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ModelInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ModelInfo_LINKS LINKS;
  typedef ModelInfo_JOINTS JOINTS;
  typedef ModelInfo_Model Model;

  // accessors -------------------------------------------------------

  // repeated .mw.internal.robotics.gazebotransport.ModelInfo.Model model_data = 1;
  int model_data_size() const;
  void clear_model_data();
  static const int kModelDataFieldNumber = 1;
  ::mw::internal::robotics::gazebotransport::ModelInfo_Model* mutable_model_data(int index);
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model >*
      mutable_model_data();
  const ::mw::internal::robotics::gazebotransport::ModelInfo_Model& model_data(int index) const;
  ::mw::internal::robotics::gazebotransport::ModelInfo_Model* add_model_data();
  const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model >&
      model_data() const;

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.ModelInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model > model_data_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MaxStepSize : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.MaxStepSize) */ {
 public:
  MaxStepSize();
  virtual ~MaxStepSize();

  MaxStepSize(const MaxStepSize& from);

  inline MaxStepSize& operator=(const MaxStepSize& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MaxStepSize(MaxStepSize&& from) noexcept
    : MaxStepSize() {
    *this = ::std::move(from);
  }

  inline MaxStepSize& operator=(MaxStepSize&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaxStepSize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MaxStepSize* internal_default_instance() {
    return reinterpret_cast<const MaxStepSize*>(
               &_MaxStepSize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(MaxStepSize* other);
  friend void swap(MaxStepSize& a, MaxStepSize& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MaxStepSize* New() const final {
    return CreateMaybeMessage<MaxStepSize>(NULL);
  }

  MaxStepSize* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MaxStepSize>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MaxStepSize& from);
  void MergeFrom(const MaxStepSize& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaxStepSize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MaxStepSize_TYPE TYPE;
  static const TYPE SET_STEP_SIZE =
    MaxStepSize_TYPE_SET_STEP_SIZE;
  static const TYPE GET_STEP_SIZE =
    MaxStepSize_TYPE_GET_STEP_SIZE;
  static inline bool TYPE_IsValid(int value) {
    return MaxStepSize_TYPE_IsValid(value);
  }
  static const TYPE TYPE_MIN =
    MaxStepSize_TYPE_TYPE_MIN;
  static const TYPE TYPE_MAX =
    MaxStepSize_TYPE_TYPE_MAX;
  static const int TYPE_ARRAYSIZE =
    MaxStepSize_TYPE_TYPE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TYPE_descriptor() {
    return MaxStepSize_TYPE_descriptor();
  }
  static inline const ::std::string& TYPE_Name(TYPE value) {
    return MaxStepSize_TYPE_Name(value);
  }
  static inline bool TYPE_Parse(const ::std::string& name,
      TYPE* value) {
    return MaxStepSize_TYPE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required double size = 2;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  double size() const;
  void set_size(double value);

  // required .mw.internal.robotics.gazebotransport.MaxStepSize.TYPE type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE type() const;
  void set_type(::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.MaxStepSize)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_size();
  void clear_has_size();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double size_;
  int type_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitCustomPublisher : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.InitCustomPublisher) */ {
 public:
  InitCustomPublisher();
  virtual ~InitCustomPublisher();

  InitCustomPublisher(const InitCustomPublisher& from);

  inline InitCustomPublisher& operator=(const InitCustomPublisher& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitCustomPublisher(InitCustomPublisher&& from) noexcept
    : InitCustomPublisher() {
    *this = ::std::move(from);
  }

  inline InitCustomPublisher& operator=(InitCustomPublisher&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitCustomPublisher& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitCustomPublisher* internal_default_instance() {
    return reinterpret_cast<const InitCustomPublisher*>(
               &_InitCustomPublisher_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(InitCustomPublisher* other);
  friend void swap(InitCustomPublisher& a, InitCustomPublisher& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitCustomPublisher* New() const final {
    return CreateMaybeMessage<InitCustomPublisher>(NULL);
  }

  InitCustomPublisher* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitCustomPublisher>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InitCustomPublisher& from);
  void MergeFrom(const InitCustomPublisher& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitCustomPublisher* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  #if LANG_CXX11
  void set_topic_name(::std::string&& value);
  #endif
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // required string message_type = 2;
  bool has_message_type() const;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 2;
  const ::std::string& message_type() const;
  void set_message_type(const ::std::string& value);
  #if LANG_CXX11
  void set_message_type(::std::string&& value);
  #endif
  void set_message_type(const char* value);
  void set_message_type(const char* value, size_t size);
  ::std::string* mutable_message_type();
  ::std::string* release_message_type();
  void set_allocated_message_type(::std::string* message_type);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.InitCustomPublisher)
 private:
  void set_has_topic_name();
  void clear_has_topic_name();
  void set_has_message_type();
  void clear_has_message_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  ::google::protobuf::internal::ArenaStringPtr message_type_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InitCustomSubscriber : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.InitCustomSubscriber) */ {
 public:
  InitCustomSubscriber();
  virtual ~InitCustomSubscriber();

  InitCustomSubscriber(const InitCustomSubscriber& from);

  inline InitCustomSubscriber& operator=(const InitCustomSubscriber& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InitCustomSubscriber(InitCustomSubscriber&& from) noexcept
    : InitCustomSubscriber() {
    *this = ::std::move(from);
  }

  inline InitCustomSubscriber& operator=(InitCustomSubscriber&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InitCustomSubscriber& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InitCustomSubscriber* internal_default_instance() {
    return reinterpret_cast<const InitCustomSubscriber*>(
               &_InitCustomSubscriber_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(InitCustomSubscriber* other);
  friend void swap(InitCustomSubscriber& a, InitCustomSubscriber& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InitCustomSubscriber* New() const final {
    return CreateMaybeMessage<InitCustomSubscriber>(NULL);
  }

  InitCustomSubscriber* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InitCustomSubscriber>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InitCustomSubscriber& from);
  void MergeFrom(const InitCustomSubscriber& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InitCustomSubscriber* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  #if LANG_CXX11
  void set_topic_name(::std::string&& value);
  #endif
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // required string message_type = 2;
  bool has_message_type() const;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 2;
  const ::std::string& message_type() const;
  void set_message_type(const ::std::string& value);
  #if LANG_CXX11
  void set_message_type(::std::string&& value);
  #endif
  void set_message_type(const char* value);
  void set_message_type(const char* value, size_t size);
  ::std::string* mutable_message_type();
  ::std::string* release_message_type();
  void set_allocated_message_type(::std::string* message_type);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.InitCustomSubscriber)
 private:
  void set_has_topic_name();
  void clear_has_topic_name();
  void set_has_message_type();
  void clear_has_message_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  ::google::protobuf::internal::ArenaStringPtr message_type_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CustomMessageSupport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.CustomMessageSupport) */ {
 public:
  CustomMessageSupport();
  virtual ~CustomMessageSupport();

  CustomMessageSupport(const CustomMessageSupport& from);

  inline CustomMessageSupport& operator=(const CustomMessageSupport& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CustomMessageSupport(CustomMessageSupport&& from) noexcept
    : CustomMessageSupport() {
    *this = ::std::move(from);
  }

  inline CustomMessageSupport& operator=(CustomMessageSupport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CustomMessageSupport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CustomMessageSupport* internal_default_instance() {
    return reinterpret_cast<const CustomMessageSupport*>(
               &_CustomMessageSupport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(CustomMessageSupport* other);
  friend void swap(CustomMessageSupport& a, CustomMessageSupport& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CustomMessageSupport* New() const final {
    return CreateMaybeMessage<CustomMessageSupport>(NULL);
  }

  CustomMessageSupport* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CustomMessageSupport>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CustomMessageSupport& from);
  void MergeFrom(const CustomMessageSupport& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CustomMessageSupport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  #if LANG_CXX11
  void set_topic_name(::std::string&& value);
  #endif
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // required string message_type = 2;
  bool has_message_type() const;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 2;
  const ::std::string& message_type() const;
  void set_message_type(const ::std::string& value);
  #if LANG_CXX11
  void set_message_type(::std::string&& value);
  #endif
  void set_message_type(const char* value);
  void set_message_type(const char* value, size_t size);
  ::std::string* mutable_message_type();
  ::std::string* release_message_type();
  void set_allocated_message_type(::std::string* message_type);

  // required bytes data = 3;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional bool is_new = 4;
  bool has_is_new() const;
  void clear_is_new();
  static const int kIsNewFieldNumber = 4;
  bool is_new() const;
  void set_is_new(bool value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.CustomMessageSupport)
 private:
  void set_has_topic_name();
  void clear_has_topic_name();
  void set_has_message_type();
  void clear_has_message_type();
  void set_has_data();
  void clear_has_data();
  void set_has_is_new();
  void clear_has_is_new();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  ::google::protobuf::internal::ArenaStringPtr message_type_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  bool is_new_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestCustomMessageSupport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport) */ {
 public:
  RequestCustomMessageSupport();
  virtual ~RequestCustomMessageSupport();

  RequestCustomMessageSupport(const RequestCustomMessageSupport& from);

  inline RequestCustomMessageSupport& operator=(const RequestCustomMessageSupport& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestCustomMessageSupport(RequestCustomMessageSupport&& from) noexcept
    : RequestCustomMessageSupport() {
    *this = ::std::move(from);
  }

  inline RequestCustomMessageSupport& operator=(RequestCustomMessageSupport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCustomMessageSupport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestCustomMessageSupport* internal_default_instance() {
    return reinterpret_cast<const RequestCustomMessageSupport*>(
               &_RequestCustomMessageSupport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(RequestCustomMessageSupport* other);
  friend void swap(RequestCustomMessageSupport& a, RequestCustomMessageSupport& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestCustomMessageSupport* New() const final {
    return CreateMaybeMessage<RequestCustomMessageSupport>(NULL);
  }

  RequestCustomMessageSupport* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestCustomMessageSupport>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestCustomMessageSupport& from);
  void MergeFrom(const RequestCustomMessageSupport& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestCustomMessageSupport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic_name = 1;
  bool has_topic_name() const;
  void clear_topic_name();
  static const int kTopicNameFieldNumber = 1;
  const ::std::string& topic_name() const;
  void set_topic_name(const ::std::string& value);
  #if LANG_CXX11
  void set_topic_name(::std::string&& value);
  #endif
  void set_topic_name(const char* value);
  void set_topic_name(const char* value, size_t size);
  ::std::string* mutable_topic_name();
  ::std::string* release_topic_name();
  void set_allocated_topic_name(::std::string* topic_name);

  // required string message_type = 2;
  bool has_message_type() const;
  void clear_message_type();
  static const int kMessageTypeFieldNumber = 2;
  const ::std::string& message_type() const;
  void set_message_type(const ::std::string& value);
  #if LANG_CXX11
  void set_message_type(::std::string&& value);
  #endif
  void set_message_type(const char* value);
  void set_message_type(const char* value, size_t size);
  ::std::string* mutable_message_type();
  ::std::string* release_message_type();
  void set_allocated_message_type(::std::string* message_type);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport)
 private:
  void set_has_topic_name();
  void clear_has_topic_name();
  void set_has_message_type();
  void clear_has_message_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr topic_name_;
  ::google::protobuf::internal::ArenaStringPtr message_type_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetJointPosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SetJointPosition) */ {
 public:
  SetJointPosition();
  virtual ~SetJointPosition();

  SetJointPosition(const SetJointPosition& from);

  inline SetJointPosition& operator=(const SetJointPosition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetJointPosition(SetJointPosition&& from) noexcept
    : SetJointPosition() {
    *this = ::std::move(from);
  }

  inline SetJointPosition& operator=(SetJointPosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetJointPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetJointPosition* internal_default_instance() {
    return reinterpret_cast<const SetJointPosition*>(
               &_SetJointPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(SetJointPosition* other);
  friend void swap(SetJointPosition& a, SetJointPosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetJointPosition* New() const final {
    return CreateMaybeMessage<SetJointPosition>(NULL);
  }

  SetJointPosition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetJointPosition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetJointPosition& from);
  void MergeFrom(const SetJointPosition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetJointPosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  #if LANG_CXX11
  void set_model_name(::std::string&& value);
  #endif
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string joint_name = 2;
  bool has_joint_name() const;
  void clear_joint_name();
  static const int kJointNameFieldNumber = 2;
  const ::std::string& joint_name() const;
  void set_joint_name(const ::std::string& value);
  #if LANG_CXX11
  void set_joint_name(::std::string&& value);
  #endif
  void set_joint_name(const char* value);
  void set_joint_name(const char* value, size_t size);
  ::std::string* mutable_joint_name();
  ::std::string* release_joint_name();
  void set_allocated_joint_name(::std::string* joint_name);

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 5;
  private:
  const ::mw::internal::robotics::gazebotransport::Time& _internal_duration() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);

  // required double position = 4;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 4;
  double position() const;
  void set_position(double value);

  // required uint32 index = 3;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SetJointPosition)
 private:
  void set_has_model_name();
  void clear_has_model_name();
  void set_has_joint_name();
  void clear_has_joint_name();
  void set_has_index();
  void clear_has_index();
  void set_has_position();
  void clear_has_position();
  void set_has_duration();
  void clear_has_duration();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr joint_name_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  double position_;
  ::google::protobuf::uint32 index_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetJointVelocity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SetJointVelocity) */ {
 public:
  SetJointVelocity();
  virtual ~SetJointVelocity();

  SetJointVelocity(const SetJointVelocity& from);

  inline SetJointVelocity& operator=(const SetJointVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetJointVelocity(SetJointVelocity&& from) noexcept
    : SetJointVelocity() {
    *this = ::std::move(from);
  }

  inline SetJointVelocity& operator=(SetJointVelocity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetJointVelocity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetJointVelocity* internal_default_instance() {
    return reinterpret_cast<const SetJointVelocity*>(
               &_SetJointVelocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(SetJointVelocity* other);
  friend void swap(SetJointVelocity& a, SetJointVelocity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetJointVelocity* New() const final {
    return CreateMaybeMessage<SetJointVelocity>(NULL);
  }

  SetJointVelocity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetJointVelocity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetJointVelocity& from);
  void MergeFrom(const SetJointVelocity& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetJointVelocity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  #if LANG_CXX11
  void set_model_name(::std::string&& value);
  #endif
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string joint_name = 2;
  bool has_joint_name() const;
  void clear_joint_name();
  static const int kJointNameFieldNumber = 2;
  const ::std::string& joint_name() const;
  void set_joint_name(const ::std::string& value);
  #if LANG_CXX11
  void set_joint_name(::std::string&& value);
  #endif
  void set_joint_name(const char* value);
  void set_joint_name(const char* value, size_t size);
  ::std::string* mutable_joint_name();
  ::std::string* release_joint_name();
  void set_allocated_joint_name(::std::string* joint_name);

  // required .mw.internal.robotics.gazebotransport.Time duration = 5;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 5;
  private:
  const ::mw::internal::robotics::gazebotransport::Time& _internal_duration() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);

  // required double velocity = 4;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 4;
  double velocity() const;
  void set_velocity(double value);

  // required uint32 index = 3;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 3;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SetJointVelocity)
 private:
  void set_has_model_name();
  void clear_has_model_name();
  void set_has_joint_name();
  void clear_has_joint_name();
  void set_has_index();
  void clear_has_index();
  void set_has_velocity();
  void clear_has_velocity();
  void set_has_duration();
  void clear_has_duration();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr joint_name_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  double velocity_;
  ::google::protobuf::uint32 index_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetJointState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetJointState) */ {
 public:
  GetJointState();
  virtual ~GetJointState();

  GetJointState(const GetJointState& from);

  inline GetJointState& operator=(const GetJointState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetJointState(GetJointState&& from) noexcept
    : GetJointState() {
    *this = ::std::move(from);
  }

  inline GetJointState& operator=(GetJointState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetJointState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetJointState* internal_default_instance() {
    return reinterpret_cast<const GetJointState*>(
               &_GetJointState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(GetJointState* other);
  friend void swap(GetJointState& a, GetJointState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetJointState* New() const final {
    return CreateMaybeMessage<GetJointState>(NULL);
  }

  GetJointState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetJointState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetJointState& from);
  void MergeFrom(const GetJointState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetJointState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  #if LANG_CXX11
  void set_model_name(::std::string&& value);
  #endif
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string joint_name = 2;
  bool has_joint_name() const;
  void clear_joint_name();
  static const int kJointNameFieldNumber = 2;
  const ::std::string& joint_name() const;
  void set_joint_name(const ::std::string& value);
  #if LANG_CXX11
  void set_joint_name(::std::string&& value);
  #endif
  void set_joint_name(const char* value);
  void set_joint_name(const char* value, size_t size);
  ::std::string* mutable_joint_name();
  ::std::string* release_joint_name();
  void set_allocated_joint_name(::std::string* joint_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetJointState)
 private:
  void set_has_model_name();
  void clear_has_model_name();
  void set_has_joint_name();
  void clear_has_joint_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr joint_name_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Axis : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.Axis) */ {
 public:
  Axis();
  virtual ~Axis();

  Axis(const Axis& from);

  inline Axis& operator=(const Axis& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Axis(Axis&& from) noexcept
    : Axis() {
    *this = ::std::move(from);
  }

  inline Axis& operator=(Axis&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Axis& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Axis* internal_default_instance() {
    return reinterpret_cast<const Axis*>(
               &_Axis_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(Axis* other);
  friend void swap(Axis& a, Axis& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Axis* New() const final {
    return CreateMaybeMessage<Axis>(NULL);
  }

  Axis* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Axis>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Axis& from);
  void MergeFrom(const Axis& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Axis* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .mw.internal.robotics.gazebotransport.Point xyz = 1;
  bool has_xyz() const;
  void clear_xyz();
  static const int kXyzFieldNumber = 1;
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_xyz() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Point& xyz() const;
  ::mw::internal::robotics::gazebotransport::Point* release_xyz();
  ::mw::internal::robotics::gazebotransport::Point* mutable_xyz();
  void set_allocated_xyz(::mw::internal::robotics::gazebotransport::Point* xyz);

  // required double limit_lower = 2;
  bool has_limit_lower() const;
  void clear_limit_lower();
  static const int kLimitLowerFieldNumber = 2;
  double limit_lower() const;
  void set_limit_lower(double value);

  // required double limit_upper = 3;
  bool has_limit_upper() const;
  void clear_limit_upper();
  static const int kLimitUpperFieldNumber = 3;
  double limit_upper() const;
  void set_limit_upper(double value);

  // required double limit_effort = 4;
  bool has_limit_effort() const;
  void clear_limit_effort();
  static const int kLimitEffortFieldNumber = 4;
  double limit_effort() const;
  void set_limit_effort(double value);

  // required double limit_velocity = 5;
  bool has_limit_velocity() const;
  void clear_limit_velocity();
  static const int kLimitVelocityFieldNumber = 5;
  double limit_velocity() const;
  void set_limit_velocity(double value);

  // required double damping = 6;
  bool has_damping() const;
  void clear_damping();
  static const int kDampingFieldNumber = 6;
  double damping() const;
  void set_damping(double value);

  // required double friction = 7;
  bool has_friction() const;
  void clear_friction();
  static const int kFrictionFieldNumber = 7;
  double friction() const;
  void set_friction(double value);

  // required bool use_parent_model_frame = 8;
  bool has_use_parent_model_frame() const;
  void clear_use_parent_model_frame();
  static const int kUseParentModelFrameFieldNumber = 8;
  bool use_parent_model_frame() const;
  void set_use_parent_model_frame(bool value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.Axis)
 private:
  void set_has_xyz();
  void clear_has_xyz();
  void set_has_limit_lower();
  void clear_has_limit_lower();
  void set_has_limit_upper();
  void clear_has_limit_upper();
  void set_has_limit_effort();
  void clear_has_limit_effort();
  void set_has_limit_velocity();
  void clear_has_limit_velocity();
  void set_has_damping();
  void clear_has_damping();
  void set_has_friction();
  void clear_has_friction();
  void set_has_use_parent_model_frame();
  void clear_has_use_parent_model_frame();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::mw::internal::robotics::gazebotransport::Point* xyz_;
  double limit_lower_;
  double limit_upper_;
  double limit_effort_;
  double limit_velocity_;
  double damping_;
  double friction_;
  bool use_parent_model_frame_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JointState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.JointState) */ {
 public:
  JointState();
  virtual ~JointState();

  JointState(const JointState& from);

  inline JointState& operator=(const JointState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JointState(JointState&& from) noexcept
    : JointState() {
    *this = ::std::move(from);
  }

  inline JointState& operator=(JointState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JointState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JointState* internal_default_instance() {
    return reinterpret_cast<const JointState*>(
               &_JointState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(JointState* other);
  friend void swap(JointState& a, JointState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JointState* New() const final {
    return CreateMaybeMessage<JointState>(NULL);
  }

  JointState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JointState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JointState& from);
  void MergeFrom(const JointState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JointState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef JointState_Joint_Type Joint_Type;
  static const Joint_Type REVOLUTE =
    JointState_Joint_Type_REVOLUTE;
  static const Joint_Type REVOLUTE2 =
    JointState_Joint_Type_REVOLUTE2;
  static const Joint_Type PRISMATIC =
    JointState_Joint_Type_PRISMATIC;
  static const Joint_Type UNIVERSAL =
    JointState_Joint_Type_UNIVERSAL;
  static const Joint_Type BALL =
    JointState_Joint_Type_BALL;
  static const Joint_Type SCREW =
    JointState_Joint_Type_SCREW;
  static const Joint_Type GEARBOX =
    JointState_Joint_Type_GEARBOX;
  static const Joint_Type FIXED =
    JointState_Joint_Type_FIXED;
  static inline bool Joint_Type_IsValid(int value) {
    return JointState_Joint_Type_IsValid(value);
  }
  static const Joint_Type Joint_Type_MIN =
    JointState_Joint_Type_Joint_Type_MIN;
  static const Joint_Type Joint_Type_MAX =
    JointState_Joint_Type_Joint_Type_MAX;
  static const int Joint_Type_ARRAYSIZE =
    JointState_Joint_Type_Joint_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Joint_Type_descriptor() {
    return JointState_Joint_Type_descriptor();
  }
  static inline const ::std::string& Joint_Type_Name(Joint_Type value) {
    return JointState_Joint_Type_Name(value);
  }
  static inline bool Joint_Type_Parse(const ::std::string& name,
      Joint_Type* value) {
    return JointState_Joint_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated double joint_position = 4;
  int joint_position_size() const;
  void clear_joint_position();
  static const int kJointPositionFieldNumber = 4;
  double joint_position(int index) const;
  void set_joint_position(int index, double value);
  void add_joint_position(double value);
  const ::google::protobuf::RepeatedField< double >&
      joint_position() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_joint_position();

  // repeated double joint_velocity = 5;
  int joint_velocity_size() const;
  void clear_joint_velocity();
  static const int kJointVelocityFieldNumber = 5;
  double joint_velocity(int index) const;
  void set_joint_velocity(int index, double value);
  void add_joint_velocity(double value);
  const ::google::protobuf::RepeatedField< double >&
      joint_velocity() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_joint_velocity();

  // repeated .mw.internal.robotics.gazebotransport.Axis axis = 14;
  int axis_size() const;
  void clear_axis();
  static const int kAxisFieldNumber = 14;
  ::mw::internal::robotics::gazebotransport::Axis* mutable_axis(int index);
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis >*
      mutable_axis();
  const ::mw::internal::robotics::gazebotransport::Axis& axis(int index) const;
  ::mw::internal::robotics::gazebotransport::Axis* add_axis();
  const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis >&
      axis() const;

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  #if LANG_CXX11
  void set_model_name(::std::string&& value);
  #endif
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string joint_name = 2;
  bool has_joint_name() const;
  void clear_joint_name();
  static const int kJointNameFieldNumber = 2;
  const ::std::string& joint_name() const;
  void set_joint_name(const ::std::string& value);
  #if LANG_CXX11
  void set_joint_name(::std::string&& value);
  #endif
  void set_joint_name(const char* value);
  void set_joint_name(const char* value, size_t size);
  ::std::string* mutable_joint_name();
  ::std::string* release_joint_name();
  void set_allocated_joint_name(::std::string* joint_name);

  // optional string parent_name = 7;
  bool has_parent_name() const;
  void clear_parent_name();
  static const int kParentNameFieldNumber = 7;
  const ::std::string& parent_name() const;
  void set_parent_name(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_name(::std::string&& value);
  #endif
  void set_parent_name(const char* value);
  void set_parent_name(const char* value, size_t size);
  ::std::string* mutable_parent_name();
  ::std::string* release_parent_name();
  void set_allocated_parent_name(::std::string* parent_name);

  // optional string child_name = 9;
  bool has_child_name() const;
  void clear_child_name();
  static const int kChildNameFieldNumber = 9;
  const ::std::string& child_name() const;
  void set_child_name(const ::std::string& value);
  #if LANG_CXX11
  void set_child_name(::std::string&& value);
  #endif
  void set_child_name(const char* value);
  void set_child_name(const char* value, size_t size);
  ::std::string* mutable_child_name();
  ::std::string* release_child_name();
  void set_allocated_child_name(::std::string* child_name);

  // optional .mw.internal.robotics.gazebotransport.Pose initial_anchor_pose = 11;
  bool has_initial_anchor_pose() const;
  void clear_initial_anchor_pose();
  static const int kInitialAnchorPoseFieldNumber = 11;
  private:
  const ::mw::internal::robotics::gazebotransport::Pose& _internal_initial_anchor_pose() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Pose& initial_anchor_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* release_initial_anchor_pose();
  ::mw::internal::robotics::gazebotransport::Pose* mutable_initial_anchor_pose();
  void set_allocated_initial_anchor_pose(::mw::internal::robotics::gazebotransport::Pose* initial_anchor_pose);

  // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 12;
  bool has_world_pose() const;
  void clear_world_pose();
  static const int kWorldPoseFieldNumber = 12;
  private:
  const ::mw::internal::robotics::gazebotransport::Pose& _internal_world_pose() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Pose& world_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* release_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* mutable_world_pose();
  void set_allocated_world_pose(::mw::internal::robotics::gazebotransport::Pose* world_pose);

  // optional .mw.internal.robotics.gazebotransport.Pose parent_world_pose = 13;
  bool has_parent_world_pose() const;
  void clear_parent_world_pose();
  static const int kParentWorldPoseFieldNumber = 13;
  private:
  const ::mw::internal::robotics::gazebotransport::Pose& _internal_parent_world_pose() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Pose& parent_world_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* release_parent_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* mutable_parent_world_pose();
  void set_allocated_parent_world_pose(::mw::internal::robotics::gazebotransport::Pose* parent_world_pose);

  // required uint32 joint_id = 3;
  bool has_joint_id() const;
  void clear_joint_id();
  static const int kJointIdFieldNumber = 3;
  ::google::protobuf::uint32 joint_id() const;
  void set_joint_id(::google::protobuf::uint32 value);

  // optional uint32 parent_id = 8;
  bool has_parent_id() const;
  void clear_parent_id();
  static const int kParentIdFieldNumber = 8;
  ::google::protobuf::uint32 parent_id() const;
  void set_parent_id(::google::protobuf::uint32 value);

  // optional uint32 child_id = 10;
  bool has_child_id() const;
  void clear_child_id();
  static const int kChildIdFieldNumber = 10;
  ::google::protobuf::uint32 child_id() const;
  void set_child_id(::google::protobuf::uint32 value);

  // optional .mw.internal.robotics.gazebotransport.JointState.Joint_Type joint_type = 6;
  bool has_joint_type() const;
  void clear_joint_type();
  static const int kJointTypeFieldNumber = 6;
  ::mw::internal::robotics::gazebotransport::JointState_Joint_Type joint_type() const;
  void set_joint_type(::mw::internal::robotics::gazebotransport::JointState_Joint_Type value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.JointState)
 private:
  void set_has_model_name();
  void clear_has_model_name();
  void set_has_joint_name();
  void clear_has_joint_name();
  void set_has_joint_id();
  void clear_has_joint_id();
  void set_has_joint_type();
  void clear_has_joint_type();
  void set_has_parent_name();
  void clear_has_parent_name();
  void set_has_parent_id();
  void clear_has_parent_id();
  void set_has_child_name();
  void clear_has_child_name();
  void set_has_child_id();
  void clear_has_child_id();
  void set_has_initial_anchor_pose();
  void clear_has_initial_anchor_pose();
  void set_has_world_pose();
  void clear_has_world_pose();
  void set_has_parent_world_pose();
  void clear_has_parent_world_pose();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< double > joint_position_;
  ::google::protobuf::RepeatedField< double > joint_velocity_;
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis > axis_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr joint_name_;
  ::google::protobuf::internal::ArenaStringPtr parent_name_;
  ::google::protobuf::internal::ArenaStringPtr child_name_;
  ::mw::internal::robotics::gazebotransport::Pose* initial_anchor_pose_;
  ::mw::internal::robotics::gazebotransport::Pose* world_pose_;
  ::mw::internal::robotics::gazebotransport::Pose* parent_world_pose_;
  ::google::protobuf::uint32 joint_id_;
  ::google::protobuf::uint32 parent_id_;
  ::google::protobuf::uint32 child_id_;
  int joint_type_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetLinkWorldPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SetLinkWorldPose) */ {
 public:
  SetLinkWorldPose();
  virtual ~SetLinkWorldPose();

  SetLinkWorldPose(const SetLinkWorldPose& from);

  inline SetLinkWorldPose& operator=(const SetLinkWorldPose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetLinkWorldPose(SetLinkWorldPose&& from) noexcept
    : SetLinkWorldPose() {
    *this = ::std::move(from);
  }

  inline SetLinkWorldPose& operator=(SetLinkWorldPose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetLinkWorldPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetLinkWorldPose* internal_default_instance() {
    return reinterpret_cast<const SetLinkWorldPose*>(
               &_SetLinkWorldPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(SetLinkWorldPose* other);
  friend void swap(SetLinkWorldPose& a, SetLinkWorldPose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetLinkWorldPose* New() const final {
    return CreateMaybeMessage<SetLinkWorldPose>(NULL);
  }

  SetLinkWorldPose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetLinkWorldPose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetLinkWorldPose& from);
  void MergeFrom(const SetLinkWorldPose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLinkWorldPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  #if LANG_CXX11
  void set_model_name(::std::string&& value);
  #endif
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  #if LANG_CXX11
  void set_link_name(::std::string&& value);
  #endif
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // required .mw.internal.robotics.gazebotransport.Pose pose = 3;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 3;
  private:
  const ::mw::internal::robotics::gazebotransport::Pose& _internal_pose() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Pose& pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* release_pose();
  ::mw::internal::robotics::gazebotransport::Pose* mutable_pose();
  void set_allocated_pose(::mw::internal::robotics::gazebotransport::Pose* pose);

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 4;
  private:
  const ::mw::internal::robotics::gazebotransport::Time& _internal_duration() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SetLinkWorldPose)
 private:
  void set_has_model_name();
  void clear_has_model_name();
  void set_has_link_name();
  void clear_has_link_name();
  void set_has_pose();
  void clear_has_pose();
  void set_has_duration();
  void clear_has_duration();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  ::mw::internal::robotics::gazebotransport::Pose* pose_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetLinkLinearVelocity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity) */ {
 public:
  SetLinkLinearVelocity();
  virtual ~SetLinkLinearVelocity();

  SetLinkLinearVelocity(const SetLinkLinearVelocity& from);

  inline SetLinkLinearVelocity& operator=(const SetLinkLinearVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetLinkLinearVelocity(SetLinkLinearVelocity&& from) noexcept
    : SetLinkLinearVelocity() {
    *this = ::std::move(from);
  }

  inline SetLinkLinearVelocity& operator=(SetLinkLinearVelocity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetLinkLinearVelocity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetLinkLinearVelocity* internal_default_instance() {
    return reinterpret_cast<const SetLinkLinearVelocity*>(
               &_SetLinkLinearVelocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(SetLinkLinearVelocity* other);
  friend void swap(SetLinkLinearVelocity& a, SetLinkLinearVelocity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetLinkLinearVelocity* New() const final {
    return CreateMaybeMessage<SetLinkLinearVelocity>(NULL);
  }

  SetLinkLinearVelocity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetLinkLinearVelocity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetLinkLinearVelocity& from);
  void MergeFrom(const SetLinkLinearVelocity& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLinkLinearVelocity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  #if LANG_CXX11
  void set_model_name(::std::string&& value);
  #endif
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  #if LANG_CXX11
  void set_link_name(::std::string&& value);
  #endif
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_velocity() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Point& velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* release_velocity();
  ::mw::internal::robotics::gazebotransport::Point* mutable_velocity();
  void set_allocated_velocity(::mw::internal::robotics::gazebotransport::Point* velocity);

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 4;
  private:
  const ::mw::internal::robotics::gazebotransport::Time& _internal_duration() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity)
 private:
  void set_has_model_name();
  void clear_has_model_name();
  void set_has_link_name();
  void clear_has_link_name();
  void set_has_velocity();
  void clear_has_velocity();
  void set_has_duration();
  void clear_has_duration();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  ::mw::internal::robotics::gazebotransport::Point* velocity_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetLinkAngularVelocity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity) */ {
 public:
  SetLinkAngularVelocity();
  virtual ~SetLinkAngularVelocity();

  SetLinkAngularVelocity(const SetLinkAngularVelocity& from);

  inline SetLinkAngularVelocity& operator=(const SetLinkAngularVelocity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetLinkAngularVelocity(SetLinkAngularVelocity&& from) noexcept
    : SetLinkAngularVelocity() {
    *this = ::std::move(from);
  }

  inline SetLinkAngularVelocity& operator=(SetLinkAngularVelocity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetLinkAngularVelocity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetLinkAngularVelocity* internal_default_instance() {
    return reinterpret_cast<const SetLinkAngularVelocity*>(
               &_SetLinkAngularVelocity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(SetLinkAngularVelocity* other);
  friend void swap(SetLinkAngularVelocity& a, SetLinkAngularVelocity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetLinkAngularVelocity* New() const final {
    return CreateMaybeMessage<SetLinkAngularVelocity>(NULL);
  }

  SetLinkAngularVelocity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetLinkAngularVelocity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetLinkAngularVelocity& from);
  void MergeFrom(const SetLinkAngularVelocity& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLinkAngularVelocity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  #if LANG_CXX11
  void set_model_name(::std::string&& value);
  #endif
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  #if LANG_CXX11
  void set_link_name(::std::string&& value);
  #endif
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // required .mw.internal.robotics.gazebotransport.Point velocity = 3;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 3;
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_velocity() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Point& velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* release_velocity();
  ::mw::internal::robotics::gazebotransport::Point* mutable_velocity();
  void set_allocated_velocity(::mw::internal::robotics::gazebotransport::Point* velocity);

  // required .mw.internal.robotics.gazebotransport.Time duration = 4;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 4;
  private:
  const ::mw::internal::robotics::gazebotransport::Time& _internal_duration() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Time& duration() const;
  ::mw::internal::robotics::gazebotransport::Time* release_duration();
  ::mw::internal::robotics::gazebotransport::Time* mutable_duration();
  void set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity)
 private:
  void set_has_model_name();
  void clear_has_model_name();
  void set_has_link_name();
  void clear_has_link_name();
  void set_has_velocity();
  void clear_has_velocity();
  void set_has_duration();
  void clear_has_duration();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  ::mw::internal::robotics::gazebotransport::Point* velocity_;
  ::mw::internal::robotics::gazebotransport::Time* duration_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetLinkState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.GetLinkState) */ {
 public:
  GetLinkState();
  virtual ~GetLinkState();

  GetLinkState(const GetLinkState& from);

  inline GetLinkState& operator=(const GetLinkState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetLinkState(GetLinkState&& from) noexcept
    : GetLinkState() {
    *this = ::std::move(from);
  }

  inline GetLinkState& operator=(GetLinkState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetLinkState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetLinkState* internal_default_instance() {
    return reinterpret_cast<const GetLinkState*>(
               &_GetLinkState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(GetLinkState* other);
  friend void swap(GetLinkState& a, GetLinkState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetLinkState* New() const final {
    return CreateMaybeMessage<GetLinkState>(NULL);
  }

  GetLinkState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetLinkState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetLinkState& from);
  void MergeFrom(const GetLinkState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLinkState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  #if LANG_CXX11
  void set_model_name(::std::string&& value);
  #endif
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  #if LANG_CXX11
  void set_link_name(::std::string&& value);
  #endif
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.GetLinkState)
 private:
  void set_has_model_name();
  void clear_has_model_name();
  void set_has_link_name();
  void clear_has_link_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinkState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.LinkState) */ {
 public:
  LinkState();
  virtual ~LinkState();

  LinkState(const LinkState& from);

  inline LinkState& operator=(const LinkState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinkState(LinkState&& from) noexcept
    : LinkState() {
    *this = ::std::move(from);
  }

  inline LinkState& operator=(LinkState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinkState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinkState* internal_default_instance() {
    return reinterpret_cast<const LinkState*>(
               &_LinkState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(LinkState* other);
  friend void swap(LinkState& a, LinkState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinkState* New() const final {
    return CreateMaybeMessage<LinkState>(NULL);
  }

  LinkState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LinkState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LinkState& from);
  void MergeFrom(const LinkState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinkState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string model_name = 1;
  bool has_model_name() const;
  void clear_model_name();
  static const int kModelNameFieldNumber = 1;
  const ::std::string& model_name() const;
  void set_model_name(const ::std::string& value);
  #if LANG_CXX11
  void set_model_name(::std::string&& value);
  #endif
  void set_model_name(const char* value);
  void set_model_name(const char* value, size_t size);
  ::std::string* mutable_model_name();
  ::std::string* release_model_name();
  void set_allocated_model_name(::std::string* model_name);

  // required string link_name = 2;
  bool has_link_name() const;
  void clear_link_name();
  static const int kLinkNameFieldNumber = 2;
  const ::std::string& link_name() const;
  void set_link_name(const ::std::string& value);
  #if LANG_CXX11
  void set_link_name(::std::string&& value);
  #endif
  void set_link_name(const char* value);
  void set_link_name(const char* value, size_t size);
  ::std::string* mutable_link_name();
  ::std::string* release_link_name();
  void set_allocated_link_name(::std::string* link_name);

  // required .mw.internal.robotics.gazebotransport.Point world_linear_velocity = 4;
  bool has_world_linear_velocity() const;
  void clear_world_linear_velocity();
  static const int kWorldLinearVelocityFieldNumber = 4;
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_world_linear_velocity() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Point& world_linear_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* release_world_linear_velocity();
  ::mw::internal::robotics::gazebotransport::Point* mutable_world_linear_velocity();
  void set_allocated_world_linear_velocity(::mw::internal::robotics::gazebotransport::Point* world_linear_velocity);

  // required .mw.internal.robotics.gazebotransport.Point world_angular_velocity = 5;
  bool has_world_angular_velocity() const;
  void clear_world_angular_velocity();
  static const int kWorldAngularVelocityFieldNumber = 5;
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_world_angular_velocity() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Point& world_angular_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* release_world_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* mutable_world_angular_velocity();
  void set_allocated_world_angular_velocity(::mw::internal::robotics::gazebotransport::Point* world_angular_velocity);

  // required .mw.internal.robotics.gazebotransport.Point relative_linear_velocity = 6;
  bool has_relative_linear_velocity() const;
  void clear_relative_linear_velocity();
  static const int kRelativeLinearVelocityFieldNumber = 6;
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_relative_linear_velocity() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Point& relative_linear_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* release_relative_linear_velocity();
  ::mw::internal::robotics::gazebotransport::Point* mutable_relative_linear_velocity();
  void set_allocated_relative_linear_velocity(::mw::internal::robotics::gazebotransport::Point* relative_linear_velocity);

  // required .mw.internal.robotics.gazebotransport.Point relative_angular_velocity = 7;
  bool has_relative_angular_velocity() const;
  void clear_relative_angular_velocity();
  static const int kRelativeAngularVelocityFieldNumber = 7;
  private:
  const ::mw::internal::robotics::gazebotransport::Point& _internal_relative_angular_velocity() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Point& relative_angular_velocity() const;
  ::mw::internal::robotics::gazebotransport::Point* release_relative_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* mutable_relative_angular_velocity();
  void set_allocated_relative_angular_velocity(::mw::internal::robotics::gazebotransport::Point* relative_angular_velocity);

  // optional .mw.internal.robotics.gazebotransport.Pose world_pose = 8;
  bool has_world_pose() const;
  void clear_world_pose();
  static const int kWorldPoseFieldNumber = 8;
  private:
  const ::mw::internal::robotics::gazebotransport::Pose& _internal_world_pose() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Pose& world_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* release_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* mutable_world_pose();
  void set_allocated_world_pose(::mw::internal::robotics::gazebotransport::Pose* world_pose);

  // optional .mw.internal.robotics.gazebotransport.Pose relative_pose = 9;
  bool has_relative_pose() const;
  void clear_relative_pose();
  static const int kRelativePoseFieldNumber = 9;
  private:
  const ::mw::internal::robotics::gazebotransport::Pose& _internal_relative_pose() const;
  public:
  const ::mw::internal::robotics::gazebotransport::Pose& relative_pose() const;
  ::mw::internal::robotics::gazebotransport::Pose* release_relative_pose();
  ::mw::internal::robotics::gazebotransport::Pose* mutable_relative_pose();
  void set_allocated_relative_pose(::mw::internal::robotics::gazebotransport::Pose* relative_pose);

  // required uint32 link_id = 3;
  bool has_link_id() const;
  void clear_link_id();
  static const int kLinkIdFieldNumber = 3;
  ::google::protobuf::uint32 link_id() const;
  void set_link_id(::google::protobuf::uint32 value);

  // optional bool self_collide = 10;
  bool has_self_collide() const;
  void clear_self_collide();
  static const int kSelfCollideFieldNumber = 10;
  bool self_collide() const;
  void set_self_collide(bool value);

  // optional bool gravity = 11;
  bool has_gravity() const;
  void clear_gravity();
  static const int kGravityFieldNumber = 11;
  bool gravity() const;
  void set_gravity(bool value);

  // optional bool kinematic = 12;
  bool has_kinematic() const;
  void clear_kinematic();
  static const int kKinematicFieldNumber = 12;
  bool kinematic() const;
  void set_kinematic(bool value);

  // optional bool enable_wind = 13;
  bool has_enable_wind() const;
  void clear_enable_wind();
  static const int kEnableWindFieldNumber = 13;
  bool enable_wind() const;
  void set_enable_wind(bool value);

  // optional bool canonical = 14;
  bool has_canonical() const;
  void clear_canonical();
  static const int kCanonicalFieldNumber = 14;
  bool canonical() const;
  void set_canonical(bool value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.LinkState)
 private:
  void set_has_model_name();
  void clear_has_model_name();
  void set_has_link_name();
  void clear_has_link_name();
  void set_has_link_id();
  void clear_has_link_id();
  void set_has_world_linear_velocity();
  void clear_has_world_linear_velocity();
  void set_has_world_angular_velocity();
  void clear_has_world_angular_velocity();
  void set_has_relative_linear_velocity();
  void clear_has_relative_linear_velocity();
  void set_has_relative_angular_velocity();
  void clear_has_relative_angular_velocity();
  void set_has_world_pose();
  void clear_has_world_pose();
  void set_has_relative_pose();
  void clear_has_relative_pose();
  void set_has_self_collide();
  void clear_has_self_collide();
  void set_has_gravity();
  void clear_has_gravity();
  void set_has_kinematic();
  void clear_has_kinematic();
  void set_has_enable_wind();
  void clear_has_enable_wind();
  void set_has_canonical();
  void clear_has_canonical();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr model_name_;
  ::google::protobuf::internal::ArenaStringPtr link_name_;
  ::mw::internal::robotics::gazebotransport::Point* world_linear_velocity_;
  ::mw::internal::robotics::gazebotransport::Point* world_angular_velocity_;
  ::mw::internal::robotics::gazebotransport::Point* relative_linear_velocity_;
  ::mw::internal::robotics::gazebotransport::Point* relative_angular_velocity_;
  ::mw::internal::robotics::gazebotransport::Pose* world_pose_;
  ::mw::internal::robotics::gazebotransport::Pose* relative_pose_;
  ::google::protobuf::uint32 link_id_;
  bool self_collide_;
  bool gravity_;
  bool kinematic_;
  bool enable_wind_;
  bool canonical_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Time

// required uint64 seconds = 1;
inline bool Time::has_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Time::set_has_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Time::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Time::clear_seconds() {
  seconds_ = GOOGLE_ULONGLONG(0);
  clear_has_seconds();
}
inline ::google::protobuf::uint64 Time::seconds() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Time.seconds)
  return seconds_;
}
inline void Time::set_seconds(::google::protobuf::uint64 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Time.seconds)
}

// required uint64 nano_seconds = 2;
inline bool Time::has_nano_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Time::set_has_nano_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Time::clear_has_nano_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Time::clear_nano_seconds() {
  nano_seconds_ = GOOGLE_ULONGLONG(0);
  clear_has_nano_seconds();
}
inline ::google::protobuf::uint64 Time::nano_seconds() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Time.nano_seconds)
  return nano_seconds_;
}
inline void Time::set_nano_seconds(::google::protobuf::uint64 value) {
  set_has_nano_seconds();
  nano_seconds_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Time.nano_seconds)
}

// -------------------------------------------------------------------

// PacketHeader

// required .mw.internal.robotics.gazebotransport.PacketHeader.MsgID id = 1;
inline bool PacketHeader::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PacketHeader::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PacketHeader::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PacketHeader::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID PacketHeader::id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.PacketHeader.id)
  return static_cast< ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID >(id_);
}
inline void PacketHeader::set_id(::mw::internal::robotics::gazebotransport::PacketHeader_MsgID value) {
  assert(::mw::internal::robotics::gazebotransport::PacketHeader_MsgID_IsValid(value));
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.PacketHeader.id)
}

// required .mw.internal.robotics.gazebotransport.Time time_stamp = 2;
inline bool PacketHeader::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PacketHeader::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PacketHeader::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PacketHeader::clear_time_stamp() {
  if (time_stamp_ != NULL) time_stamp_->Clear();
  clear_has_time_stamp();
}
inline const ::mw::internal::robotics::gazebotransport::Time& PacketHeader::_internal_time_stamp() const {
  return *time_stamp_;
}
inline const ::mw::internal::robotics::gazebotransport::Time& PacketHeader::time_stamp() const {
  const ::mw::internal::robotics::gazebotransport::Time* p = time_stamp_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Time*>(
      &::mw::internal::robotics::gazebotransport::_Time_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Time* PacketHeader::release_time_stamp() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
  clear_has_time_stamp();
  ::mw::internal::robotics::gazebotransport::Time* temp = time_stamp_;
  time_stamp_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* PacketHeader::mutable_time_stamp() {
  set_has_time_stamp();
  if (time_stamp_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(GetArenaNoVirtual());
    time_stamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
  return time_stamp_;
}
inline void PacketHeader::set_allocated_time_stamp(::mw::internal::robotics::gazebotransport::Time* time_stamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete time_stamp_;
  }
  if (time_stamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      time_stamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_stamp, submessage_arena);
    }
    set_has_time_stamp();
  } else {
    clear_has_time_stamp();
  }
  time_stamp_ = time_stamp;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.PacketHeader.time_stamp)
}

// -------------------------------------------------------------------

// Packet

// required .mw.internal.robotics.gazebotransport.PacketHeader header = 1;
inline bool Packet::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Packet::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Packet::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Packet::clear_header() {
  if (header_ != NULL) header_->Clear();
  clear_has_header();
}
inline const ::mw::internal::robotics::gazebotransport::PacketHeader& Packet::_internal_header() const {
  return *header_;
}
inline const ::mw::internal::robotics::gazebotransport::PacketHeader& Packet::header() const {
  const ::mw::internal::robotics::gazebotransport::PacketHeader* p = header_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.header)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::PacketHeader*>(
      &::mw::internal::robotics::gazebotransport::_PacketHeader_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::PacketHeader* Packet::release_header() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.header)
  clear_has_header();
  ::mw::internal::robotics::gazebotransport::PacketHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::PacketHeader* Packet::mutable_header() {
  set_has_header();
  if (header_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::PacketHeader>(GetArenaNoVirtual());
    header_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.header)
  return header_;
}
inline void Packet::set_allocated_header(::mw::internal::robotics::gazebotransport::PacketHeader* header) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete header_;
  }
  if (header) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      header = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    set_has_header();
  } else {
    clear_has_header();
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Packet.header)
}

// optional .mw.internal.robotics.gazebotransport.Packet.CoSimError status = 2;
inline bool Packet::has_status() const {
  return payload_case() == kStatus;
}
inline void Packet::set_has_status() {
  _oneof_case_[0] = kStatus;
}
inline void Packet::clear_status() {
  if (has_status()) {
    payload_.status_ = 0;
    clear_has_payload();
  }
}
inline ::mw::internal::robotics::gazebotransport::Packet_CoSimError Packet::status() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.status)
  if (has_status()) {
    return static_cast< ::mw::internal::robotics::gazebotransport::Packet_CoSimError >(payload_.status_);
  }
  return static_cast< ::mw::internal::robotics::gazebotransport::Packet_CoSimError >(0);
}
inline void Packet::set_status(::mw::internal::robotics::gazebotransport::Packet_CoSimError value) {
  assert(::mw::internal::robotics::gazebotransport::Packet_CoSimError_IsValid(value));
  if (!has_status()) {
    clear_payload();
    set_has_status();
  }
  payload_.status_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Packet.status)
}

// optional .mw.internal.robotics.gazebotransport.StepSimulation step_simulation = 3;
inline bool Packet::has_step_simulation() const {
  return payload_case() == kStepSimulation;
}
inline void Packet::set_has_step_simulation() {
  _oneof_case_[0] = kStepSimulation;
}
inline void Packet::clear_step_simulation() {
  if (has_step_simulation()) {
    delete payload_.step_simulation_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::StepSimulation& Packet::_internal_step_simulation() const {
  return *payload_.step_simulation_;
}
inline ::mw::internal::robotics::gazebotransport::StepSimulation* Packet::release_step_simulation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.step_simulation)
  if (has_step_simulation()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::StepSimulation* temp = payload_.step_simulation_;
    payload_.step_simulation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::StepSimulation& Packet::step_simulation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.step_simulation)
  return has_step_simulation()
      ? *payload_.step_simulation_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::StepSimulation*>(&::mw::internal::robotics::gazebotransport::_StepSimulation_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::StepSimulation* Packet::mutable_step_simulation() {
  if (!has_step_simulation()) {
    clear_payload();
    set_has_step_simulation();
    payload_.step_simulation_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::StepSimulation >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.step_simulation)
  return payload_.step_simulation_;
}

// optional .mw.internal.robotics.gazebotransport.ResetSimulation reset_simulation = 4;
inline bool Packet::has_reset_simulation() const {
  return payload_case() == kResetSimulation;
}
inline void Packet::set_has_reset_simulation() {
  _oneof_case_[0] = kResetSimulation;
}
inline void Packet::clear_reset_simulation() {
  if (has_reset_simulation()) {
    delete payload_.reset_simulation_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::ResetSimulation& Packet::_internal_reset_simulation() const {
  return *payload_.reset_simulation_;
}
inline ::mw::internal::robotics::gazebotransport::ResetSimulation* Packet::release_reset_simulation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
  if (has_reset_simulation()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::ResetSimulation* temp = payload_.reset_simulation_;
    payload_.reset_simulation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::ResetSimulation& Packet::reset_simulation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
  return has_reset_simulation()
      ? *payload_.reset_simulation_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::ResetSimulation*>(&::mw::internal::robotics::gazebotransport::_ResetSimulation_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::ResetSimulation* Packet::mutable_reset_simulation() {
  if (!has_reset_simulation()) {
    clear_payload();
    set_has_reset_simulation();
    payload_.reset_simulation_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ResetSimulation >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.reset_simulation)
  return payload_.reset_simulation_;
}

// optional .mw.internal.robotics.gazebotransport.Image image = 5;
inline bool Packet::has_image() const {
  return payload_case() == kImage;
}
inline void Packet::set_has_image() {
  _oneof_case_[0] = kImage;
}
inline void Packet::clear_image() {
  if (has_image()) {
    delete payload_.image_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::Image& Packet::_internal_image() const {
  return *payload_.image_;
}
inline ::mw::internal::robotics::gazebotransport::Image* Packet::release_image() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.image)
  if (has_image()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::Image* temp = payload_.image_;
    payload_.image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::Image& Packet::image() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.image)
  return has_image()
      ? *payload_.image_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::Image*>(&::mw::internal::robotics::gazebotransport::_Image_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Image* Packet::mutable_image() {
  if (!has_image()) {
    clear_payload();
    set_has_image();
    payload_.image_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::Image >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.image)
  return payload_.image_;
}

// optional .mw.internal.robotics.gazebotransport.RequestImage request_image = 6;
inline bool Packet::has_request_image() const {
  return payload_case() == kRequestImage;
}
inline void Packet::set_has_request_image() {
  _oneof_case_[0] = kRequestImage;
}
inline void Packet::clear_request_image() {
  if (has_request_image()) {
    delete payload_.request_image_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::RequestImage& Packet::_internal_request_image() const {
  return *payload_.request_image_;
}
inline ::mw::internal::robotics::gazebotransport::RequestImage* Packet::release_request_image() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_image)
  if (has_request_image()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::RequestImage* temp = payload_.request_image_;
    payload_.request_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::RequestImage& Packet::request_image() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_image)
  return has_request_image()
      ? *payload_.request_image_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::RequestImage*>(&::mw::internal::robotics::gazebotransport::_RequestImage_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::RequestImage* Packet::mutable_request_image() {
  if (!has_request_image()) {
    clear_payload();
    set_has_request_image();
    payload_.request_image_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::RequestImage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_image)
  return payload_.request_image_;
}

// optional .mw.internal.robotics.gazebotransport.RequestCoSim request_cosim = 7;
inline bool Packet::has_request_cosim() const {
  return payload_case() == kRequestCosim;
}
inline void Packet::set_has_request_cosim() {
  _oneof_case_[0] = kRequestCosim;
}
inline void Packet::clear_request_cosim() {
  if (has_request_cosim()) {
    delete payload_.request_cosim_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::RequestCoSim& Packet::_internal_request_cosim() const {
  return *payload_.request_cosim_;
}
inline ::mw::internal::robotics::gazebotransport::RequestCoSim* Packet::release_request_cosim() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_cosim)
  if (has_request_cosim()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::RequestCoSim* temp = payload_.request_cosim_;
    payload_.request_cosim_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::RequestCoSim& Packet::request_cosim() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_cosim)
  return has_request_cosim()
      ? *payload_.request_cosim_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::RequestCoSim*>(&::mw::internal::robotics::gazebotransport::_RequestCoSim_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::RequestCoSim* Packet::mutable_request_cosim() {
  if (!has_request_cosim()) {
    clear_payload();
    set_has_request_cosim();
    payload_.request_cosim_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::RequestCoSim >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_cosim)
  return payload_.request_cosim_;
}

// optional .mw.internal.robotics.gazebotransport.StopCoSim stop_cosim = 8;
inline bool Packet::has_stop_cosim() const {
  return payload_case() == kStopCosim;
}
inline void Packet::set_has_stop_cosim() {
  _oneof_case_[0] = kStopCosim;
}
inline void Packet::clear_stop_cosim() {
  if (has_stop_cosim()) {
    delete payload_.stop_cosim_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::StopCoSim& Packet::_internal_stop_cosim() const {
  return *payload_.stop_cosim_;
}
inline ::mw::internal::robotics::gazebotransport::StopCoSim* Packet::release_stop_cosim() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
  if (has_stop_cosim()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::StopCoSim* temp = payload_.stop_cosim_;
    payload_.stop_cosim_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::StopCoSim& Packet::stop_cosim() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
  return has_stop_cosim()
      ? *payload_.stop_cosim_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::StopCoSim*>(&::mw::internal::robotics::gazebotransport::_StopCoSim_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::StopCoSim* Packet::mutable_stop_cosim() {
  if (!has_stop_cosim()) {
    clear_payload();
    set_has_stop_cosim();
    payload_.stop_cosim_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::StopCoSim >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.stop_cosim)
  return payload_.stop_cosim_;
}

// optional .mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose get_ground_truth_world_pose = 9;
inline bool Packet::has_get_ground_truth_world_pose() const {
  return payload_case() == kGetGroundTruthWorldPose;
}
inline void Packet::set_has_get_ground_truth_world_pose() {
  _oneof_case_[0] = kGetGroundTruthWorldPose;
}
inline void Packet::clear_get_ground_truth_world_pose() {
  if (has_get_ground_truth_world_pose()) {
    delete payload_.get_ground_truth_world_pose_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose& Packet::_internal_get_ground_truth_world_pose() const {
  return *payload_.get_ground_truth_world_pose_;
}
inline ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* Packet::release_get_ground_truth_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  if (has_get_ground_truth_world_pose()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* temp = payload_.get_ground_truth_world_pose_;
    payload_.get_ground_truth_world_pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose& Packet::get_ground_truth_world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  return has_get_ground_truth_world_pose()
      ? *payload_.get_ground_truth_world_pose_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose*>(&::mw::internal::robotics::gazebotransport::_GetGroundTruthWorldPose_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose* Packet::mutable_get_ground_truth_world_pose() {
  if (!has_get_ground_truth_world_pose()) {
    clear_payload();
    set_has_get_ground_truth_world_pose();
    payload_.get_ground_truth_world_pose_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetGroundTruthWorldPose >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_ground_truth_world_pose)
  return payload_.get_ground_truth_world_pose_;
}

// optional .mw.internal.robotics.gazebotransport.Pose pose = 10;
inline bool Packet::has_pose() const {
  return payload_case() == kPose;
}
inline void Packet::set_has_pose() {
  _oneof_case_[0] = kPose;
}
inline void Packet::clear_pose() {
  if (has_pose()) {
    delete payload_.pose_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::Pose& Packet::_internal_pose() const {
  return *payload_.pose_;
}
inline ::mw::internal::robotics::gazebotransport::Pose* Packet::release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.pose)
  if (has_pose()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::Pose* temp = payload_.pose_;
    payload_.pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::Pose& Packet::pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.pose)
  return has_pose()
      ? *payload_.pose_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::Pose*>(&::mw::internal::robotics::gazebotransport::_Pose_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Pose* Packet::mutable_pose() {
  if (!has_pose()) {
    clear_payload();
    set_has_pose();
    payload_.pose_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::Pose >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.pose)
  return payload_.pose_;
}

// optional .mw.internal.robotics.gazebotransport.StopSimulation stop_simulation = 11;
inline bool Packet::has_stop_simulation() const {
  return payload_case() == kStopSimulation;
}
inline void Packet::set_has_stop_simulation() {
  _oneof_case_[0] = kStopSimulation;
}
inline void Packet::clear_stop_simulation() {
  if (has_stop_simulation()) {
    delete payload_.stop_simulation_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::StopSimulation& Packet::_internal_stop_simulation() const {
  return *payload_.stop_simulation_;
}
inline ::mw::internal::robotics::gazebotransport::StopSimulation* Packet::release_stop_simulation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
  if (has_stop_simulation()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::StopSimulation* temp = payload_.stop_simulation_;
    payload_.stop_simulation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::StopSimulation& Packet::stop_simulation() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
  return has_stop_simulation()
      ? *payload_.stop_simulation_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::StopSimulation*>(&::mw::internal::robotics::gazebotransport::_StopSimulation_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::StopSimulation* Packet::mutable_stop_simulation() {
  if (!has_stop_simulation()) {
    clear_payload();
    set_has_stop_simulation();
    payload_.stop_simulation_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::StopSimulation >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.stop_simulation)
  return payload_.stop_simulation_;
}

// optional .mw.internal.robotics.gazebotransport.LaserData laser_data = 12;
inline bool Packet::has_laser_data() const {
  return payload_case() == kLaserData;
}
inline void Packet::set_has_laser_data() {
  _oneof_case_[0] = kLaserData;
}
inline void Packet::clear_laser_data() {
  if (has_laser_data()) {
    delete payload_.laser_data_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::LaserData& Packet::_internal_laser_data() const {
  return *payload_.laser_data_;
}
inline ::mw::internal::robotics::gazebotransport::LaserData* Packet::release_laser_data() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.laser_data)
  if (has_laser_data()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::LaserData* temp = payload_.laser_data_;
    payload_.laser_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::LaserData& Packet::laser_data() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.laser_data)
  return has_laser_data()
      ? *payload_.laser_data_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::LaserData*>(&::mw::internal::robotics::gazebotransport::_LaserData_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::LaserData* Packet::mutable_laser_data() {
  if (!has_laser_data()) {
    clear_payload();
    set_has_laser_data();
    payload_.laser_data_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::LaserData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.laser_data)
  return payload_.laser_data_;
}

// optional .mw.internal.robotics.gazebotransport.RequestLaser request_laser = 13;
inline bool Packet::has_request_laser() const {
  return payload_case() == kRequestLaser;
}
inline void Packet::set_has_request_laser() {
  _oneof_case_[0] = kRequestLaser;
}
inline void Packet::clear_request_laser() {
  if (has_request_laser()) {
    delete payload_.request_laser_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::RequestLaser& Packet::_internal_request_laser() const {
  return *payload_.request_laser_;
}
inline ::mw::internal::robotics::gazebotransport::RequestLaser* Packet::release_request_laser() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_laser)
  if (has_request_laser()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::RequestLaser* temp = payload_.request_laser_;
    payload_.request_laser_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::RequestLaser& Packet::request_laser() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_laser)
  return has_request_laser()
      ? *payload_.request_laser_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::RequestLaser*>(&::mw::internal::robotics::gazebotransport::_RequestLaser_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::RequestLaser* Packet::mutable_request_laser() {
  if (!has_request_laser()) {
    clear_payload();
    set_has_request_laser();
    payload_.request_laser_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::RequestLaser >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_laser)
  return payload_.request_laser_;
}

// optional .mw.internal.robotics.gazebotransport.ImuData imu_data = 14;
inline bool Packet::has_imu_data() const {
  return payload_case() == kImuData;
}
inline void Packet::set_has_imu_data() {
  _oneof_case_[0] = kImuData;
}
inline void Packet::clear_imu_data() {
  if (has_imu_data()) {
    delete payload_.imu_data_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::ImuData& Packet::_internal_imu_data() const {
  return *payload_.imu_data_;
}
inline ::mw::internal::robotics::gazebotransport::ImuData* Packet::release_imu_data() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.imu_data)
  if (has_imu_data()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::ImuData* temp = payload_.imu_data_;
    payload_.imu_data_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::ImuData& Packet::imu_data() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.imu_data)
  return has_imu_data()
      ? *payload_.imu_data_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::ImuData*>(&::mw::internal::robotics::gazebotransport::_ImuData_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::ImuData* Packet::mutable_imu_data() {
  if (!has_imu_data()) {
    clear_payload();
    set_has_imu_data();
    payload_.imu_data_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ImuData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.imu_data)
  return payload_.imu_data_;
}

// optional .mw.internal.robotics.gazebotransport.RequestImu request_imu = 15;
inline bool Packet::has_request_imu() const {
  return payload_case() == kRequestImu;
}
inline void Packet::set_has_request_imu() {
  _oneof_case_[0] = kRequestImu;
}
inline void Packet::clear_request_imu() {
  if (has_request_imu()) {
    delete payload_.request_imu_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::RequestImu& Packet::_internal_request_imu() const {
  return *payload_.request_imu_;
}
inline ::mw::internal::robotics::gazebotransport::RequestImu* Packet::release_request_imu() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_imu)
  if (has_request_imu()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::RequestImu* temp = payload_.request_imu_;
    payload_.request_imu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::RequestImu& Packet::request_imu() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_imu)
  return has_request_imu()
      ? *payload_.request_imu_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::RequestImu*>(&::mw::internal::robotics::gazebotransport::_RequestImu_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::RequestImu* Packet::mutable_request_imu() {
  if (!has_request_imu()) {
    clear_payload();
    set_has_request_imu();
    payload_.request_imu_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::RequestImu >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_imu)
  return payload_.request_imu_;
}

// optional .mw.internal.robotics.gazebotransport.SubscribeImage subscribe_image = 16;
inline bool Packet::has_subscribe_image() const {
  return payload_case() == kSubscribeImage;
}
inline void Packet::set_has_subscribe_image() {
  _oneof_case_[0] = kSubscribeImage;
}
inline void Packet::clear_subscribe_image() {
  if (has_subscribe_image()) {
    delete payload_.subscribe_image_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::SubscribeImage& Packet::_internal_subscribe_image() const {
  return *payload_.subscribe_image_;
}
inline ::mw::internal::robotics::gazebotransport::SubscribeImage* Packet::release_subscribe_image() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
  if (has_subscribe_image()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::SubscribeImage* temp = payload_.subscribe_image_;
    payload_.subscribe_image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::SubscribeImage& Packet::subscribe_image() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
  return has_subscribe_image()
      ? *payload_.subscribe_image_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::SubscribeImage*>(&::mw::internal::robotics::gazebotransport::_SubscribeImage_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::SubscribeImage* Packet::mutable_subscribe_image() {
  if (!has_subscribe_image()) {
    clear_payload();
    set_has_subscribe_image();
    payload_.subscribe_image_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SubscribeImage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.subscribe_image)
  return payload_.subscribe_image_;
}

// optional .mw.internal.robotics.gazebotransport.SubscribeLaser subscribe_laser = 17;
inline bool Packet::has_subscribe_laser() const {
  return payload_case() == kSubscribeLaser;
}
inline void Packet::set_has_subscribe_laser() {
  _oneof_case_[0] = kSubscribeLaser;
}
inline void Packet::clear_subscribe_laser() {
  if (has_subscribe_laser()) {
    delete payload_.subscribe_laser_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::SubscribeLaser& Packet::_internal_subscribe_laser() const {
  return *payload_.subscribe_laser_;
}
inline ::mw::internal::robotics::gazebotransport::SubscribeLaser* Packet::release_subscribe_laser() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
  if (has_subscribe_laser()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::SubscribeLaser* temp = payload_.subscribe_laser_;
    payload_.subscribe_laser_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::SubscribeLaser& Packet::subscribe_laser() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
  return has_subscribe_laser()
      ? *payload_.subscribe_laser_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::SubscribeLaser*>(&::mw::internal::robotics::gazebotransport::_SubscribeLaser_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::SubscribeLaser* Packet::mutable_subscribe_laser() {
  if (!has_subscribe_laser()) {
    clear_payload();
    set_has_subscribe_laser();
    payload_.subscribe_laser_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SubscribeLaser >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.subscribe_laser)
  return payload_.subscribe_laser_;
}

// optional .mw.internal.robotics.gazebotransport.SubscribeImu subscribe_imu = 18;
inline bool Packet::has_subscribe_imu() const {
  return payload_case() == kSubscribeImu;
}
inline void Packet::set_has_subscribe_imu() {
  _oneof_case_[0] = kSubscribeImu;
}
inline void Packet::clear_subscribe_imu() {
  if (has_subscribe_imu()) {
    delete payload_.subscribe_imu_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::SubscribeImu& Packet::_internal_subscribe_imu() const {
  return *payload_.subscribe_imu_;
}
inline ::mw::internal::robotics::gazebotransport::SubscribeImu* Packet::release_subscribe_imu() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
  if (has_subscribe_imu()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::SubscribeImu* temp = payload_.subscribe_imu_;
    payload_.subscribe_imu_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::SubscribeImu& Packet::subscribe_imu() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
  return has_subscribe_imu()
      ? *payload_.subscribe_imu_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::SubscribeImu*>(&::mw::internal::robotics::gazebotransport::_SubscribeImu_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::SubscribeImu* Packet::mutable_subscribe_imu() {
  if (!has_subscribe_imu()) {
    clear_payload();
    set_has_subscribe_imu();
    payload_.subscribe_imu_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SubscribeImu >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.subscribe_imu)
  return payload_.subscribe_imu_;
}

// optional .mw.internal.robotics.gazebotransport.ApplyJointTorque apply_joint_torque = 19;
inline bool Packet::has_apply_joint_torque() const {
  return payload_case() == kApplyJointTorque;
}
inline void Packet::set_has_apply_joint_torque() {
  _oneof_case_[0] = kApplyJointTorque;
}
inline void Packet::clear_apply_joint_torque() {
  if (has_apply_joint_torque()) {
    delete payload_.apply_joint_torque_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::ApplyJointTorque& Packet::_internal_apply_joint_torque() const {
  return *payload_.apply_joint_torque_;
}
inline ::mw::internal::robotics::gazebotransport::ApplyJointTorque* Packet::release_apply_joint_torque() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
  if (has_apply_joint_torque()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::ApplyJointTorque* temp = payload_.apply_joint_torque_;
    payload_.apply_joint_torque_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::ApplyJointTorque& Packet::apply_joint_torque() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
  return has_apply_joint_torque()
      ? *payload_.apply_joint_torque_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::ApplyJointTorque*>(&::mw::internal::robotics::gazebotransport::_ApplyJointTorque_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::ApplyJointTorque* Packet::mutable_apply_joint_torque() {
  if (!has_apply_joint_torque()) {
    clear_payload();
    set_has_apply_joint_torque();
    payload_.apply_joint_torque_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ApplyJointTorque >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.apply_joint_torque)
  return payload_.apply_joint_torque_;
}

// optional .mw.internal.robotics.gazebotransport.GetPose get_pose = 20;
inline bool Packet::has_get_pose() const {
  return payload_case() == kGetPose;
}
inline void Packet::set_has_get_pose() {
  _oneof_case_[0] = kGetPose;
}
inline void Packet::clear_get_pose() {
  if (has_get_pose()) {
    delete payload_.get_pose_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetPose& Packet::_internal_get_pose() const {
  return *payload_.get_pose_;
}
inline ::mw::internal::robotics::gazebotransport::GetPose* Packet::release_get_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_pose)
  if (has_get_pose()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::GetPose* temp = payload_.get_pose_;
    payload_.get_pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetPose& Packet::get_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_pose)
  return has_get_pose()
      ? *payload_.get_pose_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::GetPose*>(&::mw::internal::robotics::gazebotransport::_GetPose_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::GetPose* Packet::mutable_get_pose() {
  if (!has_get_pose()) {
    clear_payload();
    set_has_get_pose();
    payload_.get_pose_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetPose >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_pose)
  return payload_.get_pose_;
}

// optional .mw.internal.robotics.gazebotransport.GetTopicList get_topic_list = 21;
inline bool Packet::has_get_topic_list() const {
  return payload_case() == kGetTopicList;
}
inline void Packet::set_has_get_topic_list() {
  _oneof_case_[0] = kGetTopicList;
}
inline void Packet::clear_get_topic_list() {
  if (has_get_topic_list()) {
    delete payload_.get_topic_list_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetTopicList& Packet::_internal_get_topic_list() const {
  return *payload_.get_topic_list_;
}
inline ::mw::internal::robotics::gazebotransport::GetTopicList* Packet::release_get_topic_list() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
  if (has_get_topic_list()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::GetTopicList* temp = payload_.get_topic_list_;
    payload_.get_topic_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetTopicList& Packet::get_topic_list() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
  return has_get_topic_list()
      ? *payload_.get_topic_list_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::GetTopicList*>(&::mw::internal::robotics::gazebotransport::_GetTopicList_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::GetTopicList* Packet::mutable_get_topic_list() {
  if (!has_get_topic_list()) {
    clear_payload();
    set_has_get_topic_list();
    payload_.get_topic_list_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetTopicList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_topic_list)
  return payload_.get_topic_list_;
}

// optional .mw.internal.robotics.gazebotransport.TopicList topic_list = 22;
inline bool Packet::has_topic_list() const {
  return payload_case() == kTopicList;
}
inline void Packet::set_has_topic_list() {
  _oneof_case_[0] = kTopicList;
}
inline void Packet::clear_topic_list() {
  if (has_topic_list()) {
    delete payload_.topic_list_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::TopicList& Packet::_internal_topic_list() const {
  return *payload_.topic_list_;
}
inline ::mw::internal::robotics::gazebotransport::TopicList* Packet::release_topic_list() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.topic_list)
  if (has_topic_list()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::TopicList* temp = payload_.topic_list_;
    payload_.topic_list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::TopicList& Packet::topic_list() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.topic_list)
  return has_topic_list()
      ? *payload_.topic_list_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::TopicList*>(&::mw::internal::robotics::gazebotransport::_TopicList_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::TopicList* Packet::mutable_topic_list() {
  if (!has_topic_list()) {
    clear_payload();
    set_has_topic_list();
    payload_.topic_list_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::TopicList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.topic_list)
  return payload_.topic_list_;
}

// optional .mw.internal.robotics.gazebotransport.GetModelInfo get_model_info = 23;
inline bool Packet::has_get_model_info() const {
  return payload_case() == kGetModelInfo;
}
inline void Packet::set_has_get_model_info() {
  _oneof_case_[0] = kGetModelInfo;
}
inline void Packet::clear_get_model_info() {
  if (has_get_model_info()) {
    delete payload_.get_model_info_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetModelInfo& Packet::_internal_get_model_info() const {
  return *payload_.get_model_info_;
}
inline ::mw::internal::robotics::gazebotransport::GetModelInfo* Packet::release_get_model_info() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_model_info)
  if (has_get_model_info()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::GetModelInfo* temp = payload_.get_model_info_;
    payload_.get_model_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetModelInfo& Packet::get_model_info() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_model_info)
  return has_get_model_info()
      ? *payload_.get_model_info_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::GetModelInfo*>(&::mw::internal::robotics::gazebotransport::_GetModelInfo_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::GetModelInfo* Packet::mutable_get_model_info() {
  if (!has_get_model_info()) {
    clear_payload();
    set_has_get_model_info();
    payload_.get_model_info_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetModelInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_model_info)
  return payload_.get_model_info_;
}

// optional .mw.internal.robotics.gazebotransport.ModelInfo model_info = 24;
inline bool Packet::has_model_info() const {
  return payload_case() == kModelInfo;
}
inline void Packet::set_has_model_info() {
  _oneof_case_[0] = kModelInfo;
}
inline void Packet::clear_model_info() {
  if (has_model_info()) {
    delete payload_.model_info_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo& Packet::_internal_model_info() const {
  return *payload_.model_info_;
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo* Packet::release_model_info() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.model_info)
  if (has_model_info()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::ModelInfo* temp = payload_.model_info_;
    payload_.model_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo& Packet::model_info() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.model_info)
  return has_model_info()
      ? *payload_.model_info_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::ModelInfo*>(&::mw::internal::robotics::gazebotransport::_ModelInfo_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo* Packet::mutable_model_info() {
  if (!has_model_info()) {
    clear_payload();
    set_has_model_info();
    payload_.model_info_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ModelInfo >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.model_info)
  return payload_.model_info_;
}

// optional .mw.internal.robotics.gazebotransport.ApplyLinkWrench apply_link_wrench = 25;
inline bool Packet::has_apply_link_wrench() const {
  return payload_case() == kApplyLinkWrench;
}
inline void Packet::set_has_apply_link_wrench() {
  _oneof_case_[0] = kApplyLinkWrench;
}
inline void Packet::clear_apply_link_wrench() {
  if (has_apply_link_wrench()) {
    delete payload_.apply_link_wrench_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::ApplyLinkWrench& Packet::_internal_apply_link_wrench() const {
  return *payload_.apply_link_wrench_;
}
inline ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* Packet::release_apply_link_wrench() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
  if (has_apply_link_wrench()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* temp = payload_.apply_link_wrench_;
    payload_.apply_link_wrench_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::ApplyLinkWrench& Packet::apply_link_wrench() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
  return has_apply_link_wrench()
      ? *payload_.apply_link_wrench_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::ApplyLinkWrench*>(&::mw::internal::robotics::gazebotransport::_ApplyLinkWrench_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::ApplyLinkWrench* Packet::mutable_apply_link_wrench() {
  if (!has_apply_link_wrench()) {
    clear_payload();
    set_has_apply_link_wrench();
    payload_.apply_link_wrench_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::ApplyLinkWrench >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.apply_link_wrench)
  return payload_.apply_link_wrench_;
}

// optional .mw.internal.robotics.gazebotransport.MaxStepSize max_step_size = 26;
inline bool Packet::has_max_step_size() const {
  return payload_case() == kMaxStepSize;
}
inline void Packet::set_has_max_step_size() {
  _oneof_case_[0] = kMaxStepSize;
}
inline void Packet::clear_max_step_size() {
  if (has_max_step_size()) {
    delete payload_.max_step_size_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::MaxStepSize& Packet::_internal_max_step_size() const {
  return *payload_.max_step_size_;
}
inline ::mw::internal::robotics::gazebotransport::MaxStepSize* Packet::release_max_step_size() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.max_step_size)
  if (has_max_step_size()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::MaxStepSize* temp = payload_.max_step_size_;
    payload_.max_step_size_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::MaxStepSize& Packet::max_step_size() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.max_step_size)
  return has_max_step_size()
      ? *payload_.max_step_size_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::MaxStepSize*>(&::mw::internal::robotics::gazebotransport::_MaxStepSize_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::MaxStepSize* Packet::mutable_max_step_size() {
  if (!has_max_step_size()) {
    clear_payload();
    set_has_max_step_size();
    payload_.max_step_size_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::MaxStepSize >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.max_step_size)
  return payload_.max_step_size_;
}

// optional .mw.internal.robotics.gazebotransport.CustomMessageSupport custom_message_support = 27;
inline bool Packet::has_custom_message_support() const {
  return payload_case() == kCustomMessageSupport;
}
inline void Packet::set_has_custom_message_support() {
  _oneof_case_[0] = kCustomMessageSupport;
}
inline void Packet::clear_custom_message_support() {
  if (has_custom_message_support()) {
    delete payload_.custom_message_support_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::CustomMessageSupport& Packet::_internal_custom_message_support() const {
  return *payload_.custom_message_support_;
}
inline ::mw::internal::robotics::gazebotransport::CustomMessageSupport* Packet::release_custom_message_support() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
  if (has_custom_message_support()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::CustomMessageSupport* temp = payload_.custom_message_support_;
    payload_.custom_message_support_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::CustomMessageSupport& Packet::custom_message_support() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
  return has_custom_message_support()
      ? *payload_.custom_message_support_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::CustomMessageSupport*>(&::mw::internal::robotics::gazebotransport::_CustomMessageSupport_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::CustomMessageSupport* Packet::mutable_custom_message_support() {
  if (!has_custom_message_support()) {
    clear_payload();
    set_has_custom_message_support();
    payload_.custom_message_support_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::CustomMessageSupport >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.custom_message_support)
  return payload_.custom_message_support_;
}

// optional .mw.internal.robotics.gazebotransport.InitCustomPublisher init_custom_publisher = 28;
inline bool Packet::has_init_custom_publisher() const {
  return payload_case() == kInitCustomPublisher;
}
inline void Packet::set_has_init_custom_publisher() {
  _oneof_case_[0] = kInitCustomPublisher;
}
inline void Packet::clear_init_custom_publisher() {
  if (has_init_custom_publisher()) {
    delete payload_.init_custom_publisher_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::InitCustomPublisher& Packet::_internal_init_custom_publisher() const {
  return *payload_.init_custom_publisher_;
}
inline ::mw::internal::robotics::gazebotransport::InitCustomPublisher* Packet::release_init_custom_publisher() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
  if (has_init_custom_publisher()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::InitCustomPublisher* temp = payload_.init_custom_publisher_;
    payload_.init_custom_publisher_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::InitCustomPublisher& Packet::init_custom_publisher() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
  return has_init_custom_publisher()
      ? *payload_.init_custom_publisher_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::InitCustomPublisher*>(&::mw::internal::robotics::gazebotransport::_InitCustomPublisher_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::InitCustomPublisher* Packet::mutable_init_custom_publisher() {
  if (!has_init_custom_publisher()) {
    clear_payload();
    set_has_init_custom_publisher();
    payload_.init_custom_publisher_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::InitCustomPublisher >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.init_custom_publisher)
  return payload_.init_custom_publisher_;
}

// optional .mw.internal.robotics.gazebotransport.InitCustomSubscriber init_custom_subscriber = 29;
inline bool Packet::has_init_custom_subscriber() const {
  return payload_case() == kInitCustomSubscriber;
}
inline void Packet::set_has_init_custom_subscriber() {
  _oneof_case_[0] = kInitCustomSubscriber;
}
inline void Packet::clear_init_custom_subscriber() {
  if (has_init_custom_subscriber()) {
    delete payload_.init_custom_subscriber_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::InitCustomSubscriber& Packet::_internal_init_custom_subscriber() const {
  return *payload_.init_custom_subscriber_;
}
inline ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* Packet::release_init_custom_subscriber() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
  if (has_init_custom_subscriber()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* temp = payload_.init_custom_subscriber_;
    payload_.init_custom_subscriber_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::InitCustomSubscriber& Packet::init_custom_subscriber() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
  return has_init_custom_subscriber()
      ? *payload_.init_custom_subscriber_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::InitCustomSubscriber*>(&::mw::internal::robotics::gazebotransport::_InitCustomSubscriber_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::InitCustomSubscriber* Packet::mutable_init_custom_subscriber() {
  if (!has_init_custom_subscriber()) {
    clear_payload();
    set_has_init_custom_subscriber();
    payload_.init_custom_subscriber_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::InitCustomSubscriber >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.init_custom_subscriber)
  return payload_.init_custom_subscriber_;
}

// optional .mw.internal.robotics.gazebotransport.RequestCustomMessageSupport request_custom_message_support = 30;
inline bool Packet::has_request_custom_message_support() const {
  return payload_case() == kRequestCustomMessageSupport;
}
inline void Packet::set_has_request_custom_message_support() {
  _oneof_case_[0] = kRequestCustomMessageSupport;
}
inline void Packet::clear_request_custom_message_support() {
  if (has_request_custom_message_support()) {
    delete payload_.request_custom_message_support_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport& Packet::_internal_request_custom_message_support() const {
  return *payload_.request_custom_message_support_;
}
inline ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* Packet::release_request_custom_message_support() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
  if (has_request_custom_message_support()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* temp = payload_.request_custom_message_support_;
    payload_.request_custom_message_support_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport& Packet::request_custom_message_support() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
  return has_request_custom_message_support()
      ? *payload_.request_custom_message_support_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport*>(&::mw::internal::robotics::gazebotransport::_RequestCustomMessageSupport_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport* Packet::mutable_request_custom_message_support() {
  if (!has_request_custom_message_support()) {
    clear_payload();
    set_has_request_custom_message_support();
    payload_.request_custom_message_support_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::RequestCustomMessageSupport >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.request_custom_message_support)
  return payload_.request_custom_message_support_;
}

// optional .mw.internal.robotics.gazebotransport.SetJointPosition set_joint_position = 31;
inline bool Packet::has_set_joint_position() const {
  return payload_case() == kSetJointPosition;
}
inline void Packet::set_has_set_joint_position() {
  _oneof_case_[0] = kSetJointPosition;
}
inline void Packet::clear_set_joint_position() {
  if (has_set_joint_position()) {
    delete payload_.set_joint_position_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::SetJointPosition& Packet::_internal_set_joint_position() const {
  return *payload_.set_joint_position_;
}
inline ::mw::internal::robotics::gazebotransport::SetJointPosition* Packet::release_set_joint_position() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
  if (has_set_joint_position()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::SetJointPosition* temp = payload_.set_joint_position_;
    payload_.set_joint_position_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::SetJointPosition& Packet::set_joint_position() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
  return has_set_joint_position()
      ? *payload_.set_joint_position_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::SetJointPosition*>(&::mw::internal::robotics::gazebotransport::_SetJointPosition_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::SetJointPosition* Packet::mutable_set_joint_position() {
  if (!has_set_joint_position()) {
    clear_payload();
    set_has_set_joint_position();
    payload_.set_joint_position_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SetJointPosition >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_joint_position)
  return payload_.set_joint_position_;
}

// optional .mw.internal.robotics.gazebotransport.SetJointVelocity set_joint_velocity = 32;
inline bool Packet::has_set_joint_velocity() const {
  return payload_case() == kSetJointVelocity;
}
inline void Packet::set_has_set_joint_velocity() {
  _oneof_case_[0] = kSetJointVelocity;
}
inline void Packet::clear_set_joint_velocity() {
  if (has_set_joint_velocity()) {
    delete payload_.set_joint_velocity_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::SetJointVelocity& Packet::_internal_set_joint_velocity() const {
  return *payload_.set_joint_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::SetJointVelocity* Packet::release_set_joint_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
  if (has_set_joint_velocity()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::SetJointVelocity* temp = payload_.set_joint_velocity_;
    payload_.set_joint_velocity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::SetJointVelocity& Packet::set_joint_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
  return has_set_joint_velocity()
      ? *payload_.set_joint_velocity_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::SetJointVelocity*>(&::mw::internal::robotics::gazebotransport::_SetJointVelocity_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::SetJointVelocity* Packet::mutable_set_joint_velocity() {
  if (!has_set_joint_velocity()) {
    clear_payload();
    set_has_set_joint_velocity();
    payload_.set_joint_velocity_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SetJointVelocity >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_joint_velocity)
  return payload_.set_joint_velocity_;
}

// optional .mw.internal.robotics.gazebotransport.GetJointState get_joint_state = 33;
inline bool Packet::has_get_joint_state() const {
  return payload_case() == kGetJointState;
}
inline void Packet::set_has_get_joint_state() {
  _oneof_case_[0] = kGetJointState;
}
inline void Packet::clear_get_joint_state() {
  if (has_get_joint_state()) {
    delete payload_.get_joint_state_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetJointState& Packet::_internal_get_joint_state() const {
  return *payload_.get_joint_state_;
}
inline ::mw::internal::robotics::gazebotransport::GetJointState* Packet::release_get_joint_state() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
  if (has_get_joint_state()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::GetJointState* temp = payload_.get_joint_state_;
    payload_.get_joint_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetJointState& Packet::get_joint_state() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
  return has_get_joint_state()
      ? *payload_.get_joint_state_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::GetJointState*>(&::mw::internal::robotics::gazebotransport::_GetJointState_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::GetJointState* Packet::mutable_get_joint_state() {
  if (!has_get_joint_state()) {
    clear_payload();
    set_has_get_joint_state();
    payload_.get_joint_state_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetJointState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_joint_state)
  return payload_.get_joint_state_;
}

// optional .mw.internal.robotics.gazebotransport.JointState joint_state = 34;
inline bool Packet::has_joint_state() const {
  return payload_case() == kJointState;
}
inline void Packet::set_has_joint_state() {
  _oneof_case_[0] = kJointState;
}
inline void Packet::clear_joint_state() {
  if (has_joint_state()) {
    delete payload_.joint_state_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::JointState& Packet::_internal_joint_state() const {
  return *payload_.joint_state_;
}
inline ::mw::internal::robotics::gazebotransport::JointState* Packet::release_joint_state() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.joint_state)
  if (has_joint_state()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::JointState* temp = payload_.joint_state_;
    payload_.joint_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::JointState& Packet::joint_state() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.joint_state)
  return has_joint_state()
      ? *payload_.joint_state_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::JointState*>(&::mw::internal::robotics::gazebotransport::_JointState_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::JointState* Packet::mutable_joint_state() {
  if (!has_joint_state()) {
    clear_payload();
    set_has_joint_state();
    payload_.joint_state_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::JointState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.joint_state)
  return payload_.joint_state_;
}

// optional .mw.internal.robotics.gazebotransport.SetLinkWorldPose set_link_world_pose = 35;
inline bool Packet::has_set_link_world_pose() const {
  return payload_case() == kSetLinkWorldPose;
}
inline void Packet::set_has_set_link_world_pose() {
  _oneof_case_[0] = kSetLinkWorldPose;
}
inline void Packet::clear_set_link_world_pose() {
  if (has_set_link_world_pose()) {
    delete payload_.set_link_world_pose_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::SetLinkWorldPose& Packet::_internal_set_link_world_pose() const {
  return *payload_.set_link_world_pose_;
}
inline ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* Packet::release_set_link_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
  if (has_set_link_world_pose()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* temp = payload_.set_link_world_pose_;
    payload_.set_link_world_pose_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::SetLinkWorldPose& Packet::set_link_world_pose() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
  return has_set_link_world_pose()
      ? *payload_.set_link_world_pose_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::SetLinkWorldPose*>(&::mw::internal::robotics::gazebotransport::_SetLinkWorldPose_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::SetLinkWorldPose* Packet::mutable_set_link_world_pose() {
  if (!has_set_link_world_pose()) {
    clear_payload();
    set_has_set_link_world_pose();
    payload_.set_link_world_pose_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SetLinkWorldPose >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_link_world_pose)
  return payload_.set_link_world_pose_;
}

// optional .mw.internal.robotics.gazebotransport.SetLinkLinearVelocity set_link_linear_velocity = 36;
inline bool Packet::has_set_link_linear_velocity() const {
  return payload_case() == kSetLinkLinearVelocity;
}
inline void Packet::set_has_set_link_linear_velocity() {
  _oneof_case_[0] = kSetLinkLinearVelocity;
}
inline void Packet::clear_set_link_linear_velocity() {
  if (has_set_link_linear_velocity()) {
    delete payload_.set_link_linear_velocity_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity& Packet::_internal_set_link_linear_velocity() const {
  return *payload_.set_link_linear_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* Packet::release_set_link_linear_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
  if (has_set_link_linear_velocity()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* temp = payload_.set_link_linear_velocity_;
    payload_.set_link_linear_velocity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity& Packet::set_link_linear_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
  return has_set_link_linear_velocity()
      ? *payload_.set_link_linear_velocity_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity*>(&::mw::internal::robotics::gazebotransport::_SetLinkLinearVelocity_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity* Packet::mutable_set_link_linear_velocity() {
  if (!has_set_link_linear_velocity()) {
    clear_payload();
    set_has_set_link_linear_velocity();
    payload_.set_link_linear_velocity_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SetLinkLinearVelocity >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_link_linear_velocity)
  return payload_.set_link_linear_velocity_;
}

// optional .mw.internal.robotics.gazebotransport.SetLinkAngularVelocity set_link_angular_velocity = 37;
inline bool Packet::has_set_link_angular_velocity() const {
  return payload_case() == kSetLinkAngularVelocity;
}
inline void Packet::set_has_set_link_angular_velocity() {
  _oneof_case_[0] = kSetLinkAngularVelocity;
}
inline void Packet::clear_set_link_angular_velocity() {
  if (has_set_link_angular_velocity()) {
    delete payload_.set_link_angular_velocity_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity& Packet::_internal_set_link_angular_velocity() const {
  return *payload_.set_link_angular_velocity_;
}
inline ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* Packet::release_set_link_angular_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
  if (has_set_link_angular_velocity()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* temp = payload_.set_link_angular_velocity_;
    payload_.set_link_angular_velocity_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity& Packet::set_link_angular_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
  return has_set_link_angular_velocity()
      ? *payload_.set_link_angular_velocity_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity*>(&::mw::internal::robotics::gazebotransport::_SetLinkAngularVelocity_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity* Packet::mutable_set_link_angular_velocity() {
  if (!has_set_link_angular_velocity()) {
    clear_payload();
    set_has_set_link_angular_velocity();
    payload_.set_link_angular_velocity_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::SetLinkAngularVelocity >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.set_link_angular_velocity)
  return payload_.set_link_angular_velocity_;
}

// optional .mw.internal.robotics.gazebotransport.GetLinkState get_link_state = 38;
inline bool Packet::has_get_link_state() const {
  return payload_case() == kGetLinkState;
}
inline void Packet::set_has_get_link_state() {
  _oneof_case_[0] = kGetLinkState;
}
inline void Packet::clear_get_link_state() {
  if (has_get_link_state()) {
    delete payload_.get_link_state_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetLinkState& Packet::_internal_get_link_state() const {
  return *payload_.get_link_state_;
}
inline ::mw::internal::robotics::gazebotransport::GetLinkState* Packet::release_get_link_state() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.get_link_state)
  if (has_get_link_state()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::GetLinkState* temp = payload_.get_link_state_;
    payload_.get_link_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::GetLinkState& Packet::get_link_state() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.get_link_state)
  return has_get_link_state()
      ? *payload_.get_link_state_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::GetLinkState*>(&::mw::internal::robotics::gazebotransport::_GetLinkState_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::GetLinkState* Packet::mutable_get_link_state() {
  if (!has_get_link_state()) {
    clear_payload();
    set_has_get_link_state();
    payload_.get_link_state_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::GetLinkState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.get_link_state)
  return payload_.get_link_state_;
}

// optional .mw.internal.robotics.gazebotransport.LinkState link_state = 39;
inline bool Packet::has_link_state() const {
  return payload_case() == kLinkState;
}
inline void Packet::set_has_link_state() {
  _oneof_case_[0] = kLinkState;
}
inline void Packet::clear_link_state() {
  if (has_link_state()) {
    delete payload_.link_state_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::LinkState& Packet::_internal_link_state() const {
  return *payload_.link_state_;
}
inline ::mw::internal::robotics::gazebotransport::LinkState* Packet::release_link_state() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Packet.link_state)
  if (has_link_state()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::LinkState* temp = payload_.link_state_;
    payload_.link_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::LinkState& Packet::link_state() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Packet.link_state)
  return has_link_state()
      ? *payload_.link_state_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::LinkState*>(&::mw::internal::robotics::gazebotransport::_LinkState_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::LinkState* Packet::mutable_link_state() {
  if (!has_link_state()) {
    clear_payload();
    set_has_link_state();
    payload_.link_state_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::LinkState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Packet.link_state)
  return payload_.link_state_;
}

inline bool Packet::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void Packet::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline Packet::PayloadCase Packet::payload_case() const {
  return Packet::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StepSimulation

// required uint32 num_steps = 1;
inline bool StepSimulation::has_num_steps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StepSimulation::set_has_num_steps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StepSimulation::clear_has_num_steps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StepSimulation::clear_num_steps() {
  num_steps_ = 0u;
  clear_has_num_steps();
}
inline ::google::protobuf::uint32 StepSimulation::num_steps() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.StepSimulation.num_steps)
  return num_steps_;
}
inline void StepSimulation::set_num_steps(::google::protobuf::uint32 value) {
  set_has_num_steps();
  num_steps_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.StepSimulation.num_steps)
}

// -------------------------------------------------------------------

// ResetSimulation

// required .mw.internal.robotics.gazebotransport.ResetSimulation.ResetBehavior behavior = 1;
inline bool ResetSimulation::has_behavior() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResetSimulation::set_has_behavior() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResetSimulation::clear_has_behavior() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResetSimulation::clear_behavior() {
  behavior_ = 0;
  clear_has_behavior();
}
inline ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior ResetSimulation::behavior() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ResetSimulation.behavior)
  return static_cast< ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior >(behavior_);
}
inline void ResetSimulation::set_behavior(::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior value) {
  assert(::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior_IsValid(value));
  set_has_behavior();
  behavior_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ResetSimulation.behavior)
}

// -------------------------------------------------------------------

// Image

// required uint32 width = 1;
inline bool Image::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Image::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Image::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Image::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 Image::width() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Image.width)
  return width_;
}
inline void Image::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Image.width)
}

// required uint32 height = 2;
inline bool Image::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Image::set_has_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Image::clear_has_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Image::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Image::height() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Image.height)
  return height_;
}
inline void Image::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Image.height)
}

// required bytes data = 3;
inline bool Image::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Image::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Image::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Image::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& Image::data() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Image.data)
  return data_.GetNoArena();
}
inline void Image::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Image.data)
}
#if LANG_CXX11
inline void Image::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.Image.data)
}
#endif
inline void Image::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.Image.data)
}
inline void Image::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.Image.data)
}
inline ::std::string* Image::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Image.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Image::release_data() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Image.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Image.data)
}

// required string data_type = 4;
inline bool Image::has_data_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Image::set_has_data_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Image::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Image::clear_data_type() {
  data_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data_type();
}
inline const ::std::string& Image::data_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Image.data_type)
  return data_type_.GetNoArena();
}
inline void Image::set_data_type(const ::std::string& value) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Image.data_type)
}
#if LANG_CXX11
inline void Image::set_data_type(::std::string&& value) {
  set_has_data_type();
  data_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.Image.data_type)
}
#endif
inline void Image::set_data_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.Image.data_type)
}
inline void Image::set_data_type(const char* value, size_t size) {
  set_has_data_type();
  data_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.Image.data_type)
}
inline ::std::string* Image::mutable_data_type() {
  set_has_data_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Image.data_type)
  return data_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Image::release_data_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Image.data_type)
  if (!has_data_type()) {
    return NULL;
  }
  clear_has_data_type();
  return data_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_data_type(::std::string* data_type) {
  if (data_type != NULL) {
    set_has_data_type();
  } else {
    clear_has_data_type();
  }
  data_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Image.data_type)
}

// -------------------------------------------------------------------

// RequestImage

// required string topic_name = 1;
inline bool RequestImage::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestImage::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestImage::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestImage::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& RequestImage::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
  return topic_name_.GetNoArena();
}
inline void RequestImage::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}
#if LANG_CXX11
inline void RequestImage::set_topic_name(::std::string&& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}
#endif
inline void RequestImage::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}
inline void RequestImage::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}
inline ::std::string* RequestImage::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestImage::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
  if (!has_topic_name()) {
    return NULL;
  }
  clear_has_topic_name();
  return topic_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestImage::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestImage.topic_name)
}

// -------------------------------------------------------------------

// RequestCoSim

// required string client_id = 1;
inline bool RequestCoSim::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCoSim::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCoSim::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCoSim::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_id();
}
inline const ::std::string& RequestCoSim::client_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
  return client_id_.GetNoArena();
}
inline void RequestCoSim::set_client_id(const ::std::string& value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}
#if LANG_CXX11
inline void RequestCoSim::set_client_id(::std::string&& value) {
  set_has_client_id();
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}
#endif
inline void RequestCoSim::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}
inline void RequestCoSim::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}
inline ::std::string* RequestCoSim::mutable_client_id() {
  set_has_client_id();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestCoSim::release_client_id() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
  if (!has_client_id()) {
    return NULL;
  }
  clear_has_client_id();
  return client_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestCoSim::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestCoSim.client_id)
}

// required double duration = 2;
inline bool RequestCoSim::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestCoSim::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestCoSim::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestCoSim::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double RequestCoSim::duration() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestCoSim.duration)
  return duration_;
}
inline void RequestCoSim::set_duration(double value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestCoSim.duration)
}

// -------------------------------------------------------------------

// StopCoSim

// required string client_id = 1;
inline bool StopCoSim::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopCoSim::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopCoSim::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopCoSim::clear_client_id() {
  client_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_client_id();
}
inline const ::std::string& StopCoSim::client_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
  return client_id_.GetNoArena();
}
inline void StopCoSim::set_client_id(const ::std::string& value) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}
#if LANG_CXX11
inline void StopCoSim::set_client_id(::std::string&& value) {
  set_has_client_id();
  client_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}
#endif
inline void StopCoSim::set_client_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}
inline void StopCoSim::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  client_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}
inline ::std::string* StopCoSim::mutable_client_id() {
  set_has_client_id();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
  return client_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopCoSim::release_client_id() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
  if (!has_client_id()) {
    return NULL;
  }
  clear_has_client_id();
  return client_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopCoSim::set_allocated_client_id(::std::string* client_id) {
  if (client_id != NULL) {
    set_has_client_id();
  } else {
    clear_has_client_id();
  }
  client_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_id);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.StopCoSim.client_id)
}

// -------------------------------------------------------------------

// GetGroundTruthWorldPose

// required string model_name = 1;
inline bool GetGroundTruthWorldPose::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetGroundTruthWorldPose::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetGroundTruthWorldPose::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetGroundTruthWorldPose::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& GetGroundTruthWorldPose::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  return model_name_.GetNoArena();
}
inline void GetGroundTruthWorldPose::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
#if LANG_CXX11
inline void GetGroundTruthWorldPose::set_model_name(::std::string&& value) {
  set_has_model_name();
  model_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
#endif
inline void GetGroundTruthWorldPose::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
inline void GetGroundTruthWorldPose::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}
inline ::std::string* GetGroundTruthWorldPose::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetGroundTruthWorldPose::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
  if (!has_model_name()) {
    return NULL;
  }
  clear_has_model_name();
  return model_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetGroundTruthWorldPose::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.model_name)
}

// required string link_name = 2;
inline bool GetGroundTruthWorldPose::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetGroundTruthWorldPose::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetGroundTruthWorldPose::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetGroundTruthWorldPose::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& GetGroundTruthWorldPose::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  return link_name_.GetNoArena();
}
inline void GetGroundTruthWorldPose::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
#if LANG_CXX11
inline void GetGroundTruthWorldPose::set_link_name(::std::string&& value) {
  set_has_link_name();
  link_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
#endif
inline void GetGroundTruthWorldPose::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
inline void GetGroundTruthWorldPose::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}
inline ::std::string* GetGroundTruthWorldPose::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetGroundTruthWorldPose::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
  if (!has_link_name()) {
    return NULL;
  }
  clear_has_link_name();
  return link_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetGroundTruthWorldPose::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetGroundTruthWorldPose.link_name)
}

// -------------------------------------------------------------------

// Point

// required double x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Point::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Point.x)
  return x_;
}
inline void Point::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Point.x)
}

// required double y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Point::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Point.y)
  return y_;
}
inline void Point::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Point.y)
}

// required double z = 3;
inline bool Point::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Point::z() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Point.z)
  return z_;
}
inline void Point::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Point.z)
}

// -------------------------------------------------------------------

// Quaternion

// required double x = 1;
inline bool Quaternion::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Quaternion::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Quaternion::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double Quaternion::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Quaternion.x)
  return x_;
}
inline void Quaternion::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Quaternion.x)
}

// required double y = 2;
inline bool Quaternion::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Quaternion::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Quaternion::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double Quaternion::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Quaternion.y)
  return y_;
}
inline void Quaternion::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Quaternion.y)
}

// required double z = 3;
inline bool Quaternion::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Quaternion::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Quaternion::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double Quaternion::z() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Quaternion.z)
  return z_;
}
inline void Quaternion::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Quaternion.z)
}

// required double w = 4;
inline bool Quaternion::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Quaternion::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Quaternion::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double Quaternion::w() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Quaternion.w)
  return w_;
}
inline void Quaternion::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Quaternion.w)
}

// -------------------------------------------------------------------

// Pose

// required .mw.internal.robotics.gazebotransport.Point position = 1;
inline bool Pose::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pose::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pose::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pose::clear_position() {
  if (position_ != NULL) position_->Clear();
  clear_has_position();
}
inline const ::mw::internal::robotics::gazebotransport::Point& Pose::_internal_position() const {
  return *position_;
}
inline const ::mw::internal::robotics::gazebotransport::Point& Pose::position() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = position_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Pose.position)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Point* Pose::release_position() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Pose.position)
  clear_has_position();
  ::mw::internal::robotics::gazebotransport::Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* Pose::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Pose.position)
  return position_;
}
inline void Pose::set_allocated_position(::mw::internal::robotics::gazebotransport::Point* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    set_has_position();
  } else {
    clear_has_position();
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Pose.position)
}

// required .mw.internal.robotics.gazebotransport.Quaternion orientation = 2;
inline bool Pose::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pose::set_has_orientation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pose::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pose::clear_orientation() {
  if (orientation_ != NULL) orientation_->Clear();
  clear_has_orientation();
}
inline const ::mw::internal::robotics::gazebotransport::Quaternion& Pose::_internal_orientation() const {
  return *orientation_;
}
inline const ::mw::internal::robotics::gazebotransport::Quaternion& Pose::orientation() const {
  const ::mw::internal::robotics::gazebotransport::Quaternion* p = orientation_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Pose.orientation)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Quaternion*>(
      &::mw::internal::robotics::gazebotransport::_Quaternion_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Quaternion* Pose::release_orientation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Pose.orientation)
  clear_has_orientation();
  ::mw::internal::robotics::gazebotransport::Quaternion* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Quaternion* Pose::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Quaternion>(GetArenaNoVirtual());
    orientation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Pose.orientation)
  return orientation_;
}
inline void Pose::set_allocated_orientation(::mw::internal::robotics::gazebotransport::Quaternion* orientation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orientation_;
  }
  if (orientation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orientation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Pose.orientation)
}

// -------------------------------------------------------------------

// StopSimulation

// required bool stop_scene = 1;
inline bool StopSimulation::has_stop_scene() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopSimulation::set_has_stop_scene() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopSimulation::clear_has_stop_scene() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopSimulation::clear_stop_scene() {
  stop_scene_ = false;
  clear_has_stop_scene();
}
inline bool StopSimulation::stop_scene() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.StopSimulation.stop_scene)
  return stop_scene_;
}
inline void StopSimulation::set_stop_scene(bool value) {
  set_has_stop_scene();
  stop_scene_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.StopSimulation.stop_scene)
}

// -------------------------------------------------------------------

// LaserData

// required double angle_min = 1;
inline bool LaserData::has_angle_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaserData::set_has_angle_min() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaserData::clear_has_angle_min() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaserData::clear_angle_min() {
  angle_min_ = 0;
  clear_has_angle_min();
}
inline double LaserData::angle_min() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.angle_min)
  return angle_min_;
}
inline void LaserData::set_angle_min(double value) {
  set_has_angle_min();
  angle_min_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.angle_min)
}

// required double angle_max = 2;
inline bool LaserData::has_angle_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaserData::set_has_angle_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaserData::clear_has_angle_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaserData::clear_angle_max() {
  angle_max_ = 0;
  clear_has_angle_max();
}
inline double LaserData::angle_max() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.angle_max)
  return angle_max_;
}
inline void LaserData::set_angle_max(double value) {
  set_has_angle_max();
  angle_max_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.angle_max)
}

// required double angle_step = 3;
inline bool LaserData::has_angle_step() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaserData::set_has_angle_step() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaserData::clear_has_angle_step() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaserData::clear_angle_step() {
  angle_step_ = 0;
  clear_has_angle_step();
}
inline double LaserData::angle_step() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.angle_step)
  return angle_step_;
}
inline void LaserData::set_angle_step(double value) {
  set_has_angle_step();
  angle_step_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.angle_step)
}

// required double range_min = 4;
inline bool LaserData::has_range_min() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaserData::set_has_range_min() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaserData::clear_has_range_min() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaserData::clear_range_min() {
  range_min_ = 0;
  clear_has_range_min();
}
inline double LaserData::range_min() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.range_min)
  return range_min_;
}
inline void LaserData::set_range_min(double value) {
  set_has_range_min();
  range_min_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.range_min)
}

// required double range_max = 5;
inline bool LaserData::has_range_max() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LaserData::set_has_range_max() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LaserData::clear_has_range_max() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LaserData::clear_range_max() {
  range_max_ = 0;
  clear_has_range_max();
}
inline double LaserData::range_max() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.range_max)
  return range_max_;
}
inline void LaserData::set_range_max(double value) {
  set_has_range_max();
  range_max_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.range_max)
}

// required double count = 6;
inline bool LaserData::has_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LaserData::set_has_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LaserData::clear_has_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LaserData::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline double LaserData::count() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.count)
  return count_;
}
inline void LaserData::set_count(double value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.count)
}

// required double vertical_angle_min = 7;
inline bool LaserData::has_vertical_angle_min() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LaserData::set_has_vertical_angle_min() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LaserData::clear_has_vertical_angle_min() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LaserData::clear_vertical_angle_min() {
  vertical_angle_min_ = 0;
  clear_has_vertical_angle_min();
}
inline double LaserData::vertical_angle_min() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_min)
  return vertical_angle_min_;
}
inline void LaserData::set_vertical_angle_min(double value) {
  set_has_vertical_angle_min();
  vertical_angle_min_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_min)
}

// required double vertical_angle_max = 8;
inline bool LaserData::has_vertical_angle_max() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LaserData::set_has_vertical_angle_max() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LaserData::clear_has_vertical_angle_max() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LaserData::clear_vertical_angle_max() {
  vertical_angle_max_ = 0;
  clear_has_vertical_angle_max();
}
inline double LaserData::vertical_angle_max() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_max)
  return vertical_angle_max_;
}
inline void LaserData::set_vertical_angle_max(double value) {
  set_has_vertical_angle_max();
  vertical_angle_max_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_max)
}

// required double vertical_angle_step = 9;
inline bool LaserData::has_vertical_angle_step() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LaserData::set_has_vertical_angle_step() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LaserData::clear_has_vertical_angle_step() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LaserData::clear_vertical_angle_step() {
  vertical_angle_step_ = 0;
  clear_has_vertical_angle_step();
}
inline double LaserData::vertical_angle_step() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_step)
  return vertical_angle_step_;
}
inline void LaserData::set_vertical_angle_step(double value) {
  set_has_vertical_angle_step();
  vertical_angle_step_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.vertical_angle_step)
}

// repeated double range = 10;
inline int LaserData::range_size() const {
  return range_.size();
}
inline void LaserData::clear_range() {
  range_.Clear();
}
inline double LaserData::range(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.range)
  return range_.Get(index);
}
inline void LaserData::set_range(int index, double value) {
  range_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.range)
}
inline void LaserData::add_range(double value) {
  range_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.LaserData.range)
}
inline const ::google::protobuf::RepeatedField< double >&
LaserData::range() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.LaserData.range)
  return range_;
}
inline ::google::protobuf::RepeatedField< double >*
LaserData::mutable_range() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.LaserData.range)
  return &range_;
}

// repeated double intensities = 11;
inline int LaserData::intensities_size() const {
  return intensities_.size();
}
inline void LaserData::clear_intensities() {
  intensities_.Clear();
}
inline double LaserData::intensities(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LaserData.intensities)
  return intensities_.Get(index);
}
inline void LaserData::set_intensities(int index, double value) {
  intensities_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LaserData.intensities)
}
inline void LaserData::add_intensities(double value) {
  intensities_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.LaserData.intensities)
}
inline const ::google::protobuf::RepeatedField< double >&
LaserData::intensities() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.LaserData.intensities)
  return intensities_;
}
inline ::google::protobuf::RepeatedField< double >*
LaserData::mutable_intensities() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.LaserData.intensities)
  return &intensities_;
}

// -------------------------------------------------------------------

// RequestLaser

// required string topic_name = 1;
inline bool RequestLaser::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestLaser::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestLaser::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestLaser::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& RequestLaser::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
  return topic_name_.GetNoArena();
}
inline void RequestLaser::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}
#if LANG_CXX11
inline void RequestLaser::set_topic_name(::std::string&& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}
#endif
inline void RequestLaser::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}
inline void RequestLaser::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}
inline ::std::string* RequestLaser::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestLaser::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
  if (!has_topic_name()) {
    return NULL;
  }
  clear_has_topic_name();
  return topic_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestLaser::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestLaser.topic_name)
}

// -------------------------------------------------------------------

// ImuData

// required .mw.internal.robotics.gazebotransport.Point linear_acceleration = 1;
inline bool ImuData::has_linear_acceleration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImuData::set_has_linear_acceleration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImuData::clear_has_linear_acceleration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImuData::clear_linear_acceleration() {
  if (linear_acceleration_ != NULL) linear_acceleration_->Clear();
  clear_has_linear_acceleration();
}
inline const ::mw::internal::robotics::gazebotransport::Point& ImuData::_internal_linear_acceleration() const {
  return *linear_acceleration_;
}
inline const ::mw::internal::robotics::gazebotransport::Point& ImuData::linear_acceleration() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = linear_acceleration_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Point* ImuData::release_linear_acceleration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
  clear_has_linear_acceleration();
  ::mw::internal::robotics::gazebotransport::Point* temp = linear_acceleration_;
  linear_acceleration_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* ImuData::mutable_linear_acceleration() {
  set_has_linear_acceleration();
  if (linear_acceleration_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArenaNoVirtual());
    linear_acceleration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
  return linear_acceleration_;
}
inline void ImuData::set_allocated_linear_acceleration(::mw::internal::robotics::gazebotransport::Point* linear_acceleration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete linear_acceleration_;
  }
  if (linear_acceleration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      linear_acceleration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, linear_acceleration, submessage_arena);
    }
    set_has_linear_acceleration();
  } else {
    clear_has_linear_acceleration();
  }
  linear_acceleration_ = linear_acceleration;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ImuData.linear_acceleration)
}

// required .mw.internal.robotics.gazebotransport.Point angular_velocity = 2;
inline bool ImuData::has_angular_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImuData::set_has_angular_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImuData::clear_has_angular_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImuData::clear_angular_velocity() {
  if (angular_velocity_ != NULL) angular_velocity_->Clear();
  clear_has_angular_velocity();
}
inline const ::mw::internal::robotics::gazebotransport::Point& ImuData::_internal_angular_velocity() const {
  return *angular_velocity_;
}
inline const ::mw::internal::robotics::gazebotransport::Point& ImuData::angular_velocity() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = angular_velocity_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Point* ImuData::release_angular_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
  clear_has_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = angular_velocity_;
  angular_velocity_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* ImuData::mutable_angular_velocity() {
  set_has_angular_velocity();
  if (angular_velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArenaNoVirtual());
    angular_velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
  return angular_velocity_;
}
inline void ImuData::set_allocated_angular_velocity(::mw::internal::robotics::gazebotransport::Point* angular_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete angular_velocity_;
  }
  if (angular_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      angular_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angular_velocity, submessage_arena);
    }
    set_has_angular_velocity();
  } else {
    clear_has_angular_velocity();
  }
  angular_velocity_ = angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ImuData.angular_velocity)
}

// required .mw.internal.robotics.gazebotransport.Quaternion orientation = 3;
inline bool ImuData::has_orientation() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImuData::set_has_orientation() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImuData::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImuData::clear_orientation() {
  if (orientation_ != NULL) orientation_->Clear();
  clear_has_orientation();
}
inline const ::mw::internal::robotics::gazebotransport::Quaternion& ImuData::_internal_orientation() const {
  return *orientation_;
}
inline const ::mw::internal::robotics::gazebotransport::Quaternion& ImuData::orientation() const {
  const ::mw::internal::robotics::gazebotransport::Quaternion* p = orientation_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ImuData.orientation)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Quaternion*>(
      &::mw::internal::robotics::gazebotransport::_Quaternion_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Quaternion* ImuData::release_orientation() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ImuData.orientation)
  clear_has_orientation();
  ::mw::internal::robotics::gazebotransport::Quaternion* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Quaternion* ImuData::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Quaternion>(GetArenaNoVirtual());
    orientation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ImuData.orientation)
  return orientation_;
}
inline void ImuData::set_allocated_orientation(::mw::internal::robotics::gazebotransport::Quaternion* orientation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete orientation_;
  }
  if (orientation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      orientation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, orientation, submessage_arena);
    }
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  orientation_ = orientation;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ImuData.orientation)
}

// -------------------------------------------------------------------

// RequestImu

// required string topic_name = 1;
inline bool RequestImu::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestImu::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestImu::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestImu::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& RequestImu::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
  return topic_name_.GetNoArena();
}
inline void RequestImu::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}
#if LANG_CXX11
inline void RequestImu::set_topic_name(::std::string&& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}
#endif
inline void RequestImu::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}
inline void RequestImu::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}
inline ::std::string* RequestImu::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestImu::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
  if (!has_topic_name()) {
    return NULL;
  }
  clear_has_topic_name();
  return topic_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestImu::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestImu.topic_name)
}

// -------------------------------------------------------------------

// SubscribeImage

// required string topic_name = 1;
inline bool SubscribeImage::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeImage::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeImage::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeImage::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& SubscribeImage::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
  return topic_name_.GetNoArena();
}
inline void SubscribeImage::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}
#if LANG_CXX11
inline void SubscribeImage::set_topic_name(::std::string&& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}
#endif
inline void SubscribeImage::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}
inline void SubscribeImage::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}
inline ::std::string* SubscribeImage::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscribeImage::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
  if (!has_topic_name()) {
    return NULL;
  }
  clear_has_topic_name();
  return topic_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeImage::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SubscribeImage.topic_name)
}

// -------------------------------------------------------------------

// SubscribeLaser

// required string topic_name = 1;
inline bool SubscribeLaser::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeLaser::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeLaser::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeLaser::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& SubscribeLaser::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
  return topic_name_.GetNoArena();
}
inline void SubscribeLaser::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}
#if LANG_CXX11
inline void SubscribeLaser::set_topic_name(::std::string&& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}
#endif
inline void SubscribeLaser::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}
inline void SubscribeLaser::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}
inline ::std::string* SubscribeLaser::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscribeLaser::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
  if (!has_topic_name()) {
    return NULL;
  }
  clear_has_topic_name();
  return topic_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeLaser::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SubscribeLaser.topic_name)
}

// -------------------------------------------------------------------

// SubscribeImu

// required string topic_name = 1;
inline bool SubscribeImu::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubscribeImu::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubscribeImu::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubscribeImu::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& SubscribeImu::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
  return topic_name_.GetNoArena();
}
inline void SubscribeImu::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}
#if LANG_CXX11
inline void SubscribeImu::set_topic_name(::std::string&& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}
#endif
inline void SubscribeImu::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}
inline void SubscribeImu::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}
inline ::std::string* SubscribeImu::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SubscribeImu::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
  if (!has_topic_name()) {
    return NULL;
  }
  clear_has_topic_name();
  return topic_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SubscribeImu::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SubscribeImu.topic_name)
}

// -------------------------------------------------------------------

// ApplyLinkWrench

// required string model_name = 1;
inline bool ApplyLinkWrench::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyLinkWrench::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyLinkWrench::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyLinkWrench::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& ApplyLinkWrench::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
  return model_name_.GetNoArena();
}
inline void ApplyLinkWrench::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}
#if LANG_CXX11
inline void ApplyLinkWrench::set_model_name(::std::string&& value) {
  set_has_model_name();
  model_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}
#endif
inline void ApplyLinkWrench::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}
inline void ApplyLinkWrench::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}
inline ::std::string* ApplyLinkWrench::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyLinkWrench::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
  if (!has_model_name()) {
    return NULL;
  }
  clear_has_model_name();
  return model_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.model_name)
}

// required string link_name = 2;
inline bool ApplyLinkWrench::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyLinkWrench::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyLinkWrench::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyLinkWrench::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& ApplyLinkWrench::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
  return link_name_.GetNoArena();
}
inline void ApplyLinkWrench::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}
#if LANG_CXX11
inline void ApplyLinkWrench::set_link_name(::std::string&& value) {
  set_has_link_name();
  link_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}
#endif
inline void ApplyLinkWrench::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}
inline void ApplyLinkWrench::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}
inline ::std::string* ApplyLinkWrench::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyLinkWrench::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
  if (!has_link_name()) {
    return NULL;
  }
  clear_has_link_name();
  return link_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.link_name)
}

// required string force_type = 3;
inline bool ApplyLinkWrench::has_force_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplyLinkWrench::set_has_force_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplyLinkWrench::clear_has_force_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplyLinkWrench::clear_force_type() {
  force_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_force_type();
}
inline const ::std::string& ApplyLinkWrench::force_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
  return force_type_.GetNoArena();
}
inline void ApplyLinkWrench::set_force_type(const ::std::string& value) {
  set_has_force_type();
  force_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}
#if LANG_CXX11
inline void ApplyLinkWrench::set_force_type(::std::string&& value) {
  set_has_force_type();
  force_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}
#endif
inline void ApplyLinkWrench::set_force_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_force_type();
  force_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}
inline void ApplyLinkWrench::set_force_type(const char* value, size_t size) {
  set_has_force_type();
  force_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}
inline ::std::string* ApplyLinkWrench::mutable_force_type() {
  set_has_force_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
  return force_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyLinkWrench::release_force_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
  if (!has_force_type()) {
    return NULL;
  }
  clear_has_force_type();
  return force_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_allocated_force_type(::std::string* force_type) {
  if (force_type != NULL) {
    set_has_force_type();
  } else {
    clear_has_force_type();
  }
  force_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), force_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.force_type)
}

// required double fx = 4;
inline bool ApplyLinkWrench::has_fx() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ApplyLinkWrench::set_has_fx() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ApplyLinkWrench::clear_has_fx() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ApplyLinkWrench::clear_fx() {
  fx_ = 0;
  clear_has_fx();
}
inline double ApplyLinkWrench::fx() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fx)
  return fx_;
}
inline void ApplyLinkWrench::set_fx(double value) {
  set_has_fx();
  fx_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fx)
}

// required double fy = 5;
inline bool ApplyLinkWrench::has_fy() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ApplyLinkWrench::set_has_fy() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ApplyLinkWrench::clear_has_fy() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ApplyLinkWrench::clear_fy() {
  fy_ = 0;
  clear_has_fy();
}
inline double ApplyLinkWrench::fy() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fy)
  return fy_;
}
inline void ApplyLinkWrench::set_fy(double value) {
  set_has_fy();
  fy_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fy)
}

// required double fz = 6;
inline bool ApplyLinkWrench::has_fz() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ApplyLinkWrench::set_has_fz() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ApplyLinkWrench::clear_has_fz() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ApplyLinkWrench::clear_fz() {
  fz_ = 0;
  clear_has_fz();
}
inline double ApplyLinkWrench::fz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fz)
  return fz_;
}
inline void ApplyLinkWrench::set_fz(double value) {
  set_has_fz();
  fz_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.fz)
}

// required string torque_type = 7;
inline bool ApplyLinkWrench::has_torque_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApplyLinkWrench::set_has_torque_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApplyLinkWrench::clear_has_torque_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApplyLinkWrench::clear_torque_type() {
  torque_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_torque_type();
}
inline const ::std::string& ApplyLinkWrench::torque_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
  return torque_type_.GetNoArena();
}
inline void ApplyLinkWrench::set_torque_type(const ::std::string& value) {
  set_has_torque_type();
  torque_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
#if LANG_CXX11
inline void ApplyLinkWrench::set_torque_type(::std::string&& value) {
  set_has_torque_type();
  torque_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
#endif
inline void ApplyLinkWrench::set_torque_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_torque_type();
  torque_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
inline void ApplyLinkWrench::set_torque_type(const char* value, size_t size) {
  set_has_torque_type();
  torque_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}
inline ::std::string* ApplyLinkWrench::mutable_torque_type() {
  set_has_torque_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
  return torque_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyLinkWrench::release_torque_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
  if (!has_torque_type()) {
    return NULL;
  }
  clear_has_torque_type();
  return torque_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyLinkWrench::set_allocated_torque_type(::std::string* torque_type) {
  if (torque_type != NULL) {
    set_has_torque_type();
  } else {
    clear_has_torque_type();
  }
  torque_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), torque_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.torque_type)
}

// required double tx = 8;
inline bool ApplyLinkWrench::has_tx() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ApplyLinkWrench::set_has_tx() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ApplyLinkWrench::clear_has_tx() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ApplyLinkWrench::clear_tx() {
  tx_ = 0;
  clear_has_tx();
}
inline double ApplyLinkWrench::tx() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.tx)
  return tx_;
}
inline void ApplyLinkWrench::set_tx(double value) {
  set_has_tx();
  tx_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.tx)
}

// required double ty = 9;
inline bool ApplyLinkWrench::has_ty() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ApplyLinkWrench::set_has_ty() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ApplyLinkWrench::clear_has_ty() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ApplyLinkWrench::clear_ty() {
  ty_ = 0;
  clear_has_ty();
}
inline double ApplyLinkWrench::ty() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.ty)
  return ty_;
}
inline void ApplyLinkWrench::set_ty(double value) {
  set_has_ty();
  ty_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.ty)
}

// required double tz = 10;
inline bool ApplyLinkWrench::has_tz() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ApplyLinkWrench::set_has_tz() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ApplyLinkWrench::clear_has_tz() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ApplyLinkWrench::clear_tz() {
  tz_ = 0;
  clear_has_tz();
}
inline double ApplyLinkWrench::tz() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.tz)
  return tz_;
}
inline void ApplyLinkWrench::set_tz(double value) {
  set_has_tz();
  tz_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyLinkWrench.tz)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 11;
inline bool ApplyLinkWrench::has_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ApplyLinkWrench::set_has_duration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ApplyLinkWrench::clear_has_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ApplyLinkWrench::clear_duration() {
  if (duration_ != NULL) duration_->Clear();
  clear_has_duration();
}
inline const ::mw::internal::robotics::gazebotransport::Time& ApplyLinkWrench::_internal_duration() const {
  return *duration_;
}
inline const ::mw::internal::robotics::gazebotransport::Time& ApplyLinkWrench::duration() const {
  const ::mw::internal::robotics::gazebotransport::Time* p = duration_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Time*>(
      &::mw::internal::robotics::gazebotransport::_Time_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Time* ApplyLinkWrench::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* ApplyLinkWrench::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(GetArenaNoVirtual());
    duration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
  return duration_;
}
inline void ApplyLinkWrench::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete duration_;
  }
  if (duration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      duration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    set_has_duration();
  } else {
    clear_has_duration();
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyLinkWrench.duration)
}

// -------------------------------------------------------------------

// ApplyJointTorque

// required string model_name = 1;
inline bool ApplyJointTorque::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplyJointTorque::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplyJointTorque::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplyJointTorque::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& ApplyJointTorque::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
  return model_name_.GetNoArena();
}
inline void ApplyJointTorque::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}
#if LANG_CXX11
inline void ApplyJointTorque::set_model_name(::std::string&& value) {
  set_has_model_name();
  model_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}
#endif
inline void ApplyJointTorque::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}
inline void ApplyJointTorque::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}
inline ::std::string* ApplyJointTorque::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyJointTorque::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
  if (!has_model_name()) {
    return NULL;
  }
  clear_has_model_name();
  return model_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyJointTorque::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyJointTorque.model_name)
}

// required string joint_name = 2;
inline bool ApplyJointTorque::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplyJointTorque::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplyJointTorque::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplyJointTorque::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
inline const ::std::string& ApplyJointTorque::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
  return joint_name_.GetNoArena();
}
inline void ApplyJointTorque::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}
#if LANG_CXX11
inline void ApplyJointTorque::set_joint_name(::std::string&& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}
#endif
inline void ApplyJointTorque::set_joint_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}
inline void ApplyJointTorque::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}
inline ::std::string* ApplyJointTorque::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ApplyJointTorque::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
  if (!has_joint_name()) {
    return NULL;
  }
  clear_has_joint_name();
  return joint_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ApplyJointTorque::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyJointTorque.joint_name)
}

// required uint32 index = 3;
inline bool ApplyJointTorque::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ApplyJointTorque::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ApplyJointTorque::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ApplyJointTorque::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 ApplyJointTorque::index() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.index)
  return index_;
}
inline void ApplyJointTorque::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyJointTorque.index)
}

// required double effort = 4;
inline bool ApplyJointTorque::has_effort() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApplyJointTorque::set_has_effort() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApplyJointTorque::clear_has_effort() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApplyJointTorque::clear_effort() {
  effort_ = 0;
  clear_has_effort();
}
inline double ApplyJointTorque::effort() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.effort)
  return effort_;
}
inline void ApplyJointTorque::set_effort(double value) {
  set_has_effort();
  effort_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ApplyJointTorque.effort)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 5;
inline bool ApplyJointTorque::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplyJointTorque::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplyJointTorque::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplyJointTorque::clear_duration() {
  if (duration_ != NULL) duration_->Clear();
  clear_has_duration();
}
inline const ::mw::internal::robotics::gazebotransport::Time& ApplyJointTorque::_internal_duration() const {
  return *duration_;
}
inline const ::mw::internal::robotics::gazebotransport::Time& ApplyJointTorque::duration() const {
  const ::mw::internal::robotics::gazebotransport::Time* p = duration_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Time*>(
      &::mw::internal::robotics::gazebotransport::_Time_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Time* ApplyJointTorque::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* ApplyJointTorque::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(GetArenaNoVirtual());
    duration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
  return duration_;
}
inline void ApplyJointTorque::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete duration_;
  }
  if (duration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      duration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    set_has_duration();
  } else {
    clear_has_duration();
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ApplyJointTorque.duration)
}

// -------------------------------------------------------------------

// GetPose

// required string model_name = 1;
inline bool GetPose::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPose::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPose::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPose::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& GetPose::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetPose.model_name)
  return model_name_.GetNoArena();
}
inline void GetPose::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetPose.model_name)
}
#if LANG_CXX11
inline void GetPose::set_model_name(::std::string&& value) {
  set_has_model_name();
  model_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetPose.model_name)
}
#endif
inline void GetPose::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetPose.model_name)
}
inline void GetPose::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetPose.model_name)
}
inline ::std::string* GetPose::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetPose.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetPose::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetPose.model_name)
  if (!has_model_name()) {
    return NULL;
  }
  clear_has_model_name();
  return model_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetPose::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetPose.model_name)
}

// -------------------------------------------------------------------

// GetTopicList

// required string topic_name = 1;
inline bool GetTopicList::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTopicList::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTopicList::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTopicList::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& GetTopicList::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
  return topic_name_.GetNoArena();
}
inline void GetTopicList::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}
#if LANG_CXX11
inline void GetTopicList::set_topic_name(::std::string&& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}
#endif
inline void GetTopicList::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}
inline void GetTopicList::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}
inline ::std::string* GetTopicList::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetTopicList::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
  if (!has_topic_name()) {
    return NULL;
  }
  clear_has_topic_name();
  return topic_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetTopicList::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetTopicList.topic_name)
}

// -------------------------------------------------------------------

// TopicList_TopicInfo

// required string name = 1;
inline bool TopicList_TopicInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopicList_TopicInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopicList_TopicInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopicList_TopicInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TopicList_TopicInfo::name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
  return name_.GetNoArena();
}
inline void TopicList_TopicInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}
#if LANG_CXX11
inline void TopicList_TopicInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}
#endif
inline void TopicList_TopicInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}
inline void TopicList_TopicInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}
inline ::std::string* TopicList_TopicInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicList_TopicInfo::release_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicList_TopicInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.name)
}

// required string type = 2;
inline bool TopicList_TopicInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopicList_TopicInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopicList_TopicInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopicList_TopicInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& TopicList_TopicInfo::type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
  return type_.GetNoArena();
}
inline void TopicList_TopicInfo::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}
#if LANG_CXX11
inline void TopicList_TopicInfo::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}
#endif
inline void TopicList_TopicInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}
inline void TopicList_TopicInfo::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}
inline ::std::string* TopicList_TopicInfo::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopicList_TopicInfo::release_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopicList_TopicInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.TopicList.TopicInfo.type)
}

// -------------------------------------------------------------------

// TopicList

// repeated .mw.internal.robotics.gazebotransport.TopicList.TopicInfo data = 1;
inline int TopicList::data_size() const {
  return data_.size();
}
inline void TopicList::clear_data() {
  data_.Clear();
}
inline ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* TopicList::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TopicList.data)
  return data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo >*
TopicList::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TopicList.data)
  return &data_;
}
inline const ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo& TopicList::data(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TopicList.data)
  return data_.Get(index);
}
inline ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo* TopicList::add_data() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TopicList.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TopicList_TopicInfo >&
TopicList::data() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TopicList.data)
  return data_;
}

// -------------------------------------------------------------------

// GetModelInfo

// required string topic_name = 1;
inline bool GetModelInfo::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetModelInfo::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetModelInfo::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetModelInfo::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& GetModelInfo::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
  return topic_name_.GetNoArena();
}
inline void GetModelInfo::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}
#if LANG_CXX11
inline void GetModelInfo::set_topic_name(::std::string&& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}
#endif
inline void GetModelInfo::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}
inline void GetModelInfo::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}
inline ::std::string* GetModelInfo::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetModelInfo::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
  if (!has_topic_name()) {
    return NULL;
  }
  clear_has_topic_name();
  return topic_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetModelInfo::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetModelInfo.topic_name)
}

// -------------------------------------------------------------------

// ModelInfo_LINKS

// repeated string link_name = 1;
inline int ModelInfo_LINKS::link_name_size() const {
  return link_name_.size();
}
inline void ModelInfo_LINKS::clear_link_name() {
  link_name_.Clear();
}
inline const ::std::string& ModelInfo_LINKS::link_name(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_.Get(index);
}
inline ::std::string* ModelInfo_LINKS::mutable_link_name(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_.Mutable(index);
}
inline void ModelInfo_LINKS::set_link_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  link_name_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ModelInfo_LINKS::set_link_name(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  link_name_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ModelInfo_LINKS::set_link_name(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  link_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline void ModelInfo_LINKS::set_link_name(int index, const char* value, size_t size) {
  link_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline ::std::string* ModelInfo_LINKS::add_link_name() {
  // @@protoc_insertion_point(field_add_mutable:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_.Add();
}
inline void ModelInfo_LINKS::add_link_name(const ::std::string& value) {
  link_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
#if LANG_CXX11
inline void ModelInfo_LINKS::add_link_name(::std::string&& value) {
  link_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
#endif
inline void ModelInfo_LINKS::add_link_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  link_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline void ModelInfo_LINKS::add_link_name(const char* value, size_t size) {
  link_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelInfo_LINKS::link_name() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return link_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelInfo_LINKS::mutable_link_name() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.ModelInfo.LINKS.link_name)
  return &link_name_;
}

// -------------------------------------------------------------------

// ModelInfo_JOINTS

// repeated string joint_name = 1;
inline int ModelInfo_JOINTS::joint_name_size() const {
  return joint_name_.size();
}
inline void ModelInfo_JOINTS::clear_joint_name() {
  joint_name_.Clear();
}
inline const ::std::string& ModelInfo_JOINTS::joint_name(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_.Get(index);
}
inline ::std::string* ModelInfo_JOINTS::mutable_joint_name(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_.Mutable(index);
}
inline void ModelInfo_JOINTS::set_joint_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  joint_name_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ModelInfo_JOINTS::set_joint_name(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  joint_name_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ModelInfo_JOINTS::set_joint_name(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  joint_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline void ModelInfo_JOINTS::set_joint_name(int index, const char* value, size_t size) {
  joint_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline ::std::string* ModelInfo_JOINTS::add_joint_name() {
  // @@protoc_insertion_point(field_add_mutable:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_.Add();
}
inline void ModelInfo_JOINTS::add_joint_name(const ::std::string& value) {
  joint_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
#if LANG_CXX11
inline void ModelInfo_JOINTS::add_joint_name(::std::string&& value) {
  joint_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
#endif
inline void ModelInfo_JOINTS::add_joint_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  joint_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline void ModelInfo_JOINTS::add_joint_name(const char* value, size_t size) {
  joint_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ModelInfo_JOINTS::joint_name() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return joint_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ModelInfo_JOINTS::mutable_joint_name() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.ModelInfo.JOINTS.joint_name)
  return &joint_name_;
}

// -------------------------------------------------------------------

// ModelInfo_Model

// required string model_name = 1;
inline bool ModelInfo_Model::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelInfo_Model::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelInfo_Model::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelInfo_Model::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& ModelInfo_Model::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
  return model_name_.GetNoArena();
}
inline void ModelInfo_Model::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}
#if LANG_CXX11
inline void ModelInfo_Model::set_model_name(::std::string&& value) {
  set_has_model_name();
  model_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}
#endif
inline void ModelInfo_Model::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}
inline void ModelInfo_Model::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}
inline ::std::string* ModelInfo_Model::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ModelInfo_Model::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
  if (!has_model_name()) {
    return NULL;
  }
  clear_has_model_name();
  return model_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ModelInfo_Model::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ModelInfo.Model.model_name)
}

// optional .mw.internal.robotics.gazebotransport.ModelInfo.LINKS links = 2;
inline bool ModelInfo_Model::has_links() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModelInfo_Model::set_has_links() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModelInfo_Model::clear_has_links() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModelInfo_Model::clear_links() {
  if (links_ != NULL) links_->Clear();
  clear_has_links();
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS& ModelInfo_Model::_internal_links() const {
  return *links_;
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS& ModelInfo_Model::links() const {
  const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* p = links_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS*>(
      &::mw::internal::robotics::gazebotransport::_ModelInfo_LINKS_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* ModelInfo_Model::release_links() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
  clear_has_links();
  ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* temp = links_;
  links_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* ModelInfo_Model::mutable_links() {
  set_has_links();
  if (links_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ModelInfo_LINKS>(GetArenaNoVirtual());
    links_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
  return links_;
}
inline void ModelInfo_Model::set_allocated_links(::mw::internal::robotics::gazebotransport::ModelInfo_LINKS* links) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete links_;
  }
  if (links) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      links = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, links, submessage_arena);
    }
    set_has_links();
  } else {
    clear_has_links();
  }
  links_ = links;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ModelInfo.Model.links)
}

// optional .mw.internal.robotics.gazebotransport.ModelInfo.JOINTS joints = 3;
inline bool ModelInfo_Model::has_joints() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModelInfo_Model::set_has_joints() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModelInfo_Model::clear_has_joints() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModelInfo_Model::clear_joints() {
  if (joints_ != NULL) joints_->Clear();
  clear_has_joints();
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS& ModelInfo_Model::_internal_joints() const {
  return *joints_;
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS& ModelInfo_Model::joints() const {
  const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* p = joints_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS*>(
      &::mw::internal::robotics::gazebotransport::_ModelInfo_JOINTS_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* ModelInfo_Model::release_joints() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
  clear_has_joints();
  ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* temp = joints_;
  joints_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* ModelInfo_Model::mutable_joints() {
  set_has_joints();
  if (joints_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS>(GetArenaNoVirtual());
    joints_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
  return joints_;
}
inline void ModelInfo_Model::set_allocated_joints(::mw::internal::robotics::gazebotransport::ModelInfo_JOINTS* joints) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete joints_;
  }
  if (joints) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      joints = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, joints, submessage_arena);
    }
    set_has_joints();
  } else {
    clear_has_joints();
  }
  joints_ = joints;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.ModelInfo.Model.joints)
}

// -------------------------------------------------------------------

// ModelInfo

// repeated .mw.internal.robotics.gazebotransport.ModelInfo.Model model_data = 1;
inline int ModelInfo::model_data_size() const {
  return model_data_.size();
}
inline void ModelInfo::clear_model_data() {
  model_data_.Clear();
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_Model* ModelInfo::mutable_model_data(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return model_data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model >*
ModelInfo::mutable_model_data() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return &model_data_;
}
inline const ::mw::internal::robotics::gazebotransport::ModelInfo_Model& ModelInfo::model_data(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return model_data_.Get(index);
}
inline ::mw::internal::robotics::gazebotransport::ModelInfo_Model* ModelInfo::add_model_data() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return model_data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::ModelInfo_Model >&
ModelInfo::model_data() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.ModelInfo.model_data)
  return model_data_;
}

// -------------------------------------------------------------------

// MaxStepSize

// required .mw.internal.robotics.gazebotransport.MaxStepSize.TYPE type = 1;
inline bool MaxStepSize::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MaxStepSize::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MaxStepSize::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MaxStepSize::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE MaxStepSize::type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.MaxStepSize.type)
  return static_cast< ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE >(type_);
}
inline void MaxStepSize::set_type(::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE value) {
  assert(::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.MaxStepSize.type)
}

// required double size = 2;
inline bool MaxStepSize::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MaxStepSize::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MaxStepSize::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MaxStepSize::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline double MaxStepSize::size() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.MaxStepSize.size)
  return size_;
}
inline void MaxStepSize::set_size(double value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.MaxStepSize.size)
}

// -------------------------------------------------------------------

// InitCustomPublisher

// required string topic_name = 1;
inline bool InitCustomPublisher::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitCustomPublisher::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitCustomPublisher::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitCustomPublisher::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& InitCustomPublisher::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
  return topic_name_.GetNoArena();
}
inline void InitCustomPublisher::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}
#if LANG_CXX11
inline void InitCustomPublisher::set_topic_name(::std::string&& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}
#endif
inline void InitCustomPublisher::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}
inline void InitCustomPublisher::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}
inline ::std::string* InitCustomPublisher::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitCustomPublisher::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
  if (!has_topic_name()) {
    return NULL;
  }
  clear_has_topic_name();
  return topic_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitCustomPublisher::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.InitCustomPublisher.topic_name)
}

// required string message_type = 2;
inline bool InitCustomPublisher::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitCustomPublisher::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitCustomPublisher::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitCustomPublisher::clear_message_type() {
  message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_type();
}
inline const ::std::string& InitCustomPublisher::message_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
  return message_type_.GetNoArena();
}
inline void InitCustomPublisher::set_message_type(const ::std::string& value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}
#if LANG_CXX11
inline void InitCustomPublisher::set_message_type(::std::string&& value) {
  set_has_message_type();
  message_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}
#endif
inline void InitCustomPublisher::set_message_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}
inline void InitCustomPublisher::set_message_type(const char* value, size_t size) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}
inline ::std::string* InitCustomPublisher::mutable_message_type() {
  set_has_message_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
  return message_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitCustomPublisher::release_message_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
  if (!has_message_type()) {
    return NULL;
  }
  clear_has_message_type();
  return message_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitCustomPublisher::set_allocated_message_type(::std::string* message_type) {
  if (message_type != NULL) {
    set_has_message_type();
  } else {
    clear_has_message_type();
  }
  message_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.InitCustomPublisher.message_type)
}

// -------------------------------------------------------------------

// InitCustomSubscriber

// required string topic_name = 1;
inline bool InitCustomSubscriber::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InitCustomSubscriber::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InitCustomSubscriber::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InitCustomSubscriber::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& InitCustomSubscriber::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
  return topic_name_.GetNoArena();
}
inline void InitCustomSubscriber::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}
#if LANG_CXX11
inline void InitCustomSubscriber::set_topic_name(::std::string&& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}
#endif
inline void InitCustomSubscriber::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}
inline void InitCustomSubscriber::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}
inline ::std::string* InitCustomSubscriber::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitCustomSubscriber::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
  if (!has_topic_name()) {
    return NULL;
  }
  clear_has_topic_name();
  return topic_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitCustomSubscriber::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.InitCustomSubscriber.topic_name)
}

// required string message_type = 2;
inline bool InitCustomSubscriber::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InitCustomSubscriber::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InitCustomSubscriber::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InitCustomSubscriber::clear_message_type() {
  message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_type();
}
inline const ::std::string& InitCustomSubscriber::message_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
  return message_type_.GetNoArena();
}
inline void InitCustomSubscriber::set_message_type(const ::std::string& value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}
#if LANG_CXX11
inline void InitCustomSubscriber::set_message_type(::std::string&& value) {
  set_has_message_type();
  message_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}
#endif
inline void InitCustomSubscriber::set_message_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}
inline void InitCustomSubscriber::set_message_type(const char* value, size_t size) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}
inline ::std::string* InitCustomSubscriber::mutable_message_type() {
  set_has_message_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
  return message_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InitCustomSubscriber::release_message_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
  if (!has_message_type()) {
    return NULL;
  }
  clear_has_message_type();
  return message_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InitCustomSubscriber::set_allocated_message_type(::std::string* message_type) {
  if (message_type != NULL) {
    set_has_message_type();
  } else {
    clear_has_message_type();
  }
  message_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.InitCustomSubscriber.message_type)
}

// -------------------------------------------------------------------

// CustomMessageSupport

// required string topic_name = 1;
inline bool CustomMessageSupport::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CustomMessageSupport::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CustomMessageSupport::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CustomMessageSupport::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& CustomMessageSupport::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
  return topic_name_.GetNoArena();
}
inline void CustomMessageSupport::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}
#if LANG_CXX11
inline void CustomMessageSupport::set_topic_name(::std::string&& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}
#endif
inline void CustomMessageSupport::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}
inline void CustomMessageSupport::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}
inline ::std::string* CustomMessageSupport::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CustomMessageSupport::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
  if (!has_topic_name()) {
    return NULL;
  }
  clear_has_topic_name();
  return topic_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomMessageSupport::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.CustomMessageSupport.topic_name)
}

// required string message_type = 2;
inline bool CustomMessageSupport::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CustomMessageSupport::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CustomMessageSupport::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CustomMessageSupport::clear_message_type() {
  message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_type();
}
inline const ::std::string& CustomMessageSupport::message_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
  return message_type_.GetNoArena();
}
inline void CustomMessageSupport::set_message_type(const ::std::string& value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}
#if LANG_CXX11
inline void CustomMessageSupport::set_message_type(::std::string&& value) {
  set_has_message_type();
  message_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}
#endif
inline void CustomMessageSupport::set_message_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}
inline void CustomMessageSupport::set_message_type(const char* value, size_t size) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}
inline ::std::string* CustomMessageSupport::mutable_message_type() {
  set_has_message_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
  return message_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CustomMessageSupport::release_message_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
  if (!has_message_type()) {
    return NULL;
  }
  clear_has_message_type();
  return message_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomMessageSupport::set_allocated_message_type(::std::string* message_type) {
  if (message_type != NULL) {
    set_has_message_type();
  } else {
    clear_has_message_type();
  }
  message_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.CustomMessageSupport.message_type)
}

// required bytes data = 3;
inline bool CustomMessageSupport::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CustomMessageSupport::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CustomMessageSupport::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CustomMessageSupport::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& CustomMessageSupport::data() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
  return data_.GetNoArena();
}
inline void CustomMessageSupport::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}
#if LANG_CXX11
inline void CustomMessageSupport::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}
#endif
inline void CustomMessageSupport::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}
inline void CustomMessageSupport::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}
inline ::std::string* CustomMessageSupport::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CustomMessageSupport::release_data() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
  if (!has_data()) {
    return NULL;
  }
  clear_has_data();
  return data_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CustomMessageSupport::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.CustomMessageSupport.data)
}

// optional bool is_new = 4;
inline bool CustomMessageSupport::has_is_new() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CustomMessageSupport::set_has_is_new() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CustomMessageSupport::clear_has_is_new() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CustomMessageSupport::clear_is_new() {
  is_new_ = false;
  clear_has_is_new();
}
inline bool CustomMessageSupport::is_new() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.CustomMessageSupport.is_new)
  return is_new_;
}
inline void CustomMessageSupport::set_is_new(bool value) {
  set_has_is_new();
  is_new_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.CustomMessageSupport.is_new)
}

// -------------------------------------------------------------------

// RequestCustomMessageSupport

// required string topic_name = 1;
inline bool RequestCustomMessageSupport::has_topic_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestCustomMessageSupport::set_has_topic_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestCustomMessageSupport::clear_has_topic_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestCustomMessageSupport::clear_topic_name() {
  topic_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_topic_name();
}
inline const ::std::string& RequestCustomMessageSupport::topic_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
  return topic_name_.GetNoArena();
}
inline void RequestCustomMessageSupport::set_topic_name(const ::std::string& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}
#if LANG_CXX11
inline void RequestCustomMessageSupport::set_topic_name(::std::string&& value) {
  set_has_topic_name();
  topic_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}
#endif
inline void RequestCustomMessageSupport::set_topic_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}
inline void RequestCustomMessageSupport::set_topic_name(const char* value, size_t size) {
  set_has_topic_name();
  topic_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}
inline ::std::string* RequestCustomMessageSupport::mutable_topic_name() {
  set_has_topic_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
  return topic_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestCustomMessageSupport::release_topic_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
  if (!has_topic_name()) {
    return NULL;
  }
  clear_has_topic_name();
  return topic_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestCustomMessageSupport::set_allocated_topic_name(::std::string* topic_name) {
  if (topic_name != NULL) {
    set_has_topic_name();
  } else {
    clear_has_topic_name();
  }
  topic_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), topic_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.topic_name)
}

// required string message_type = 2;
inline bool RequestCustomMessageSupport::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestCustomMessageSupport::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestCustomMessageSupport::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestCustomMessageSupport::clear_message_type() {
  message_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message_type();
}
inline const ::std::string& RequestCustomMessageSupport::message_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
  return message_type_.GetNoArena();
}
inline void RequestCustomMessageSupport::set_message_type(const ::std::string& value) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}
#if LANG_CXX11
inline void RequestCustomMessageSupport::set_message_type(::std::string&& value) {
  set_has_message_type();
  message_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}
#endif
inline void RequestCustomMessageSupport::set_message_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}
inline void RequestCustomMessageSupport::set_message_type(const char* value, size_t size) {
  set_has_message_type();
  message_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}
inline ::std::string* RequestCustomMessageSupport::mutable_message_type() {
  set_has_message_type();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
  return message_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestCustomMessageSupport::release_message_type() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
  if (!has_message_type()) {
    return NULL;
  }
  clear_has_message_type();
  return message_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestCustomMessageSupport::set_allocated_message_type(::std::string* message_type) {
  if (message_type != NULL) {
    set_has_message_type();
  } else {
    clear_has_message_type();
  }
  message_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message_type);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.RequestCustomMessageSupport.message_type)
}

// -------------------------------------------------------------------

// SetJointPosition

// required string model_name = 1;
inline bool SetJointPosition::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetJointPosition::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetJointPosition::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetJointPosition::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& SetJointPosition::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
  return model_name_.GetNoArena();
}
inline void SetJointPosition::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}
#if LANG_CXX11
inline void SetJointPosition::set_model_name(::std::string&& value) {
  set_has_model_name();
  model_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}
#endif
inline void SetJointPosition::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}
inline void SetJointPosition::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}
inline ::std::string* SetJointPosition::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetJointPosition::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
  if (!has_model_name()) {
    return NULL;
  }
  clear_has_model_name();
  return model_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetJointPosition::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointPosition.model_name)
}

// required string joint_name = 2;
inline bool SetJointPosition::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetJointPosition::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetJointPosition::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetJointPosition::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
inline const ::std::string& SetJointPosition::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
  return joint_name_.GetNoArena();
}
inline void SetJointPosition::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}
#if LANG_CXX11
inline void SetJointPosition::set_joint_name(::std::string&& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}
#endif
inline void SetJointPosition::set_joint_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}
inline void SetJointPosition::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}
inline ::std::string* SetJointPosition::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetJointPosition::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
  if (!has_joint_name()) {
    return NULL;
  }
  clear_has_joint_name();
  return joint_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetJointPosition::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointPosition.joint_name)
}

// required uint32 index = 3;
inline bool SetJointPosition::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SetJointPosition::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SetJointPosition::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SetJointPosition::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 SetJointPosition::index() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.index)
  return index_;
}
inline void SetJointPosition::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointPosition.index)
}

// required double position = 4;
inline bool SetJointPosition::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetJointPosition::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetJointPosition::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetJointPosition::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline double SetJointPosition::position() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.position)
  return position_;
}
inline void SetJointPosition::set_position(double value) {
  set_has_position();
  position_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointPosition.position)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 5;
inline bool SetJointPosition::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetJointPosition::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetJointPosition::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetJointPosition::clear_duration() {
  if (duration_ != NULL) duration_->Clear();
  clear_has_duration();
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetJointPosition::_internal_duration() const {
  return *duration_;
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetJointPosition::duration() const {
  const ::mw::internal::robotics::gazebotransport::Time* p = duration_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Time*>(
      &::mw::internal::robotics::gazebotransport::_Time_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Time* SetJointPosition::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetJointPosition::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(GetArenaNoVirtual());
    duration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
  return duration_;
}
inline void SetJointPosition::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete duration_;
  }
  if (duration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      duration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    set_has_duration();
  } else {
    clear_has_duration();
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointPosition.duration)
}

// -------------------------------------------------------------------

// SetJointVelocity

// required string model_name = 1;
inline bool SetJointVelocity::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetJointVelocity::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetJointVelocity::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetJointVelocity::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& SetJointVelocity::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
  return model_name_.GetNoArena();
}
inline void SetJointVelocity::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}
#if LANG_CXX11
inline void SetJointVelocity::set_model_name(::std::string&& value) {
  set_has_model_name();
  model_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}
#endif
inline void SetJointVelocity::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}
inline void SetJointVelocity::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}
inline ::std::string* SetJointVelocity::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetJointVelocity::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
  if (!has_model_name()) {
    return NULL;
  }
  clear_has_model_name();
  return model_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetJointVelocity::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointVelocity.model_name)
}

// required string joint_name = 2;
inline bool SetJointVelocity::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetJointVelocity::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetJointVelocity::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetJointVelocity::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
inline const ::std::string& SetJointVelocity::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
  return joint_name_.GetNoArena();
}
inline void SetJointVelocity::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}
#if LANG_CXX11
inline void SetJointVelocity::set_joint_name(::std::string&& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}
#endif
inline void SetJointVelocity::set_joint_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}
inline void SetJointVelocity::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}
inline ::std::string* SetJointVelocity::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetJointVelocity::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
  if (!has_joint_name()) {
    return NULL;
  }
  clear_has_joint_name();
  return joint_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetJointVelocity::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointVelocity.joint_name)
}

// required uint32 index = 3;
inline bool SetJointVelocity::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SetJointVelocity::set_has_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SetJointVelocity::clear_has_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SetJointVelocity::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 SetJointVelocity::index() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.index)
  return index_;
}
inline void SetJointVelocity::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointVelocity.index)
}

// required double velocity = 4;
inline bool SetJointVelocity::has_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetJointVelocity::set_has_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetJointVelocity::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetJointVelocity::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline double SetJointVelocity::velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.velocity)
  return velocity_;
}
inline void SetJointVelocity::set_velocity(double value) {
  set_has_velocity();
  velocity_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetJointVelocity.velocity)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 5;
inline bool SetJointVelocity::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetJointVelocity::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetJointVelocity::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetJointVelocity::clear_duration() {
  if (duration_ != NULL) duration_->Clear();
  clear_has_duration();
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetJointVelocity::_internal_duration() const {
  return *duration_;
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetJointVelocity::duration() const {
  const ::mw::internal::robotics::gazebotransport::Time* p = duration_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Time*>(
      &::mw::internal::robotics::gazebotransport::_Time_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Time* SetJointVelocity::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetJointVelocity::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(GetArenaNoVirtual());
    duration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
  return duration_;
}
inline void SetJointVelocity::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete duration_;
  }
  if (duration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      duration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    set_has_duration();
  } else {
    clear_has_duration();
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetJointVelocity.duration)
}

// -------------------------------------------------------------------

// GetJointState

// required string model_name = 1;
inline bool GetJointState::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetJointState::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetJointState::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetJointState::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& GetJointState::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetJointState.model_name)
  return model_name_.GetNoArena();
}
inline void GetJointState::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}
#if LANG_CXX11
inline void GetJointState::set_model_name(::std::string&& value) {
  set_has_model_name();
  model_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}
#endif
inline void GetJointState::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}
inline void GetJointState::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}
inline ::std::string* GetJointState::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetJointState.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetJointState::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetJointState.model_name)
  if (!has_model_name()) {
    return NULL;
  }
  clear_has_model_name();
  return model_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetJointState::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetJointState.model_name)
}

// required string joint_name = 2;
inline bool GetJointState::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetJointState::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetJointState::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetJointState::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
inline const ::std::string& GetJointState::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
  return joint_name_.GetNoArena();
}
inline void GetJointState::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}
#if LANG_CXX11
inline void GetJointState::set_joint_name(::std::string&& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}
#endif
inline void GetJointState::set_joint_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}
inline void GetJointState::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}
inline ::std::string* GetJointState::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetJointState::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
  if (!has_joint_name()) {
    return NULL;
  }
  clear_has_joint_name();
  return joint_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetJointState::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetJointState.joint_name)
}

// -------------------------------------------------------------------

// Axis

// required .mw.internal.robotics.gazebotransport.Point xyz = 1;
inline bool Axis::has_xyz() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Axis::set_has_xyz() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Axis::clear_has_xyz() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Axis::clear_xyz() {
  if (xyz_ != NULL) xyz_->Clear();
  clear_has_xyz();
}
inline const ::mw::internal::robotics::gazebotransport::Point& Axis::_internal_xyz() const {
  return *xyz_;
}
inline const ::mw::internal::robotics::gazebotransport::Point& Axis::xyz() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = xyz_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.xyz)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Point* Axis::release_xyz() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.Axis.xyz)
  clear_has_xyz();
  ::mw::internal::robotics::gazebotransport::Point* temp = xyz_;
  xyz_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* Axis::mutable_xyz() {
  set_has_xyz();
  if (xyz_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArenaNoVirtual());
    xyz_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.Axis.xyz)
  return xyz_;
}
inline void Axis::set_allocated_xyz(::mw::internal::robotics::gazebotransport::Point* xyz) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete xyz_;
  }
  if (xyz) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      xyz = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, xyz, submessage_arena);
    }
    set_has_xyz();
  } else {
    clear_has_xyz();
  }
  xyz_ = xyz;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.Axis.xyz)
}

// required double limit_lower = 2;
inline bool Axis::has_limit_lower() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Axis::set_has_limit_lower() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Axis::clear_has_limit_lower() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Axis::clear_limit_lower() {
  limit_lower_ = 0;
  clear_has_limit_lower();
}
inline double Axis::limit_lower() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.limit_lower)
  return limit_lower_;
}
inline void Axis::set_limit_lower(double value) {
  set_has_limit_lower();
  limit_lower_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.limit_lower)
}

// required double limit_upper = 3;
inline bool Axis::has_limit_upper() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Axis::set_has_limit_upper() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Axis::clear_has_limit_upper() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Axis::clear_limit_upper() {
  limit_upper_ = 0;
  clear_has_limit_upper();
}
inline double Axis::limit_upper() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.limit_upper)
  return limit_upper_;
}
inline void Axis::set_limit_upper(double value) {
  set_has_limit_upper();
  limit_upper_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.limit_upper)
}

// required double limit_effort = 4;
inline bool Axis::has_limit_effort() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Axis::set_has_limit_effort() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Axis::clear_has_limit_effort() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Axis::clear_limit_effort() {
  limit_effort_ = 0;
  clear_has_limit_effort();
}
inline double Axis::limit_effort() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.limit_effort)
  return limit_effort_;
}
inline void Axis::set_limit_effort(double value) {
  set_has_limit_effort();
  limit_effort_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.limit_effort)
}

// required double limit_velocity = 5;
inline bool Axis::has_limit_velocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Axis::set_has_limit_velocity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Axis::clear_has_limit_velocity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Axis::clear_limit_velocity() {
  limit_velocity_ = 0;
  clear_has_limit_velocity();
}
inline double Axis::limit_velocity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.limit_velocity)
  return limit_velocity_;
}
inline void Axis::set_limit_velocity(double value) {
  set_has_limit_velocity();
  limit_velocity_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.limit_velocity)
}

// required double damping = 6;
inline bool Axis::has_damping() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Axis::set_has_damping() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Axis::clear_has_damping() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Axis::clear_damping() {
  damping_ = 0;
  clear_has_damping();
}
inline double Axis::damping() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.damping)
  return damping_;
}
inline void Axis::set_damping(double value) {
  set_has_damping();
  damping_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.damping)
}

// required double friction = 7;
inline bool Axis::has_friction() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Axis::set_has_friction() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Axis::clear_has_friction() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Axis::clear_friction() {
  friction_ = 0;
  clear_has_friction();
}
inline double Axis::friction() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.friction)
  return friction_;
}
inline void Axis::set_friction(double value) {
  set_has_friction();
  friction_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.friction)
}

// required bool use_parent_model_frame = 8;
inline bool Axis::has_use_parent_model_frame() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Axis::set_has_use_parent_model_frame() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Axis::clear_has_use_parent_model_frame() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Axis::clear_use_parent_model_frame() {
  use_parent_model_frame_ = false;
  clear_has_use_parent_model_frame();
}
inline bool Axis::use_parent_model_frame() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.Axis.use_parent_model_frame)
  return use_parent_model_frame_;
}
inline void Axis::set_use_parent_model_frame(bool value) {
  set_has_use_parent_model_frame();
  use_parent_model_frame_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.Axis.use_parent_model_frame)
}

// -------------------------------------------------------------------

// JointState

// required string model_name = 1;
inline bool JointState::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void JointState::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void JointState::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void JointState::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& JointState::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.model_name)
  return model_name_.GetNoArena();
}
inline void JointState::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.model_name)
}
#if LANG_CXX11
inline void JointState::set_model_name(::std::string&& value) {
  set_has_model_name();
  model_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.JointState.model_name)
}
#endif
inline void JointState::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.JointState.model_name)
}
inline void JointState::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.JointState.model_name)
}
inline ::std::string* JointState::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JointState::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.model_name)
  if (!has_model_name()) {
    return NULL;
  }
  clear_has_model_name();
  return model_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JointState::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.model_name)
}

// required string joint_name = 2;
inline bool JointState::has_joint_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void JointState::set_has_joint_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void JointState::clear_has_joint_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void JointState::clear_joint_name() {
  joint_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_joint_name();
}
inline const ::std::string& JointState::joint_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_name)
  return joint_name_.GetNoArena();
}
inline void JointState::set_joint_name(const ::std::string& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_name)
}
#if LANG_CXX11
inline void JointState::set_joint_name(::std::string&& value) {
  set_has_joint_name();
  joint_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.JointState.joint_name)
}
#endif
inline void JointState::set_joint_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.JointState.joint_name)
}
inline void JointState::set_joint_name(const char* value, size_t size) {
  set_has_joint_name();
  joint_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.JointState.joint_name)
}
inline ::std::string* JointState::mutable_joint_name() {
  set_has_joint_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.joint_name)
  return joint_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JointState::release_joint_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.joint_name)
  if (!has_joint_name()) {
    return NULL;
  }
  clear_has_joint_name();
  return joint_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JointState::set_allocated_joint_name(::std::string* joint_name) {
  if (joint_name != NULL) {
    set_has_joint_name();
  } else {
    clear_has_joint_name();
  }
  joint_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), joint_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.joint_name)
}

// required uint32 joint_id = 3;
inline bool JointState::has_joint_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void JointState::set_has_joint_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void JointState::clear_has_joint_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void JointState::clear_joint_id() {
  joint_id_ = 0u;
  clear_has_joint_id();
}
inline ::google::protobuf::uint32 JointState::joint_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_id)
  return joint_id_;
}
inline void JointState::set_joint_id(::google::protobuf::uint32 value) {
  set_has_joint_id();
  joint_id_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_id)
}

// repeated double joint_position = 4;
inline int JointState::joint_position_size() const {
  return joint_position_.size();
}
inline void JointState::clear_joint_position() {
  joint_position_.Clear();
}
inline double JointState::joint_position(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_position)
  return joint_position_.Get(index);
}
inline void JointState::set_joint_position(int index, double value) {
  joint_position_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_position)
}
inline void JointState::add_joint_position(double value) {
  joint_position_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.JointState.joint_position)
}
inline const ::google::protobuf::RepeatedField< double >&
JointState::joint_position() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.JointState.joint_position)
  return joint_position_;
}
inline ::google::protobuf::RepeatedField< double >*
JointState::mutable_joint_position() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.JointState.joint_position)
  return &joint_position_;
}

// repeated double joint_velocity = 5;
inline int JointState::joint_velocity_size() const {
  return joint_velocity_.size();
}
inline void JointState::clear_joint_velocity() {
  joint_velocity_.Clear();
}
inline double JointState::joint_velocity(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
  return joint_velocity_.Get(index);
}
inline void JointState::set_joint_velocity(int index, double value) {
  joint_velocity_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
}
inline void JointState::add_joint_velocity(double value) {
  joint_velocity_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
}
inline const ::google::protobuf::RepeatedField< double >&
JointState::joint_velocity() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
  return joint_velocity_;
}
inline ::google::protobuf::RepeatedField< double >*
JointState::mutable_joint_velocity() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.JointState.joint_velocity)
  return &joint_velocity_;
}

// optional .mw.internal.robotics.gazebotransport.JointState.Joint_Type joint_type = 6;
inline bool JointState::has_joint_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void JointState::set_has_joint_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void JointState::clear_has_joint_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void JointState::clear_joint_type() {
  joint_type_ = 1;
  clear_has_joint_type();
}
inline ::mw::internal::robotics::gazebotransport::JointState_Joint_Type JointState::joint_type() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.joint_type)
  return static_cast< ::mw::internal::robotics::gazebotransport::JointState_Joint_Type >(joint_type_);
}
inline void JointState::set_joint_type(::mw::internal::robotics::gazebotransport::JointState_Joint_Type value) {
  assert(::mw::internal::robotics::gazebotransport::JointState_Joint_Type_IsValid(value));
  set_has_joint_type();
  joint_type_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.joint_type)
}

// optional string parent_name = 7;
inline bool JointState::has_parent_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void JointState::set_has_parent_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void JointState::clear_has_parent_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void JointState::clear_parent_name() {
  parent_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parent_name();
}
inline const ::std::string& JointState::parent_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.parent_name)
  return parent_name_.GetNoArena();
}
inline void JointState::set_parent_name(const ::std::string& value) {
  set_has_parent_name();
  parent_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.parent_name)
}
#if LANG_CXX11
inline void JointState::set_parent_name(::std::string&& value) {
  set_has_parent_name();
  parent_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.JointState.parent_name)
}
#endif
inline void JointState::set_parent_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_parent_name();
  parent_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.JointState.parent_name)
}
inline void JointState::set_parent_name(const char* value, size_t size) {
  set_has_parent_name();
  parent_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.JointState.parent_name)
}
inline ::std::string* JointState::mutable_parent_name() {
  set_has_parent_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.parent_name)
  return parent_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JointState::release_parent_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.parent_name)
  if (!has_parent_name()) {
    return NULL;
  }
  clear_has_parent_name();
  return parent_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JointState::set_allocated_parent_name(::std::string* parent_name) {
  if (parent_name != NULL) {
    set_has_parent_name();
  } else {
    clear_has_parent_name();
  }
  parent_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.parent_name)
}

// optional uint32 parent_id = 8;
inline bool JointState::has_parent_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void JointState::set_has_parent_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void JointState::clear_has_parent_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void JointState::clear_parent_id() {
  parent_id_ = 0u;
  clear_has_parent_id();
}
inline ::google::protobuf::uint32 JointState::parent_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.parent_id)
  return parent_id_;
}
inline void JointState::set_parent_id(::google::protobuf::uint32 value) {
  set_has_parent_id();
  parent_id_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.parent_id)
}

// optional string child_name = 9;
inline bool JointState::has_child_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void JointState::set_has_child_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void JointState::clear_has_child_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void JointState::clear_child_name() {
  child_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_child_name();
}
inline const ::std::string& JointState::child_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.child_name)
  return child_name_.GetNoArena();
}
inline void JointState::set_child_name(const ::std::string& value) {
  set_has_child_name();
  child_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.child_name)
}
#if LANG_CXX11
inline void JointState::set_child_name(::std::string&& value) {
  set_has_child_name();
  child_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.JointState.child_name)
}
#endif
inline void JointState::set_child_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_child_name();
  child_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.JointState.child_name)
}
inline void JointState::set_child_name(const char* value, size_t size) {
  set_has_child_name();
  child_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.JointState.child_name)
}
inline ::std::string* JointState::mutable_child_name() {
  set_has_child_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.child_name)
  return child_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JointState::release_child_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.child_name)
  if (!has_child_name()) {
    return NULL;
  }
  clear_has_child_name();
  return child_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JointState::set_allocated_child_name(::std::string* child_name) {
  if (child_name != NULL) {
    set_has_child_name();
  } else {
    clear_has_child_name();
  }
  child_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), child_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.child_name)
}

// optional uint32 child_id = 10;
inline bool JointState::has_child_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void JointState::set_has_child_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void JointState::clear_has_child_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void JointState::clear_child_id() {
  child_id_ = 0u;
  clear_has_child_id();
}
inline ::google::protobuf::uint32 JointState::child_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.child_id)
  return child_id_;
}
inline void JointState::set_child_id(::google::protobuf::uint32 value) {
  set_has_child_id();
  child_id_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.JointState.child_id)
}

// optional .mw.internal.robotics.gazebotransport.Pose initial_anchor_pose = 11;
inline bool JointState::has_initial_anchor_pose() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void JointState::set_has_initial_anchor_pose() {
  _has_bits_[0] |= 0x00000010u;
}
inline void JointState::clear_has_initial_anchor_pose() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void JointState::clear_initial_anchor_pose() {
  if (initial_anchor_pose_ != NULL) initial_anchor_pose_->Clear();
  clear_has_initial_anchor_pose();
}
inline const ::mw::internal::robotics::gazebotransport::Pose& JointState::_internal_initial_anchor_pose() const {
  return *initial_anchor_pose_;
}
inline const ::mw::internal::robotics::gazebotransport::Pose& JointState::initial_anchor_pose() const {
  const ::mw::internal::robotics::gazebotransport::Pose* p = initial_anchor_pose_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Pose*>(
      &::mw::internal::robotics::gazebotransport::_Pose_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::release_initial_anchor_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
  clear_has_initial_anchor_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = initial_anchor_pose_;
  initial_anchor_pose_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::mutable_initial_anchor_pose() {
  set_has_initial_anchor_pose();
  if (initial_anchor_pose_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Pose>(GetArenaNoVirtual());
    initial_anchor_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
  return initial_anchor_pose_;
}
inline void JointState::set_allocated_initial_anchor_pose(::mw::internal::robotics::gazebotransport::Pose* initial_anchor_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete initial_anchor_pose_;
  }
  if (initial_anchor_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      initial_anchor_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, initial_anchor_pose, submessage_arena);
    }
    set_has_initial_anchor_pose();
  } else {
    clear_has_initial_anchor_pose();
  }
  initial_anchor_pose_ = initial_anchor_pose;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.initial_anchor_pose)
}

// optional .mw.internal.robotics.gazebotransport.Pose world_pose = 12;
inline bool JointState::has_world_pose() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void JointState::set_has_world_pose() {
  _has_bits_[0] |= 0x00000020u;
}
inline void JointState::clear_has_world_pose() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void JointState::clear_world_pose() {
  if (world_pose_ != NULL) world_pose_->Clear();
  clear_has_world_pose();
}
inline const ::mw::internal::robotics::gazebotransport::Pose& JointState::_internal_world_pose() const {
  return *world_pose_;
}
inline const ::mw::internal::robotics::gazebotransport::Pose& JointState::world_pose() const {
  const ::mw::internal::robotics::gazebotransport::Pose* p = world_pose_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.world_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Pose*>(
      &::mw::internal::robotics::gazebotransport::_Pose_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::release_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.world_pose)
  clear_has_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = world_pose_;
  world_pose_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::mutable_world_pose() {
  set_has_world_pose();
  if (world_pose_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Pose>(GetArenaNoVirtual());
    world_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.world_pose)
  return world_pose_;
}
inline void JointState::set_allocated_world_pose(::mw::internal::robotics::gazebotransport::Pose* world_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete world_pose_;
  }
  if (world_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      world_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, world_pose, submessage_arena);
    }
    set_has_world_pose();
  } else {
    clear_has_world_pose();
  }
  world_pose_ = world_pose;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.world_pose)
}

// optional .mw.internal.robotics.gazebotransport.Pose parent_world_pose = 13;
inline bool JointState::has_parent_world_pose() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void JointState::set_has_parent_world_pose() {
  _has_bits_[0] |= 0x00000040u;
}
inline void JointState::clear_has_parent_world_pose() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void JointState::clear_parent_world_pose() {
  if (parent_world_pose_ != NULL) parent_world_pose_->Clear();
  clear_has_parent_world_pose();
}
inline const ::mw::internal::robotics::gazebotransport::Pose& JointState::_internal_parent_world_pose() const {
  return *parent_world_pose_;
}
inline const ::mw::internal::robotics::gazebotransport::Pose& JointState::parent_world_pose() const {
  const ::mw::internal::robotics::gazebotransport::Pose* p = parent_world_pose_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Pose*>(
      &::mw::internal::robotics::gazebotransport::_Pose_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::release_parent_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
  clear_has_parent_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = parent_world_pose_;
  parent_world_pose_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* JointState::mutable_parent_world_pose() {
  set_has_parent_world_pose();
  if (parent_world_pose_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Pose>(GetArenaNoVirtual());
    parent_world_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
  return parent_world_pose_;
}
inline void JointState::set_allocated_parent_world_pose(::mw::internal::robotics::gazebotransport::Pose* parent_world_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parent_world_pose_;
  }
  if (parent_world_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parent_world_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parent_world_pose, submessage_arena);
    }
    set_has_parent_world_pose();
  } else {
    clear_has_parent_world_pose();
  }
  parent_world_pose_ = parent_world_pose;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.JointState.parent_world_pose)
}

// repeated .mw.internal.robotics.gazebotransport.Axis axis = 14;
inline int JointState::axis_size() const {
  return axis_.size();
}
inline void JointState::clear_axis() {
  axis_.Clear();
}
inline ::mw::internal::robotics::gazebotransport::Axis* JointState::mutable_axis(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.JointState.axis)
  return axis_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis >*
JointState::mutable_axis() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.JointState.axis)
  return &axis_;
}
inline const ::mw::internal::robotics::gazebotransport::Axis& JointState::axis(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.JointState.axis)
  return axis_.Get(index);
}
inline ::mw::internal::robotics::gazebotransport::Axis* JointState::add_axis() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.JointState.axis)
  return axis_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::Axis >&
JointState::axis() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.JointState.axis)
  return axis_;
}

// -------------------------------------------------------------------

// SetLinkWorldPose

// required string model_name = 1;
inline bool SetLinkWorldPose::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetLinkWorldPose::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetLinkWorldPose::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetLinkWorldPose::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& SetLinkWorldPose::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
  return model_name_.GetNoArena();
}
inline void SetLinkWorldPose::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}
#if LANG_CXX11
inline void SetLinkWorldPose::set_model_name(::std::string&& value) {
  set_has_model_name();
  model_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}
#endif
inline void SetLinkWorldPose::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}
inline void SetLinkWorldPose::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}
inline ::std::string* SetLinkWorldPose::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetLinkWorldPose::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
  if (!has_model_name()) {
    return NULL;
  }
  clear_has_model_name();
  return model_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkWorldPose::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.model_name)
}

// required string link_name = 2;
inline bool SetLinkWorldPose::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetLinkWorldPose::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetLinkWorldPose::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetLinkWorldPose::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& SetLinkWorldPose::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
  return link_name_.GetNoArena();
}
inline void SetLinkWorldPose::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}
#if LANG_CXX11
inline void SetLinkWorldPose::set_link_name(::std::string&& value) {
  set_has_link_name();
  link_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}
#endif
inline void SetLinkWorldPose::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}
inline void SetLinkWorldPose::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}
inline ::std::string* SetLinkWorldPose::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetLinkWorldPose::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
  if (!has_link_name()) {
    return NULL;
  }
  clear_has_link_name();
  return link_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkWorldPose::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.link_name)
}

// required .mw.internal.robotics.gazebotransport.Pose pose = 3;
inline bool SetLinkWorldPose::has_pose() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetLinkWorldPose::set_has_pose() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetLinkWorldPose::clear_has_pose() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetLinkWorldPose::clear_pose() {
  if (pose_ != NULL) pose_->Clear();
  clear_has_pose();
}
inline const ::mw::internal::robotics::gazebotransport::Pose& SetLinkWorldPose::_internal_pose() const {
  return *pose_;
}
inline const ::mw::internal::robotics::gazebotransport::Pose& SetLinkWorldPose::pose() const {
  const ::mw::internal::robotics::gazebotransport::Pose* p = pose_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Pose*>(
      &::mw::internal::robotics::gazebotransport::_Pose_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Pose* SetLinkWorldPose::release_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
  clear_has_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* SetLinkWorldPose::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Pose>(GetArenaNoVirtual());
    pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
  return pose_;
}
inline void SetLinkWorldPose::set_allocated_pose(::mw::internal::robotics::gazebotransport::Pose* pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pose_;
  }
  if (pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    set_has_pose();
  } else {
    clear_has_pose();
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.pose)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 4;
inline bool SetLinkWorldPose::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetLinkWorldPose::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetLinkWorldPose::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetLinkWorldPose::clear_duration() {
  if (duration_ != NULL) duration_->Clear();
  clear_has_duration();
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetLinkWorldPose::_internal_duration() const {
  return *duration_;
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetLinkWorldPose::duration() const {
  const ::mw::internal::robotics::gazebotransport::Time* p = duration_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Time*>(
      &::mw::internal::robotics::gazebotransport::_Time_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkWorldPose::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkWorldPose::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(GetArenaNoVirtual());
    duration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
  return duration_;
}
inline void SetLinkWorldPose::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete duration_;
  }
  if (duration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      duration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    set_has_duration();
  } else {
    clear_has_duration();
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkWorldPose.duration)
}

// -------------------------------------------------------------------

// SetLinkLinearVelocity

// required string model_name = 1;
inline bool SetLinkLinearVelocity::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetLinkLinearVelocity::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetLinkLinearVelocity::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetLinkLinearVelocity::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& SetLinkLinearVelocity::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
  return model_name_.GetNoArena();
}
inline void SetLinkLinearVelocity::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}
#if LANG_CXX11
inline void SetLinkLinearVelocity::set_model_name(::std::string&& value) {
  set_has_model_name();
  model_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}
#endif
inline void SetLinkLinearVelocity::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}
inline void SetLinkLinearVelocity::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}
inline ::std::string* SetLinkLinearVelocity::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetLinkLinearVelocity::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
  if (!has_model_name()) {
    return NULL;
  }
  clear_has_model_name();
  return model_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkLinearVelocity::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.model_name)
}

// required string link_name = 2;
inline bool SetLinkLinearVelocity::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetLinkLinearVelocity::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetLinkLinearVelocity::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetLinkLinearVelocity::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& SetLinkLinearVelocity::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
  return link_name_.GetNoArena();
}
inline void SetLinkLinearVelocity::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}
#if LANG_CXX11
inline void SetLinkLinearVelocity::set_link_name(::std::string&& value) {
  set_has_link_name();
  link_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}
#endif
inline void SetLinkLinearVelocity::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}
inline void SetLinkLinearVelocity::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}
inline ::std::string* SetLinkLinearVelocity::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetLinkLinearVelocity::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
  if (!has_link_name()) {
    return NULL;
  }
  clear_has_link_name();
  return link_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkLinearVelocity::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.link_name)
}

// required .mw.internal.robotics.gazebotransport.Point velocity = 3;
inline bool SetLinkLinearVelocity::has_velocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetLinkLinearVelocity::set_has_velocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetLinkLinearVelocity::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetLinkLinearVelocity::clear_velocity() {
  if (velocity_ != NULL) velocity_->Clear();
  clear_has_velocity();
}
inline const ::mw::internal::robotics::gazebotransport::Point& SetLinkLinearVelocity::_internal_velocity() const {
  return *velocity_;
}
inline const ::mw::internal::robotics::gazebotransport::Point& SetLinkLinearVelocity::velocity() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = velocity_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Point* SetLinkLinearVelocity::release_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
  clear_has_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* SetLinkLinearVelocity::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArenaNoVirtual());
    velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
  return velocity_;
}
inline void SetLinkLinearVelocity::set_allocated_velocity(::mw::internal::robotics::gazebotransport::Point* velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete velocity_;
  }
  if (velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.velocity)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 4;
inline bool SetLinkLinearVelocity::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetLinkLinearVelocity::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetLinkLinearVelocity::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetLinkLinearVelocity::clear_duration() {
  if (duration_ != NULL) duration_->Clear();
  clear_has_duration();
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetLinkLinearVelocity::_internal_duration() const {
  return *duration_;
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetLinkLinearVelocity::duration() const {
  const ::mw::internal::robotics::gazebotransport::Time* p = duration_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Time*>(
      &::mw::internal::robotics::gazebotransport::_Time_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkLinearVelocity::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkLinearVelocity::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(GetArenaNoVirtual());
    duration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
  return duration_;
}
inline void SetLinkLinearVelocity::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete duration_;
  }
  if (duration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      duration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    set_has_duration();
  } else {
    clear_has_duration();
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkLinearVelocity.duration)
}

// -------------------------------------------------------------------

// SetLinkAngularVelocity

// required string model_name = 1;
inline bool SetLinkAngularVelocity::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetLinkAngularVelocity::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetLinkAngularVelocity::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetLinkAngularVelocity::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& SetLinkAngularVelocity::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
  return model_name_.GetNoArena();
}
inline void SetLinkAngularVelocity::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}
#if LANG_CXX11
inline void SetLinkAngularVelocity::set_model_name(::std::string&& value) {
  set_has_model_name();
  model_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}
#endif
inline void SetLinkAngularVelocity::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}
inline void SetLinkAngularVelocity::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}
inline ::std::string* SetLinkAngularVelocity::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetLinkAngularVelocity::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
  if (!has_model_name()) {
    return NULL;
  }
  clear_has_model_name();
  return model_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkAngularVelocity::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.model_name)
}

// required string link_name = 2;
inline bool SetLinkAngularVelocity::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetLinkAngularVelocity::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetLinkAngularVelocity::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetLinkAngularVelocity::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& SetLinkAngularVelocity::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
  return link_name_.GetNoArena();
}
inline void SetLinkAngularVelocity::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}
#if LANG_CXX11
inline void SetLinkAngularVelocity::set_link_name(::std::string&& value) {
  set_has_link_name();
  link_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}
#endif
inline void SetLinkAngularVelocity::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}
inline void SetLinkAngularVelocity::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}
inline ::std::string* SetLinkAngularVelocity::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetLinkAngularVelocity::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
  if (!has_link_name()) {
    return NULL;
  }
  clear_has_link_name();
  return link_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetLinkAngularVelocity::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.link_name)
}

// required .mw.internal.robotics.gazebotransport.Point velocity = 3;
inline bool SetLinkAngularVelocity::has_velocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetLinkAngularVelocity::set_has_velocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetLinkAngularVelocity::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetLinkAngularVelocity::clear_velocity() {
  if (velocity_ != NULL) velocity_->Clear();
  clear_has_velocity();
}
inline const ::mw::internal::robotics::gazebotransport::Point& SetLinkAngularVelocity::_internal_velocity() const {
  return *velocity_;
}
inline const ::mw::internal::robotics::gazebotransport::Point& SetLinkAngularVelocity::velocity() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = velocity_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Point* SetLinkAngularVelocity::release_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
  clear_has_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* SetLinkAngularVelocity::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArenaNoVirtual());
    velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
  return velocity_;
}
inline void SetLinkAngularVelocity::set_allocated_velocity(::mw::internal::robotics::gazebotransport::Point* velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete velocity_;
  }
  if (velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, velocity, submessage_arena);
    }
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  velocity_ = velocity;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.velocity)
}

// required .mw.internal.robotics.gazebotransport.Time duration = 4;
inline bool SetLinkAngularVelocity::has_duration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SetLinkAngularVelocity::set_has_duration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SetLinkAngularVelocity::clear_has_duration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SetLinkAngularVelocity::clear_duration() {
  if (duration_ != NULL) duration_->Clear();
  clear_has_duration();
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetLinkAngularVelocity::_internal_duration() const {
  return *duration_;
}
inline const ::mw::internal::robotics::gazebotransport::Time& SetLinkAngularVelocity::duration() const {
  const ::mw::internal::robotics::gazebotransport::Time* p = duration_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Time*>(
      &::mw::internal::robotics::gazebotransport::_Time_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkAngularVelocity::release_duration() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
  clear_has_duration();
  ::mw::internal::robotics::gazebotransport::Time* temp = duration_;
  duration_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Time* SetLinkAngularVelocity::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Time>(GetArenaNoVirtual());
    duration_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
  return duration_;
}
inline void SetLinkAngularVelocity::set_allocated_duration(::mw::internal::robotics::gazebotransport::Time* duration) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete duration_;
  }
  if (duration) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      duration = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, duration, submessage_arena);
    }
    set_has_duration();
  } else {
    clear_has_duration();
  }
  duration_ = duration;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.SetLinkAngularVelocity.duration)
}

// -------------------------------------------------------------------

// GetLinkState

// required string model_name = 1;
inline bool GetLinkState::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetLinkState::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetLinkState::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetLinkState::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& GetLinkState::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
  return model_name_.GetNoArena();
}
inline void GetLinkState::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}
#if LANG_CXX11
inline void GetLinkState::set_model_name(::std::string&& value) {
  set_has_model_name();
  model_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}
#endif
inline void GetLinkState::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}
inline void GetLinkState::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}
inline ::std::string* GetLinkState::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetLinkState::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
  if (!has_model_name()) {
    return NULL;
  }
  clear_has_model_name();
  return model_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLinkState::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetLinkState.model_name)
}

// required string link_name = 2;
inline bool GetLinkState::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetLinkState::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetLinkState::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetLinkState::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& GetLinkState::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
  return link_name_.GetNoArena();
}
inline void GetLinkState::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}
#if LANG_CXX11
inline void GetLinkState::set_link_name(::std::string&& value) {
  set_has_link_name();
  link_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}
#endif
inline void GetLinkState::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}
inline void GetLinkState::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}
inline ::std::string* GetLinkState::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetLinkState::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
  if (!has_link_name()) {
    return NULL;
  }
  clear_has_link_name();
  return link_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetLinkState::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.GetLinkState.link_name)
}

// -------------------------------------------------------------------

// LinkState

// required string model_name = 1;
inline bool LinkState::has_model_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinkState::set_has_model_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinkState::clear_has_model_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinkState::clear_model_name() {
  model_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model_name();
}
inline const ::std::string& LinkState::model_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.model_name)
  return model_name_.GetNoArena();
}
inline void LinkState::set_model_name(const ::std::string& value) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.model_name)
}
#if LANG_CXX11
inline void LinkState::set_model_name(::std::string&& value) {
  set_has_model_name();
  model_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.LinkState.model_name)
}
#endif
inline void LinkState::set_model_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.LinkState.model_name)
}
inline void LinkState::set_model_name(const char* value, size_t size) {
  set_has_model_name();
  model_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.LinkState.model_name)
}
inline ::std::string* LinkState::mutable_model_name() {
  set_has_model_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.model_name)
  return model_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinkState::release_model_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.model_name)
  if (!has_model_name()) {
    return NULL;
  }
  clear_has_model_name();
  return model_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinkState::set_allocated_model_name(::std::string* model_name) {
  if (model_name != NULL) {
    set_has_model_name();
  } else {
    clear_has_model_name();
  }
  model_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.model_name)
}

// required string link_name = 2;
inline bool LinkState::has_link_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LinkState::set_has_link_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LinkState::clear_has_link_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LinkState::clear_link_name() {
  link_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_link_name();
}
inline const ::std::string& LinkState::link_name() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.link_name)
  return link_name_.GetNoArena();
}
inline void LinkState::set_link_name(const ::std::string& value) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.link_name)
}
#if LANG_CXX11
inline void LinkState::set_link_name(::std::string&& value) {
  set_has_link_name();
  link_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.LinkState.link_name)
}
#endif
inline void LinkState::set_link_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.LinkState.link_name)
}
inline void LinkState::set_link_name(const char* value, size_t size) {
  set_has_link_name();
  link_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.LinkState.link_name)
}
inline ::std::string* LinkState::mutable_link_name() {
  set_has_link_name();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.link_name)
  return link_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LinkState::release_link_name() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.link_name)
  if (!has_link_name()) {
    return NULL;
  }
  clear_has_link_name();
  return link_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LinkState::set_allocated_link_name(::std::string* link_name) {
  if (link_name != NULL) {
    set_has_link_name();
  } else {
    clear_has_link_name();
  }
  link_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), link_name);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.link_name)
}

// required uint32 link_id = 3;
inline bool LinkState::has_link_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LinkState::set_has_link_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LinkState::clear_has_link_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LinkState::clear_link_id() {
  link_id_ = 0u;
  clear_has_link_id();
}
inline ::google::protobuf::uint32 LinkState::link_id() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.link_id)
  return link_id_;
}
inline void LinkState::set_link_id(::google::protobuf::uint32 value) {
  set_has_link_id();
  link_id_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.link_id)
}

// required .mw.internal.robotics.gazebotransport.Point world_linear_velocity = 4;
inline bool LinkState::has_world_linear_velocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LinkState::set_has_world_linear_velocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LinkState::clear_has_world_linear_velocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LinkState::clear_world_linear_velocity() {
  if (world_linear_velocity_ != NULL) world_linear_velocity_->Clear();
  clear_has_world_linear_velocity();
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::_internal_world_linear_velocity() const {
  return *world_linear_velocity_;
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::world_linear_velocity() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = world_linear_velocity_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::release_world_linear_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
  clear_has_world_linear_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = world_linear_velocity_;
  world_linear_velocity_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::mutable_world_linear_velocity() {
  set_has_world_linear_velocity();
  if (world_linear_velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArenaNoVirtual());
    world_linear_velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
  return world_linear_velocity_;
}
inline void LinkState::set_allocated_world_linear_velocity(::mw::internal::robotics::gazebotransport::Point* world_linear_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete world_linear_velocity_;
  }
  if (world_linear_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      world_linear_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, world_linear_velocity, submessage_arena);
    }
    set_has_world_linear_velocity();
  } else {
    clear_has_world_linear_velocity();
  }
  world_linear_velocity_ = world_linear_velocity;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.world_linear_velocity)
}

// required .mw.internal.robotics.gazebotransport.Point world_angular_velocity = 5;
inline bool LinkState::has_world_angular_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LinkState::set_has_world_angular_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LinkState::clear_has_world_angular_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LinkState::clear_world_angular_velocity() {
  if (world_angular_velocity_ != NULL) world_angular_velocity_->Clear();
  clear_has_world_angular_velocity();
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::_internal_world_angular_velocity() const {
  return *world_angular_velocity_;
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::world_angular_velocity() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = world_angular_velocity_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::release_world_angular_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
  clear_has_world_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = world_angular_velocity_;
  world_angular_velocity_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::mutable_world_angular_velocity() {
  set_has_world_angular_velocity();
  if (world_angular_velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArenaNoVirtual());
    world_angular_velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
  return world_angular_velocity_;
}
inline void LinkState::set_allocated_world_angular_velocity(::mw::internal::robotics::gazebotransport::Point* world_angular_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete world_angular_velocity_;
  }
  if (world_angular_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      world_angular_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, world_angular_velocity, submessage_arena);
    }
    set_has_world_angular_velocity();
  } else {
    clear_has_world_angular_velocity();
  }
  world_angular_velocity_ = world_angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.world_angular_velocity)
}

// required .mw.internal.robotics.gazebotransport.Point relative_linear_velocity = 6;
inline bool LinkState::has_relative_linear_velocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LinkState::set_has_relative_linear_velocity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LinkState::clear_has_relative_linear_velocity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LinkState::clear_relative_linear_velocity() {
  if (relative_linear_velocity_ != NULL) relative_linear_velocity_->Clear();
  clear_has_relative_linear_velocity();
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::_internal_relative_linear_velocity() const {
  return *relative_linear_velocity_;
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::relative_linear_velocity() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = relative_linear_velocity_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::release_relative_linear_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
  clear_has_relative_linear_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = relative_linear_velocity_;
  relative_linear_velocity_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::mutable_relative_linear_velocity() {
  set_has_relative_linear_velocity();
  if (relative_linear_velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArenaNoVirtual());
    relative_linear_velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
  return relative_linear_velocity_;
}
inline void LinkState::set_allocated_relative_linear_velocity(::mw::internal::robotics::gazebotransport::Point* relative_linear_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete relative_linear_velocity_;
  }
  if (relative_linear_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      relative_linear_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, relative_linear_velocity, submessage_arena);
    }
    set_has_relative_linear_velocity();
  } else {
    clear_has_relative_linear_velocity();
  }
  relative_linear_velocity_ = relative_linear_velocity;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.relative_linear_velocity)
}

// required .mw.internal.robotics.gazebotransport.Point relative_angular_velocity = 7;
inline bool LinkState::has_relative_angular_velocity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LinkState::set_has_relative_angular_velocity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LinkState::clear_has_relative_angular_velocity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LinkState::clear_relative_angular_velocity() {
  if (relative_angular_velocity_ != NULL) relative_angular_velocity_->Clear();
  clear_has_relative_angular_velocity();
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::_internal_relative_angular_velocity() const {
  return *relative_angular_velocity_;
}
inline const ::mw::internal::robotics::gazebotransport::Point& LinkState::relative_angular_velocity() const {
  const ::mw::internal::robotics::gazebotransport::Point* p = relative_angular_velocity_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Point*>(
      &::mw::internal::robotics::gazebotransport::_Point_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::release_relative_angular_velocity() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
  clear_has_relative_angular_velocity();
  ::mw::internal::robotics::gazebotransport::Point* temp = relative_angular_velocity_;
  relative_angular_velocity_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Point* LinkState::mutable_relative_angular_velocity() {
  set_has_relative_angular_velocity();
  if (relative_angular_velocity_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Point>(GetArenaNoVirtual());
    relative_angular_velocity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
  return relative_angular_velocity_;
}
inline void LinkState::set_allocated_relative_angular_velocity(::mw::internal::robotics::gazebotransport::Point* relative_angular_velocity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete relative_angular_velocity_;
  }
  if (relative_angular_velocity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      relative_angular_velocity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, relative_angular_velocity, submessage_arena);
    }
    set_has_relative_angular_velocity();
  } else {
    clear_has_relative_angular_velocity();
  }
  relative_angular_velocity_ = relative_angular_velocity;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.relative_angular_velocity)
}

// optional .mw.internal.robotics.gazebotransport.Pose world_pose = 8;
inline bool LinkState::has_world_pose() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LinkState::set_has_world_pose() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LinkState::clear_has_world_pose() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LinkState::clear_world_pose() {
  if (world_pose_ != NULL) world_pose_->Clear();
  clear_has_world_pose();
}
inline const ::mw::internal::robotics::gazebotransport::Pose& LinkState::_internal_world_pose() const {
  return *world_pose_;
}
inline const ::mw::internal::robotics::gazebotransport::Pose& LinkState::world_pose() const {
  const ::mw::internal::robotics::gazebotransport::Pose* p = world_pose_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.world_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Pose*>(
      &::mw::internal::robotics::gazebotransport::_Pose_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Pose* LinkState::release_world_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.world_pose)
  clear_has_world_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = world_pose_;
  world_pose_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* LinkState::mutable_world_pose() {
  set_has_world_pose();
  if (world_pose_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Pose>(GetArenaNoVirtual());
    world_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.world_pose)
  return world_pose_;
}
inline void LinkState::set_allocated_world_pose(::mw::internal::robotics::gazebotransport::Pose* world_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete world_pose_;
  }
  if (world_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      world_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, world_pose, submessage_arena);
    }
    set_has_world_pose();
  } else {
    clear_has_world_pose();
  }
  world_pose_ = world_pose;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.world_pose)
}

// optional .mw.internal.robotics.gazebotransport.Pose relative_pose = 9;
inline bool LinkState::has_relative_pose() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LinkState::set_has_relative_pose() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LinkState::clear_has_relative_pose() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LinkState::clear_relative_pose() {
  if (relative_pose_ != NULL) relative_pose_->Clear();
  clear_has_relative_pose();
}
inline const ::mw::internal::robotics::gazebotransport::Pose& LinkState::_internal_relative_pose() const {
  return *relative_pose_;
}
inline const ::mw::internal::robotics::gazebotransport::Pose& LinkState::relative_pose() const {
  const ::mw::internal::robotics::gazebotransport::Pose* p = relative_pose_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::Pose*>(
      &::mw::internal::robotics::gazebotransport::_Pose_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::Pose* LinkState::release_relative_pose() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
  clear_has_relative_pose();
  ::mw::internal::robotics::gazebotransport::Pose* temp = relative_pose_;
  relative_pose_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::Pose* LinkState::mutable_relative_pose() {
  set_has_relative_pose();
  if (relative_pose_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::Pose>(GetArenaNoVirtual());
    relative_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
  return relative_pose_;
}
inline void LinkState::set_allocated_relative_pose(::mw::internal::robotics::gazebotransport::Pose* relative_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete relative_pose_;
  }
  if (relative_pose) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      relative_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, relative_pose, submessage_arena);
    }
    set_has_relative_pose();
  } else {
    clear_has_relative_pose();
  }
  relative_pose_ = relative_pose;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.LinkState.relative_pose)
}

// optional bool self_collide = 10;
inline bool LinkState::has_self_collide() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LinkState::set_has_self_collide() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LinkState::clear_has_self_collide() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LinkState::clear_self_collide() {
  self_collide_ = false;
  clear_has_self_collide();
}
inline bool LinkState::self_collide() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.self_collide)
  return self_collide_;
}
inline void LinkState::set_self_collide(bool value) {
  set_has_self_collide();
  self_collide_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.self_collide)
}

// optional bool gravity = 11;
inline bool LinkState::has_gravity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LinkState::set_has_gravity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LinkState::clear_has_gravity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LinkState::clear_gravity() {
  gravity_ = false;
  clear_has_gravity();
}
inline bool LinkState::gravity() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.gravity)
  return gravity_;
}
inline void LinkState::set_gravity(bool value) {
  set_has_gravity();
  gravity_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.gravity)
}

// optional bool kinematic = 12;
inline bool LinkState::has_kinematic() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LinkState::set_has_kinematic() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LinkState::clear_has_kinematic() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LinkState::clear_kinematic() {
  kinematic_ = false;
  clear_has_kinematic();
}
inline bool LinkState::kinematic() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.kinematic)
  return kinematic_;
}
inline void LinkState::set_kinematic(bool value) {
  set_has_kinematic();
  kinematic_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.kinematic)
}

// optional bool enable_wind = 13;
inline bool LinkState::has_enable_wind() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LinkState::set_has_enable_wind() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LinkState::clear_has_enable_wind() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LinkState::clear_enable_wind() {
  enable_wind_ = false;
  clear_has_enable_wind();
}
inline bool LinkState::enable_wind() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.enable_wind)
  return enable_wind_;
}
inline void LinkState::set_enable_wind(bool value) {
  set_has_enable_wind();
  enable_wind_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.enable_wind)
}

// optional bool canonical = 14;
inline bool LinkState::has_canonical() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LinkState::set_has_canonical() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LinkState::clear_has_canonical() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LinkState::clear_canonical() {
  canonical_ = false;
  clear_has_canonical();
}
inline bool LinkState::canonical() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.LinkState.canonical)
  return canonical_;
}
inline void LinkState::set_canonical(bool value) {
  set_has_canonical();
  canonical_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.LinkState.canonical)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gazebotransport
}  // namespace robotics
}  // namespace internal
}  // namespace mw

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID>() {
  return ::mw::internal::robotics::gazebotransport::PacketHeader_MsgID_descriptor();
}
template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::Packet_CoSimError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::Packet_CoSimError>() {
  return ::mw::internal::robotics::gazebotransport::Packet_CoSimError_descriptor();
}
template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior>() {
  return ::mw::internal::robotics::gazebotransport::ResetSimulation_ResetBehavior_descriptor();
}
template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE>() {
  return ::mw::internal::robotics::gazebotransport::MaxStepSize_TYPE_descriptor();
}
template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::JointState_Joint_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::JointState_Joint_Type>() {
  return ::mw::internal::robotics::gazebotransport::JointState_Joint_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_mw_2einternal_2erobotics_2egazebotransport_2eCoSimMsgs_2eproto
