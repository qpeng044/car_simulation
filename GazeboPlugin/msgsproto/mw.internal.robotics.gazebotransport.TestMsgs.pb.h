// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mw.internal.robotics.gazebotransport.TestMsgs.proto

#ifndef PROTOBUF_INCLUDED_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto
#define PROTOBUF_INCLUDED_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto 

namespace protobuf_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto
namespace mw {
namespace internal {
namespace robotics {
namespace gazebotransport {
class TestArrays;
class TestArraysDefaultTypeInternal;
extern TestArraysDefaultTypeInternal _TestArrays_default_instance_;
class TestMessage;
class TestMessageDefaultTypeInternal;
extern TestMessageDefaultTypeInternal _TestMessage_default_instance_;
class TestNestedMessage;
class TestNestedMessageDefaultTypeInternal;
extern TestNestedMessageDefaultTypeInternal _TestNestedMessage_default_instance_;
class TestPose;
class TestPoseDefaultTypeInternal;
extern TestPoseDefaultTypeInternal _TestPose_default_instance_;
class TestScalars;
class TestScalarsDefaultTypeInternal;
extern TestScalarsDefaultTypeInternal _TestScalars_default_instance_;
}  // namespace gazebotransport
}  // namespace robotics
}  // namespace internal
}  // namespace mw
namespace google {
namespace protobuf {
template<> ::mw::internal::robotics::gazebotransport::TestArrays* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::TestArrays>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::TestMessage* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::TestMessage>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::TestNestedMessage* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::TestNestedMessage>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::TestPose* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::TestPose>(Arena*);
template<> ::mw::internal::robotics::gazebotransport::TestScalars* Arena::CreateMaybeMessage<::mw::internal::robotics::gazebotransport::TestScalars>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace mw {
namespace internal {
namespace robotics {
namespace gazebotransport {

enum TestEnum {
  ITEM_A = 0,
  ITEM_B = 1
};
bool TestEnum_IsValid(int value);
const TestEnum TestEnum_MIN = ITEM_A;
const TestEnum TestEnum_MAX = ITEM_B;
const int TestEnum_ARRAYSIZE = TestEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TestEnum_descriptor();
inline const ::std::string& TestEnum_Name(TestEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TestEnum_descriptor(), value);
}
inline bool TestEnum_Parse(
    const ::std::string& name, TestEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TestEnum>(
    TestEnum_descriptor(), name, value);
}
// ===================================================================

class TestScalars : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.TestScalars) */ {
 public:
  TestScalars();
  virtual ~TestScalars();

  TestScalars(const TestScalars& from);

  inline TestScalars& operator=(const TestScalars& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestScalars(TestScalars&& from) noexcept
    : TestScalars() {
    *this = ::std::move(from);
  }

  inline TestScalars& operator=(TestScalars&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestScalars& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestScalars* internal_default_instance() {
    return reinterpret_cast<const TestScalars*>(
               &_TestScalars_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(TestScalars* other);
  friend void swap(TestScalars& a, TestScalars& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestScalars* New() const final {
    return CreateMaybeMessage<TestScalars>(NULL);
  }

  TestScalars* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestScalars>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestScalars& from);
  void MergeFrom(const TestScalars& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestScalars* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes byte_array = 7;
  bool has_byte_array() const;
  void clear_byte_array();
  static const int kByteArrayFieldNumber = 7;
  const ::std::string& byte_array() const;
  void set_byte_array(const ::std::string& value);
  #if LANG_CXX11
  void set_byte_array(::std::string&& value);
  #endif
  void set_byte_array(const char* value);
  void set_byte_array(const void* value, size_t size);
  ::std::string* mutable_byte_array();
  ::std::string* release_byte_array();
  void set_allocated_byte_array(::std::string* byte_array);

  // required string character_array = 8;
  bool has_character_array() const;
  void clear_character_array();
  static const int kCharacterArrayFieldNumber = 8;
  const ::std::string& character_array() const;
  void set_character_array(const ::std::string& value);
  #if LANG_CXX11
  void set_character_array(::std::string&& value);
  #endif
  void set_character_array(const char* value);
  void set_character_array(const char* value, size_t size);
  ::std::string* mutable_character_array();
  ::std::string* release_character_array();
  void set_allocated_character_array(::std::string* character_array);

  // required int64 integer_64 = 1;
  bool has_integer_64() const;
  void clear_integer_64();
  static const int kInteger64FieldNumber = 1;
  ::google::protobuf::int64 integer_64() const;
  void set_integer_64(::google::protobuf::int64 value);

  // required uint64 unsigned_integer_64 = 2;
  bool has_unsigned_integer_64() const;
  void clear_unsigned_integer_64();
  static const int kUnsignedInteger64FieldNumber = 2;
  ::google::protobuf::uint64 unsigned_integer_64() const;
  void set_unsigned_integer_64(::google::protobuf::uint64 value);

  // required int32 integer_32 = 3;
  bool has_integer_32() const;
  void clear_integer_32();
  static const int kInteger32FieldNumber = 3;
  ::google::protobuf::int32 integer_32() const;
  void set_integer_32(::google::protobuf::int32 value);

  // required uint32 unsigned_integer_32 = 4;
  bool has_unsigned_integer_32() const;
  void clear_unsigned_integer_32();
  static const int kUnsignedInteger32FieldNumber = 4;
  ::google::protobuf::uint32 unsigned_integer_32() const;
  void set_unsigned_integer_32(::google::protobuf::uint32 value);

  // required double binary_64 = 5;
  bool has_binary_64() const;
  void clear_binary_64();
  static const int kBinary64FieldNumber = 5;
  double binary_64() const;
  void set_binary_64(double value);

  // required float binary_32 = 6;
  bool has_binary_32() const;
  void clear_binary_32();
  static const int kBinary32FieldNumber = 6;
  float binary_32() const;
  void set_binary_32(float value);

  // required .mw.internal.robotics.gazebotransport.TestEnum enum_item = 9;
  bool has_enum_item() const;
  void clear_enum_item();
  static const int kEnumItemFieldNumber = 9;
  ::mw::internal::robotics::gazebotransport::TestEnum enum_item() const;
  void set_enum_item(::mw::internal::robotics::gazebotransport::TestEnum value);

  // required bool logical_item = 10;
  bool has_logical_item() const;
  void clear_logical_item();
  static const int kLogicalItemFieldNumber = 10;
  bool logical_item() const;
  void set_logical_item(bool value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.TestScalars)
 private:
  void set_has_integer_64();
  void clear_has_integer_64();
  void set_has_unsigned_integer_64();
  void clear_has_unsigned_integer_64();
  void set_has_integer_32();
  void clear_has_integer_32();
  void set_has_unsigned_integer_32();
  void clear_has_unsigned_integer_32();
  void set_has_binary_64();
  void clear_has_binary_64();
  void set_has_binary_32();
  void clear_has_binary_32();
  void set_has_byte_array();
  void clear_has_byte_array();
  void set_has_character_array();
  void clear_has_character_array();
  void set_has_enum_item();
  void clear_has_enum_item();
  void set_has_logical_item();
  void clear_has_logical_item();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr byte_array_;
  ::google::protobuf::internal::ArenaStringPtr character_array_;
  ::google::protobuf::int64 integer_64_;
  ::google::protobuf::uint64 unsigned_integer_64_;
  ::google::protobuf::int32 integer_32_;
  ::google::protobuf::uint32 unsigned_integer_32_;
  double binary_64_;
  float binary_32_;
  int enum_item_;
  bool logical_item_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TestArrays : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.TestArrays) */ {
 public:
  TestArrays();
  virtual ~TestArrays();

  TestArrays(const TestArrays& from);

  inline TestArrays& operator=(const TestArrays& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestArrays(TestArrays&& from) noexcept
    : TestArrays() {
    *this = ::std::move(from);
  }

  inline TestArrays& operator=(TestArrays&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestArrays& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestArrays* internal_default_instance() {
    return reinterpret_cast<const TestArrays*>(
               &_TestArrays_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TestArrays* other);
  friend void swap(TestArrays& a, TestArrays& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestArrays* New() const final {
    return CreateMaybeMessage<TestArrays>(NULL);
  }

  TestArrays* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestArrays>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestArrays& from);
  void MergeFrom(const TestArrays& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestArrays* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 integer_64 = 1;
  int integer_64_size() const;
  void clear_integer_64();
  static const int kInteger64FieldNumber = 1;
  ::google::protobuf::int64 integer_64(int index) const;
  void set_integer_64(int index, ::google::protobuf::int64 value);
  void add_integer_64(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      integer_64() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_integer_64();

  // repeated uint64 unsigned_integer_64 = 2;
  int unsigned_integer_64_size() const;
  void clear_unsigned_integer_64();
  static const int kUnsignedInteger64FieldNumber = 2;
  ::google::protobuf::uint64 unsigned_integer_64(int index) const;
  void set_unsigned_integer_64(int index, ::google::protobuf::uint64 value);
  void add_unsigned_integer_64(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      unsigned_integer_64() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_unsigned_integer_64();

  // repeated int32 integer_32 = 3;
  int integer_32_size() const;
  void clear_integer_32();
  static const int kInteger32FieldNumber = 3;
  ::google::protobuf::int32 integer_32(int index) const;
  void set_integer_32(int index, ::google::protobuf::int32 value);
  void add_integer_32(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      integer_32() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_integer_32();

  // repeated uint32 unsigned_integer_32 = 4;
  int unsigned_integer_32_size() const;
  void clear_unsigned_integer_32();
  static const int kUnsignedInteger32FieldNumber = 4;
  ::google::protobuf::uint32 unsigned_integer_32(int index) const;
  void set_unsigned_integer_32(int index, ::google::protobuf::uint32 value);
  void add_unsigned_integer_32(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      unsigned_integer_32() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_unsigned_integer_32();

  // repeated double binary_64 = 5;
  int binary_64_size() const;
  void clear_binary_64();
  static const int kBinary64FieldNumber = 5;
  double binary_64(int index) const;
  void set_binary_64(int index, double value);
  void add_binary_64(double value);
  const ::google::protobuf::RepeatedField< double >&
      binary_64() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_binary_64();

  // repeated float binary_32 = 6;
  int binary_32_size() const;
  void clear_binary_32();
  static const int kBinary32FieldNumber = 6;
  float binary_32(int index) const;
  void set_binary_32(int index, float value);
  void add_binary_32(float value);
  const ::google::protobuf::RepeatedField< float >&
      binary_32() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_binary_32();

  // repeated bytes byte_array = 7;
  int byte_array_size() const;
  void clear_byte_array();
  static const int kByteArrayFieldNumber = 7;
  const ::std::string& byte_array(int index) const;
  ::std::string* mutable_byte_array(int index);
  void set_byte_array(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_byte_array(int index, ::std::string&& value);
  #endif
  void set_byte_array(int index, const char* value);
  void set_byte_array(int index, const void* value, size_t size);
  ::std::string* add_byte_array();
  void add_byte_array(const ::std::string& value);
  #if LANG_CXX11
  void add_byte_array(::std::string&& value);
  #endif
  void add_byte_array(const char* value);
  void add_byte_array(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& byte_array() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_byte_array();

  // repeated string character_array = 8;
  int character_array_size() const;
  void clear_character_array();
  static const int kCharacterArrayFieldNumber = 8;
  const ::std::string& character_array(int index) const;
  ::std::string* mutable_character_array(int index);
  void set_character_array(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_character_array(int index, ::std::string&& value);
  #endif
  void set_character_array(int index, const char* value);
  void set_character_array(int index, const char* value, size_t size);
  ::std::string* add_character_array();
  void add_character_array(const ::std::string& value);
  #if LANG_CXX11
  void add_character_array(::std::string&& value);
  #endif
  void add_character_array(const char* value);
  void add_character_array(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& character_array() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_character_array();

  // repeated .mw.internal.robotics.gazebotransport.TestEnum enum_item = 9;
  int enum_item_size() const;
  void clear_enum_item();
  static const int kEnumItemFieldNumber = 9;
  ::mw::internal::robotics::gazebotransport::TestEnum enum_item(int index) const;
  void set_enum_item(int index, ::mw::internal::robotics::gazebotransport::TestEnum value);
  void add_enum_item(::mw::internal::robotics::gazebotransport::TestEnum value);
  const ::google::protobuf::RepeatedField<int>& enum_item() const;
  ::google::protobuf::RepeatedField<int>* mutable_enum_item();

  // repeated bool logical_item = 10;
  int logical_item_size() const;
  void clear_logical_item();
  static const int kLogicalItemFieldNumber = 10;
  bool logical_item(int index) const;
  void set_logical_item(int index, bool value);
  void add_logical_item(bool value);
  const ::google::protobuf::RepeatedField< bool >&
      logical_item() const;
  ::google::protobuf::RepeatedField< bool >*
      mutable_logical_item();

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.TestArrays)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > integer_64_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > unsigned_integer_64_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > integer_32_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > unsigned_integer_32_;
  ::google::protobuf::RepeatedField< double > binary_64_;
  ::google::protobuf::RepeatedField< float > binary_32_;
  ::google::protobuf::RepeatedPtrField< ::std::string> byte_array_;
  ::google::protobuf::RepeatedPtrField< ::std::string> character_array_;
  ::google::protobuf::RepeatedField<int> enum_item_;
  ::google::protobuf::RepeatedField< bool > logical_item_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TestNestedMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.TestNestedMessage) */ {
 public:
  TestNestedMessage();
  virtual ~TestNestedMessage();

  TestNestedMessage(const TestNestedMessage& from);

  inline TestNestedMessage& operator=(const TestNestedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestNestedMessage(TestNestedMessage&& from) noexcept
    : TestNestedMessage() {
    *this = ::std::move(from);
  }

  inline TestNestedMessage& operator=(TestNestedMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestNestedMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestNestedMessage* internal_default_instance() {
    return reinterpret_cast<const TestNestedMessage*>(
               &_TestNestedMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TestNestedMessage* other);
  friend void swap(TestNestedMessage& a, TestNestedMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestNestedMessage* New() const final {
    return CreateMaybeMessage<TestNestedMessage>(NULL);
  }

  TestNestedMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestNestedMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestNestedMessage& from);
  void MergeFrom(const TestNestedMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestNestedMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mw.internal.robotics.gazebotransport.TestScalars array_nested_message = 2;
  int array_nested_message_size() const;
  void clear_array_nested_message();
  static const int kArrayNestedMessageFieldNumber = 2;
  ::mw::internal::robotics::gazebotransport::TestScalars* mutable_array_nested_message(int index);
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TestScalars >*
      mutable_array_nested_message();
  const ::mw::internal::robotics::gazebotransport::TestScalars& array_nested_message(int index) const;
  ::mw::internal::robotics::gazebotransport::TestScalars* add_array_nested_message();
  const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TestScalars >&
      array_nested_message() const;

  // required .mw.internal.robotics.gazebotransport.TestScalars scalar_nested_message = 1;
  bool has_scalar_nested_message() const;
  void clear_scalar_nested_message();
  static const int kScalarNestedMessageFieldNumber = 1;
  private:
  const ::mw::internal::robotics::gazebotransport::TestScalars& _internal_scalar_nested_message() const;
  public:
  const ::mw::internal::robotics::gazebotransport::TestScalars& scalar_nested_message() const;
  ::mw::internal::robotics::gazebotransport::TestScalars* release_scalar_nested_message();
  ::mw::internal::robotics::gazebotransport::TestScalars* mutable_scalar_nested_message();
  void set_allocated_scalar_nested_message(::mw::internal::robotics::gazebotransport::TestScalars* scalar_nested_message);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.TestNestedMessage)
 private:
  void set_has_scalar_nested_message();
  void clear_has_scalar_nested_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TestScalars > array_nested_message_;
  ::mw::internal::robotics::gazebotransport::TestScalars* scalar_nested_message_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TestMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.TestMessage) */ {
 public:
  TestMessage();
  virtual ~TestMessage();

  TestMessage(const TestMessage& from);

  inline TestMessage& operator=(const TestMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestMessage(TestMessage&& from) noexcept
    : TestMessage() {
    *this = ::std::move(from);
  }

  inline TestMessage& operator=(TestMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestMessage& default_instance();

  enum PayloadCase {
    kTestScalar = 2,
    kTestArray = 3,
    kTestNestedMessage = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestMessage* internal_default_instance() {
    return reinterpret_cast<const TestMessage*>(
               &_TestMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TestMessage* other);
  friend void swap(TestMessage& a, TestMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestMessage* New() const final {
    return CreateMaybeMessage<TestMessage>(NULL);
  }

  TestMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestMessage& from);
  void MergeFrom(const TestMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  double header() const;
  void set_header(double value);

  // optional .mw.internal.robotics.gazebotransport.TestScalars test_scalar = 2;
  bool has_test_scalar() const;
  void clear_test_scalar();
  static const int kTestScalarFieldNumber = 2;
  private:
  const ::mw::internal::robotics::gazebotransport::TestScalars& _internal_test_scalar() const;
  public:
  const ::mw::internal::robotics::gazebotransport::TestScalars& test_scalar() const;
  ::mw::internal::robotics::gazebotransport::TestScalars* release_test_scalar();
  ::mw::internal::robotics::gazebotransport::TestScalars* mutable_test_scalar();
  void set_allocated_test_scalar(::mw::internal::robotics::gazebotransport::TestScalars* test_scalar);

  // optional .mw.internal.robotics.gazebotransport.TestArrays test_array = 3;
  bool has_test_array() const;
  void clear_test_array();
  static const int kTestArrayFieldNumber = 3;
  private:
  const ::mw::internal::robotics::gazebotransport::TestArrays& _internal_test_array() const;
  public:
  const ::mw::internal::robotics::gazebotransport::TestArrays& test_array() const;
  ::mw::internal::robotics::gazebotransport::TestArrays* release_test_array();
  ::mw::internal::robotics::gazebotransport::TestArrays* mutable_test_array();
  void set_allocated_test_array(::mw::internal::robotics::gazebotransport::TestArrays* test_array);

  // optional .mw.internal.robotics.gazebotransport.TestNestedMessage test_nested_message = 4;
  bool has_test_nested_message() const;
  void clear_test_nested_message();
  static const int kTestNestedMessageFieldNumber = 4;
  private:
  const ::mw::internal::robotics::gazebotransport::TestNestedMessage& _internal_test_nested_message() const;
  public:
  const ::mw::internal::robotics::gazebotransport::TestNestedMessage& test_nested_message() const;
  ::mw::internal::robotics::gazebotransport::TestNestedMessage* release_test_nested_message();
  ::mw::internal::robotics::gazebotransport::TestNestedMessage* mutable_test_nested_message();
  void set_allocated_test_nested_message(::mw::internal::robotics::gazebotransport::TestNestedMessage* test_nested_message);

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.TestMessage)
 private:
  void set_has_header();
  void clear_has_header();
  void set_has_test_scalar();
  void set_has_test_array();
  void set_has_test_nested_message();

  inline bool has_payload() const;
  inline void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double header_;
  union PayloadUnion {
    PayloadUnion() {}
    ::mw::internal::robotics::gazebotransport::TestScalars* test_scalar_;
    ::mw::internal::robotics::gazebotransport::TestArrays* test_array_;
    ::mw::internal::robotics::gazebotransport::TestNestedMessage* test_nested_message_;
  } payload_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TestPose : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mw.internal.robotics.gazebotransport.TestPose) */ {
 public:
  TestPose();
  virtual ~TestPose();

  TestPose(const TestPose& from);

  inline TestPose& operator=(const TestPose& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TestPose(TestPose&& from) noexcept
    : TestPose() {
    *this = ::std::move(from);
  }

  inline TestPose& operator=(TestPose&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestPose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestPose* internal_default_instance() {
    return reinterpret_cast<const TestPose*>(
               &_TestPose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(TestPose* other);
  friend void swap(TestPose& a, TestPose& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TestPose* New() const final {
    return CreateMaybeMessage<TestPose>(NULL);
  }

  TestPose* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TestPose>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TestPose& from);
  void MergeFrom(const TestPose& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestPose* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  double x() const;
  void set_x(double value);

  // required double y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  double y() const;
  void set_y(double value);

  // required double z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  double z() const;
  void set_z(double value);

  // required double w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  double w() const;
  void set_w(double value);

  // @@protoc_insertion_point(class_scope:mw.internal.robotics.gazebotransport.TestPose)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_w();
  void clear_has_w();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double x_;
  double y_;
  double z_;
  double w_;
  friend struct ::protobuf_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TestScalars

// required int64 integer_64 = 1;
inline bool TestScalars::has_integer_64() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TestScalars::set_has_integer_64() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TestScalars::clear_has_integer_64() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TestScalars::clear_integer_64() {
  integer_64_ = GOOGLE_LONGLONG(0);
  clear_has_integer_64();
}
inline ::google::protobuf::int64 TestScalars::integer_64() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.integer_64)
  return integer_64_;
}
inline void TestScalars::set_integer_64(::google::protobuf::int64 value) {
  set_has_integer_64();
  integer_64_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.integer_64)
}

// required uint64 unsigned_integer_64 = 2;
inline bool TestScalars::has_unsigned_integer_64() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TestScalars::set_has_unsigned_integer_64() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TestScalars::clear_has_unsigned_integer_64() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TestScalars::clear_unsigned_integer_64() {
  unsigned_integer_64_ = GOOGLE_ULONGLONG(0);
  clear_has_unsigned_integer_64();
}
inline ::google::protobuf::uint64 TestScalars::unsigned_integer_64() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.unsigned_integer_64)
  return unsigned_integer_64_;
}
inline void TestScalars::set_unsigned_integer_64(::google::protobuf::uint64 value) {
  set_has_unsigned_integer_64();
  unsigned_integer_64_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.unsigned_integer_64)
}

// required int32 integer_32 = 3;
inline bool TestScalars::has_integer_32() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TestScalars::set_has_integer_32() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TestScalars::clear_has_integer_32() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TestScalars::clear_integer_32() {
  integer_32_ = 0;
  clear_has_integer_32();
}
inline ::google::protobuf::int32 TestScalars::integer_32() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.integer_32)
  return integer_32_;
}
inline void TestScalars::set_integer_32(::google::protobuf::int32 value) {
  set_has_integer_32();
  integer_32_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.integer_32)
}

// required uint32 unsigned_integer_32 = 4;
inline bool TestScalars::has_unsigned_integer_32() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TestScalars::set_has_unsigned_integer_32() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TestScalars::clear_has_unsigned_integer_32() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TestScalars::clear_unsigned_integer_32() {
  unsigned_integer_32_ = 0u;
  clear_has_unsigned_integer_32();
}
inline ::google::protobuf::uint32 TestScalars::unsigned_integer_32() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.unsigned_integer_32)
  return unsigned_integer_32_;
}
inline void TestScalars::set_unsigned_integer_32(::google::protobuf::uint32 value) {
  set_has_unsigned_integer_32();
  unsigned_integer_32_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.unsigned_integer_32)
}

// required double binary_64 = 5;
inline bool TestScalars::has_binary_64() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TestScalars::set_has_binary_64() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TestScalars::clear_has_binary_64() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TestScalars::clear_binary_64() {
  binary_64_ = 0;
  clear_has_binary_64();
}
inline double TestScalars::binary_64() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.binary_64)
  return binary_64_;
}
inline void TestScalars::set_binary_64(double value) {
  set_has_binary_64();
  binary_64_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.binary_64)
}

// required float binary_32 = 6;
inline bool TestScalars::has_binary_32() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TestScalars::set_has_binary_32() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TestScalars::clear_has_binary_32() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TestScalars::clear_binary_32() {
  binary_32_ = 0;
  clear_has_binary_32();
}
inline float TestScalars::binary_32() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.binary_32)
  return binary_32_;
}
inline void TestScalars::set_binary_32(float value) {
  set_has_binary_32();
  binary_32_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.binary_32)
}

// required bytes byte_array = 7;
inline bool TestScalars::has_byte_array() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestScalars::set_has_byte_array() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestScalars::clear_has_byte_array() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestScalars::clear_byte_array() {
  byte_array_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_byte_array();
}
inline const ::std::string& TestScalars::byte_array() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
  return byte_array_.GetNoArena();
}
inline void TestScalars::set_byte_array(const ::std::string& value) {
  set_has_byte_array();
  byte_array_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
}
#if LANG_CXX11
inline void TestScalars::set_byte_array(::std::string&& value) {
  set_has_byte_array();
  byte_array_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
}
#endif
inline void TestScalars::set_byte_array(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_byte_array();
  byte_array_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
}
inline void TestScalars::set_byte_array(const void* value, size_t size) {
  set_has_byte_array();
  byte_array_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
}
inline ::std::string* TestScalars::mutable_byte_array() {
  set_has_byte_array();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
  return byte_array_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestScalars::release_byte_array() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
  if (!has_byte_array()) {
    return NULL;
  }
  clear_has_byte_array();
  return byte_array_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestScalars::set_allocated_byte_array(::std::string* byte_array) {
  if (byte_array != NULL) {
    set_has_byte_array();
  } else {
    clear_has_byte_array();
  }
  byte_array_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), byte_array);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.TestScalars.byte_array)
}

// required string character_array = 8;
inline bool TestScalars::has_character_array() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestScalars::set_has_character_array() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestScalars::clear_has_character_array() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestScalars::clear_character_array() {
  character_array_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_character_array();
}
inline const ::std::string& TestScalars::character_array() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.character_array)
  return character_array_.GetNoArena();
}
inline void TestScalars::set_character_array(const ::std::string& value) {
  set_has_character_array();
  character_array_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.character_array)
}
#if LANG_CXX11
inline void TestScalars::set_character_array(::std::string&& value) {
  set_has_character_array();
  character_array_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mw.internal.robotics.gazebotransport.TestScalars.character_array)
}
#endif
inline void TestScalars::set_character_array(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_character_array();
  character_array_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.TestScalars.character_array)
}
inline void TestScalars::set_character_array(const char* value, size_t size) {
  set_has_character_array();
  character_array_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.TestScalars.character_array)
}
inline ::std::string* TestScalars::mutable_character_array() {
  set_has_character_array();
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestScalars.character_array)
  return character_array_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestScalars::release_character_array() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TestScalars.character_array)
  if (!has_character_array()) {
    return NULL;
  }
  clear_has_character_array();
  return character_array_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestScalars::set_allocated_character_array(::std::string* character_array) {
  if (character_array != NULL) {
    set_has_character_array();
  } else {
    clear_has_character_array();
  }
  character_array_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), character_array);
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.TestScalars.character_array)
}

// required .mw.internal.robotics.gazebotransport.TestEnum enum_item = 9;
inline bool TestScalars::has_enum_item() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TestScalars::set_has_enum_item() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TestScalars::clear_has_enum_item() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TestScalars::clear_enum_item() {
  enum_item_ = 0;
  clear_has_enum_item();
}
inline ::mw::internal::robotics::gazebotransport::TestEnum TestScalars::enum_item() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.enum_item)
  return static_cast< ::mw::internal::robotics::gazebotransport::TestEnum >(enum_item_);
}
inline void TestScalars::set_enum_item(::mw::internal::robotics::gazebotransport::TestEnum value) {
  assert(::mw::internal::robotics::gazebotransport::TestEnum_IsValid(value));
  set_has_enum_item();
  enum_item_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.enum_item)
}

// required bool logical_item = 10;
inline bool TestScalars::has_logical_item() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TestScalars::set_has_logical_item() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TestScalars::clear_has_logical_item() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TestScalars::clear_logical_item() {
  logical_item_ = false;
  clear_has_logical_item();
}
inline bool TestScalars::logical_item() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestScalars.logical_item)
  return logical_item_;
}
inline void TestScalars::set_logical_item(bool value) {
  set_has_logical_item();
  logical_item_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestScalars.logical_item)
}

// -------------------------------------------------------------------

// TestArrays

// repeated int64 integer_64 = 1;
inline int TestArrays::integer_64_size() const {
  return integer_64_.size();
}
inline void TestArrays::clear_integer_64() {
  integer_64_.Clear();
}
inline ::google::protobuf::int64 TestArrays::integer_64(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.integer_64)
  return integer_64_.Get(index);
}
inline void TestArrays::set_integer_64(int index, ::google::protobuf::int64 value) {
  integer_64_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.integer_64)
}
inline void TestArrays::add_integer_64(::google::protobuf::int64 value) {
  integer_64_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.integer_64)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
TestArrays::integer_64() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.integer_64)
  return integer_64_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
TestArrays::mutable_integer_64() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.integer_64)
  return &integer_64_;
}

// repeated uint64 unsigned_integer_64 = 2;
inline int TestArrays::unsigned_integer_64_size() const {
  return unsigned_integer_64_.size();
}
inline void TestArrays::clear_unsigned_integer_64() {
  unsigned_integer_64_.Clear();
}
inline ::google::protobuf::uint64 TestArrays::unsigned_integer_64(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_64)
  return unsigned_integer_64_.Get(index);
}
inline void TestArrays::set_unsigned_integer_64(int index, ::google::protobuf::uint64 value) {
  unsigned_integer_64_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_64)
}
inline void TestArrays::add_unsigned_integer_64(::google::protobuf::uint64 value) {
  unsigned_integer_64_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_64)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
TestArrays::unsigned_integer_64() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_64)
  return unsigned_integer_64_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
TestArrays::mutable_unsigned_integer_64() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_64)
  return &unsigned_integer_64_;
}

// repeated int32 integer_32 = 3;
inline int TestArrays::integer_32_size() const {
  return integer_32_.size();
}
inline void TestArrays::clear_integer_32() {
  integer_32_.Clear();
}
inline ::google::protobuf::int32 TestArrays::integer_32(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.integer_32)
  return integer_32_.Get(index);
}
inline void TestArrays::set_integer_32(int index, ::google::protobuf::int32 value) {
  integer_32_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.integer_32)
}
inline void TestArrays::add_integer_32(::google::protobuf::int32 value) {
  integer_32_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.integer_32)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TestArrays::integer_32() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.integer_32)
  return integer_32_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TestArrays::mutable_integer_32() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.integer_32)
  return &integer_32_;
}

// repeated uint32 unsigned_integer_32 = 4;
inline int TestArrays::unsigned_integer_32_size() const {
  return unsigned_integer_32_.size();
}
inline void TestArrays::clear_unsigned_integer_32() {
  unsigned_integer_32_.Clear();
}
inline ::google::protobuf::uint32 TestArrays::unsigned_integer_32(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_32)
  return unsigned_integer_32_.Get(index);
}
inline void TestArrays::set_unsigned_integer_32(int index, ::google::protobuf::uint32 value) {
  unsigned_integer_32_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_32)
}
inline void TestArrays::add_unsigned_integer_32(::google::protobuf::uint32 value) {
  unsigned_integer_32_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_32)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TestArrays::unsigned_integer_32() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_32)
  return unsigned_integer_32_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TestArrays::mutable_unsigned_integer_32() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.unsigned_integer_32)
  return &unsigned_integer_32_;
}

// repeated double binary_64 = 5;
inline int TestArrays::binary_64_size() const {
  return binary_64_.size();
}
inline void TestArrays::clear_binary_64() {
  binary_64_.Clear();
}
inline double TestArrays::binary_64(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.binary_64)
  return binary_64_.Get(index);
}
inline void TestArrays::set_binary_64(int index, double value) {
  binary_64_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.binary_64)
}
inline void TestArrays::add_binary_64(double value) {
  binary_64_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.binary_64)
}
inline const ::google::protobuf::RepeatedField< double >&
TestArrays::binary_64() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.binary_64)
  return binary_64_;
}
inline ::google::protobuf::RepeatedField< double >*
TestArrays::mutable_binary_64() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.binary_64)
  return &binary_64_;
}

// repeated float binary_32 = 6;
inline int TestArrays::binary_32_size() const {
  return binary_32_.size();
}
inline void TestArrays::clear_binary_32() {
  binary_32_.Clear();
}
inline float TestArrays::binary_32(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.binary_32)
  return binary_32_.Get(index);
}
inline void TestArrays::set_binary_32(int index, float value) {
  binary_32_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.binary_32)
}
inline void TestArrays::add_binary_32(float value) {
  binary_32_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.binary_32)
}
inline const ::google::protobuf::RepeatedField< float >&
TestArrays::binary_32() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.binary_32)
  return binary_32_;
}
inline ::google::protobuf::RepeatedField< float >*
TestArrays::mutable_binary_32() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.binary_32)
  return &binary_32_;
}

// repeated bytes byte_array = 7;
inline int TestArrays::byte_array_size() const {
  return byte_array_.size();
}
inline void TestArrays::clear_byte_array() {
  byte_array_.Clear();
}
inline const ::std::string& TestArrays::byte_array(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
  return byte_array_.Get(index);
}
inline ::std::string* TestArrays::mutable_byte_array(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
  return byte_array_.Mutable(index);
}
inline void TestArrays::set_byte_array(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
  byte_array_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TestArrays::set_byte_array(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
  byte_array_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TestArrays::set_byte_array(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  byte_array_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
}
inline void TestArrays::set_byte_array(int index, const void* value, size_t size) {
  byte_array_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
}
inline ::std::string* TestArrays::add_byte_array() {
  // @@protoc_insertion_point(field_add_mutable:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
  return byte_array_.Add();
}
inline void TestArrays::add_byte_array(const ::std::string& value) {
  byte_array_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
}
#if LANG_CXX11
inline void TestArrays::add_byte_array(::std::string&& value) {
  byte_array_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
}
#endif
inline void TestArrays::add_byte_array(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  byte_array_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
}
inline void TestArrays::add_byte_array(const void* value, size_t size) {
  byte_array_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TestArrays::byte_array() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
  return byte_array_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TestArrays::mutable_byte_array() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.byte_array)
  return &byte_array_;
}

// repeated string character_array = 8;
inline int TestArrays::character_array_size() const {
  return character_array_.size();
}
inline void TestArrays::clear_character_array() {
  character_array_.Clear();
}
inline const ::std::string& TestArrays::character_array(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.character_array)
  return character_array_.Get(index);
}
inline ::std::string* TestArrays::mutable_character_array(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestArrays.character_array)
  return character_array_.Mutable(index);
}
inline void TestArrays::set_character_array(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.character_array)
  character_array_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TestArrays::set_character_array(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.character_array)
  character_array_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TestArrays::set_character_array(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  character_array_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mw.internal.robotics.gazebotransport.TestArrays.character_array)
}
inline void TestArrays::set_character_array(int index, const char* value, size_t size) {
  character_array_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mw.internal.robotics.gazebotransport.TestArrays.character_array)
}
inline ::std::string* TestArrays::add_character_array() {
  // @@protoc_insertion_point(field_add_mutable:mw.internal.robotics.gazebotransport.TestArrays.character_array)
  return character_array_.Add();
}
inline void TestArrays::add_character_array(const ::std::string& value) {
  character_array_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.character_array)
}
#if LANG_CXX11
inline void TestArrays::add_character_array(::std::string&& value) {
  character_array_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.character_array)
}
#endif
inline void TestArrays::add_character_array(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  character_array_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mw.internal.robotics.gazebotransport.TestArrays.character_array)
}
inline void TestArrays::add_character_array(const char* value, size_t size) {
  character_array_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mw.internal.robotics.gazebotransport.TestArrays.character_array)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TestArrays::character_array() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.character_array)
  return character_array_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TestArrays::mutable_character_array() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.character_array)
  return &character_array_;
}

// repeated .mw.internal.robotics.gazebotransport.TestEnum enum_item = 9;
inline int TestArrays::enum_item_size() const {
  return enum_item_.size();
}
inline void TestArrays::clear_enum_item() {
  enum_item_.Clear();
}
inline ::mw::internal::robotics::gazebotransport::TestEnum TestArrays::enum_item(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.enum_item)
  return static_cast< ::mw::internal::robotics::gazebotransport::TestEnum >(enum_item_.Get(index));
}
inline void TestArrays::set_enum_item(int index, ::mw::internal::robotics::gazebotransport::TestEnum value) {
  assert(::mw::internal::robotics::gazebotransport::TestEnum_IsValid(value));
  enum_item_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.enum_item)
}
inline void TestArrays::add_enum_item(::mw::internal::robotics::gazebotransport::TestEnum value) {
  assert(::mw::internal::robotics::gazebotransport::TestEnum_IsValid(value));
  enum_item_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.enum_item)
}
inline const ::google::protobuf::RepeatedField<int>&
TestArrays::enum_item() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.enum_item)
  return enum_item_;
}
inline ::google::protobuf::RepeatedField<int>*
TestArrays::mutable_enum_item() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.enum_item)
  return &enum_item_;
}

// repeated bool logical_item = 10;
inline int TestArrays::logical_item_size() const {
  return logical_item_.size();
}
inline void TestArrays::clear_logical_item() {
  logical_item_.Clear();
}
inline bool TestArrays::logical_item(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestArrays.logical_item)
  return logical_item_.Get(index);
}
inline void TestArrays::set_logical_item(int index, bool value) {
  logical_item_.Set(index, value);
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestArrays.logical_item)
}
inline void TestArrays::add_logical_item(bool value) {
  logical_item_.Add(value);
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestArrays.logical_item)
}
inline const ::google::protobuf::RepeatedField< bool >&
TestArrays::logical_item() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestArrays.logical_item)
  return logical_item_;
}
inline ::google::protobuf::RepeatedField< bool >*
TestArrays::mutable_logical_item() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestArrays.logical_item)
  return &logical_item_;
}

// -------------------------------------------------------------------

// TestNestedMessage

// required .mw.internal.robotics.gazebotransport.TestScalars scalar_nested_message = 1;
inline bool TestNestedMessage::has_scalar_nested_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestNestedMessage::set_has_scalar_nested_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestNestedMessage::clear_has_scalar_nested_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestNestedMessage::clear_scalar_nested_message() {
  if (scalar_nested_message_ != NULL) scalar_nested_message_->Clear();
  clear_has_scalar_nested_message();
}
inline const ::mw::internal::robotics::gazebotransport::TestScalars& TestNestedMessage::_internal_scalar_nested_message() const {
  return *scalar_nested_message_;
}
inline const ::mw::internal::robotics::gazebotransport::TestScalars& TestNestedMessage::scalar_nested_message() const {
  const ::mw::internal::robotics::gazebotransport::TestScalars* p = scalar_nested_message_;
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestNestedMessage.scalar_nested_message)
  return p != NULL ? *p : *reinterpret_cast<const ::mw::internal::robotics::gazebotransport::TestScalars*>(
      &::mw::internal::robotics::gazebotransport::_TestScalars_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestNestedMessage::release_scalar_nested_message() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TestNestedMessage.scalar_nested_message)
  clear_has_scalar_nested_message();
  ::mw::internal::robotics::gazebotransport::TestScalars* temp = scalar_nested_message_;
  scalar_nested_message_ = NULL;
  return temp;
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestNestedMessage::mutable_scalar_nested_message() {
  set_has_scalar_nested_message();
  if (scalar_nested_message_ == NULL) {
    auto* p = CreateMaybeMessage<::mw::internal::robotics::gazebotransport::TestScalars>(GetArenaNoVirtual());
    scalar_nested_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestNestedMessage.scalar_nested_message)
  return scalar_nested_message_;
}
inline void TestNestedMessage::set_allocated_scalar_nested_message(::mw::internal::robotics::gazebotransport::TestScalars* scalar_nested_message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete scalar_nested_message_;
  }
  if (scalar_nested_message) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      scalar_nested_message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, scalar_nested_message, submessage_arena);
    }
    set_has_scalar_nested_message();
  } else {
    clear_has_scalar_nested_message();
  }
  scalar_nested_message_ = scalar_nested_message;
  // @@protoc_insertion_point(field_set_allocated:mw.internal.robotics.gazebotransport.TestNestedMessage.scalar_nested_message)
}

// repeated .mw.internal.robotics.gazebotransport.TestScalars array_nested_message = 2;
inline int TestNestedMessage::array_nested_message_size() const {
  return array_nested_message_.size();
}
inline void TestNestedMessage::clear_array_nested_message() {
  array_nested_message_.Clear();
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestNestedMessage::mutable_array_nested_message(int index) {
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestNestedMessage.array_nested_message)
  return array_nested_message_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TestScalars >*
TestNestedMessage::mutable_array_nested_message() {
  // @@protoc_insertion_point(field_mutable_list:mw.internal.robotics.gazebotransport.TestNestedMessage.array_nested_message)
  return &array_nested_message_;
}
inline const ::mw::internal::robotics::gazebotransport::TestScalars& TestNestedMessage::array_nested_message(int index) const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestNestedMessage.array_nested_message)
  return array_nested_message_.Get(index);
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestNestedMessage::add_array_nested_message() {
  // @@protoc_insertion_point(field_add:mw.internal.robotics.gazebotransport.TestNestedMessage.array_nested_message)
  return array_nested_message_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mw::internal::robotics::gazebotransport::TestScalars >&
TestNestedMessage::array_nested_message() const {
  // @@protoc_insertion_point(field_list:mw.internal.robotics.gazebotransport.TestNestedMessage.array_nested_message)
  return array_nested_message_;
}

// -------------------------------------------------------------------

// TestMessage

// required double header = 1;
inline bool TestMessage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestMessage::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestMessage::clear_header() {
  header_ = 0;
  clear_has_header();
}
inline double TestMessage::header() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestMessage.header)
  return header_;
}
inline void TestMessage::set_header(double value) {
  set_has_header();
  header_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestMessage.header)
}

// optional .mw.internal.robotics.gazebotransport.TestScalars test_scalar = 2;
inline bool TestMessage::has_test_scalar() const {
  return payload_case() == kTestScalar;
}
inline void TestMessage::set_has_test_scalar() {
  _oneof_case_[0] = kTestScalar;
}
inline void TestMessage::clear_test_scalar() {
  if (has_test_scalar()) {
    delete payload_.test_scalar_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::TestScalars& TestMessage::_internal_test_scalar() const {
  return *payload_.test_scalar_;
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestMessage::release_test_scalar() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TestMessage.test_scalar)
  if (has_test_scalar()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::TestScalars* temp = payload_.test_scalar_;
    payload_.test_scalar_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::TestScalars& TestMessage::test_scalar() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestMessage.test_scalar)
  return has_test_scalar()
      ? *payload_.test_scalar_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::TestScalars*>(&::mw::internal::robotics::gazebotransport::_TestScalars_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::TestScalars* TestMessage::mutable_test_scalar() {
  if (!has_test_scalar()) {
    clear_payload();
    set_has_test_scalar();
    payload_.test_scalar_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::TestScalars >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestMessage.test_scalar)
  return payload_.test_scalar_;
}

// optional .mw.internal.robotics.gazebotransport.TestArrays test_array = 3;
inline bool TestMessage::has_test_array() const {
  return payload_case() == kTestArray;
}
inline void TestMessage::set_has_test_array() {
  _oneof_case_[0] = kTestArray;
}
inline void TestMessage::clear_test_array() {
  if (has_test_array()) {
    delete payload_.test_array_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::TestArrays& TestMessage::_internal_test_array() const {
  return *payload_.test_array_;
}
inline ::mw::internal::robotics::gazebotransport::TestArrays* TestMessage::release_test_array() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TestMessage.test_array)
  if (has_test_array()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::TestArrays* temp = payload_.test_array_;
    payload_.test_array_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::TestArrays& TestMessage::test_array() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestMessage.test_array)
  return has_test_array()
      ? *payload_.test_array_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::TestArrays*>(&::mw::internal::robotics::gazebotransport::_TestArrays_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::TestArrays* TestMessage::mutable_test_array() {
  if (!has_test_array()) {
    clear_payload();
    set_has_test_array();
    payload_.test_array_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::TestArrays >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestMessage.test_array)
  return payload_.test_array_;
}

// optional .mw.internal.robotics.gazebotransport.TestNestedMessage test_nested_message = 4;
inline bool TestMessage::has_test_nested_message() const {
  return payload_case() == kTestNestedMessage;
}
inline void TestMessage::set_has_test_nested_message() {
  _oneof_case_[0] = kTestNestedMessage;
}
inline void TestMessage::clear_test_nested_message() {
  if (has_test_nested_message()) {
    delete payload_.test_nested_message_;
    clear_has_payload();
  }
}
inline const ::mw::internal::robotics::gazebotransport::TestNestedMessage& TestMessage::_internal_test_nested_message() const {
  return *payload_.test_nested_message_;
}
inline ::mw::internal::robotics::gazebotransport::TestNestedMessage* TestMessage::release_test_nested_message() {
  // @@protoc_insertion_point(field_release:mw.internal.robotics.gazebotransport.TestMessage.test_nested_message)
  if (has_test_nested_message()) {
    clear_has_payload();
      ::mw::internal::robotics::gazebotransport::TestNestedMessage* temp = payload_.test_nested_message_;
    payload_.test_nested_message_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mw::internal::robotics::gazebotransport::TestNestedMessage& TestMessage::test_nested_message() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestMessage.test_nested_message)
  return has_test_nested_message()
      ? *payload_.test_nested_message_
      : *reinterpret_cast< ::mw::internal::robotics::gazebotransport::TestNestedMessage*>(&::mw::internal::robotics::gazebotransport::_TestNestedMessage_default_instance_);
}
inline ::mw::internal::robotics::gazebotransport::TestNestedMessage* TestMessage::mutable_test_nested_message() {
  if (!has_test_nested_message()) {
    clear_payload();
    set_has_test_nested_message();
    payload_.test_nested_message_ = CreateMaybeMessage< ::mw::internal::robotics::gazebotransport::TestNestedMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mw.internal.robotics.gazebotransport.TestMessage.test_nested_message)
  return payload_.test_nested_message_;
}

inline bool TestMessage::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void TestMessage::clear_has_payload() {
  _oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline TestMessage::PayloadCase TestMessage::payload_case() const {
  return TestMessage::PayloadCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TestPose

// required double x = 1;
inline bool TestPose::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TestPose::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TestPose::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TestPose::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double TestPose::x() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestPose.x)
  return x_;
}
inline void TestPose::set_x(double value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestPose.x)
}

// required double y = 2;
inline bool TestPose::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TestPose::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TestPose::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TestPose::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double TestPose::y() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestPose.y)
  return y_;
}
inline void TestPose::set_y(double value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestPose.y)
}

// required double z = 3;
inline bool TestPose::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TestPose::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TestPose::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TestPose::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double TestPose::z() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestPose.z)
  return z_;
}
inline void TestPose::set_z(double value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestPose.z)
}

// required double w = 4;
inline bool TestPose::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TestPose::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TestPose::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TestPose::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline double TestPose::w() const {
  // @@protoc_insertion_point(field_get:mw.internal.robotics.gazebotransport.TestPose.w)
  return w_;
}
inline void TestPose::set_w(double value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:mw.internal.robotics.gazebotransport.TestPose.w)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gazebotransport
}  // namespace robotics
}  // namespace internal
}  // namespace mw

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mw::internal::robotics::gazebotransport::TestEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mw::internal::robotics::gazebotransport::TestEnum>() {
  return ::mw::internal::robotics::gazebotransport::TestEnum_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_mw_2einternal_2erobotics_2egazebotransport_2eTestMsgs_2eproto
